{"0": {
    "doc": "About app architecture",
    "title": "About app architecture",
    "content": "Bu kılavuz, sağlam, yüksek kaliteli uygulamalar oluşturmak için best practiceleri ve önerilen mimariyi kapsar. Not: Bu sayfada Android Framework ile ilgili temel bilgilere sahip olduğunuz varsayılmaktadır. Android uygulama geliştirme konusunda yeniyseniz, başlamak ve bu kılavuzda bahsedilen kavramlar hakkında daha fazla bilgi edinmek için Android Basics kursu na göz atın. Mobile app user experiences . Tipik bir Android uygulaması, activities, fragments, services, content providers, and broadcast receivers dahil olmak üzere multiple app componentler içerir. Bu uygulama componentlerinin çoğunu app manifest dosyasinda bildirirsiniz. Android işletim sistemi daha sonra uygulamanızı cihazın genel kullanıcı deneyimine nasıl entegre edeceğine karar vermek için bu dosyayı kullanır. Tipik bir Android uygulamasının multiple component içerebileceği ve kullanıcıların genellikle kısa bir süre içinde birden çok uygulamayla etkileşime girdiği göz önüne alındığında, uygulamaların farklı türde kullanıcı odaklı iş akışlarına(user-driven workflows) ve tasklere uyum sağlaması gerekir. Mobil cihazlarda kaynaklarin kısıtlı olduğunu unutmayın; bu nedenle, işletim sistemi herhangi bir zamanda yenilerine yer açmak için bazı uygulama processlerini sonlandırabilir. Bu ortamın koşulları göz önüne alındığında, uygulama componentlerinizin ayrı ayrı ve duzensiz olarak başlatılması mümkündür ve işletim sistemi veya kullanıcı bunları herhangi bir zamanda sonlandirabilir. Bu olaylar sizin kontrolünüz altında olmadığından, uygulama componentlerinizdeki herhangi bir uygulama verisini veya state’ini saklamamalı veya bellekte tutmamalısınız ve uygulama componentleriniz birbirine bağimlı olmamalıdır. Common architectural principles . Uygulama verilerini ve state’ini tutumak için uygulama componentlerini kullanmamanız gerekiyorsa,peki uygulamanızı nasıl tasarlamanız gerekir? Android uygulamalarının boyutu büyüdükçe, uygulamanın ölçeklenmesini sağlayan, uygulamanın sağlamlığını artıran ve uygulamanın test edilmesini kolaylaştıran bir mimari tanımlamak önemlidir. Bir uygulama mimarisi, uygulamanın bölümleri arasındaki sınırları ve her bir bölümün sahip olması gereken sorumlulukları tanımlar. Yukarıda belirtilen ihtiyaçları karşılamak için uygulama mimarinizi birkaç belirli ilkeyi takip edecek şekilde tasarlamanız gerekir. Separation of concerns . İzlenecek en önemli ilke, separation of concers. Tüm kodunuzu bir Activity veya Fragment’a yazmak yaygın bir hatadır. Bu UI tabanlı sınıflar yalnızca UI ve işletim sistemi interactionlarini handle eden mantığı(logic) içermelidir. Bu sınıfları olabildiğince yalın tutarak, component yaşam döngüsüyle(lifecycle) ilgili birçok sorunu önleyebilir ve bu sınıfların test edilebilirliğini kolaylastirabilirsiniz. Aktivite ve Fragment implementasyonlari uzerinde bir sahipliginiz olmadığını unutmayın; bunlar yalnızca Android işletim sistemi ile uygulamanız arasındaki sözleşmeyi temsil eden glue classlardir. İşletim sistemi, kullanıcı etkileşimlerine bağlı olarak veya düşük bellek gibi sistem koşulları nedeniyle herhangi bir zamanda bunları yok edebilir. Tatmin edici bir kullanıcı deneyimi ve daha yönetilebilir bir uygulama bakım deneyimi sağlamak için bunlara bağımlılığınızı en aza indirmek en iyisidir. Drive UI from data models . Bir diğer önemli ilke, kullanıcı arayüzünüzü(UI) data modellerinden, tercihen kalıcı(persistent) modellerden olusturmaniz gerektiğidir. Data modelleri, bir uygulamanın verilerini temsil eder. Uygulamanızdaki UI öğelerinden ve diğer componentlerden bağımsızdırlar. Bu, kullanıcı arayüzüne ve uygulama bileşeni yaşam döngüsüne bağlı olmadıkları, ancak işletim sistemi uygulamanın sürecini bellekten kaldırmaya karar verdiğinde yine de yok edilecekleri anlamına gelir. Kalıcı modeller aşağıdaki nedenlerle idealdir: . | Android işletim sistemi, kaynakları boşaltmak için uygulamanızı yok ederse, kullanıcılarınız veri kaybetmez. | Uygulamanız, ağ bağlantısının kesintili olduğu veya kullanılamadığı durumlarda çalışmaya devam eder. | . Uygulama mimarinizi data model sınıflarına(viewmodel gibi) dayandırırsanız, uygulamanızı daha test edilebilir ve sağlam hale getirirsiniz. Single source of truth . Uygulamanızda yeni bir veri türü tanımlandığında, ona Tek Doğruluk Kaynağı (SSOT) atamanız gerekir. SSOT, bu verilerin sahibidir ve yalnızca SSOT onu modifiye edebilir veya değiştirebilir. Bunu başarmak için SSOT, immutable bir tip kullanarak verileri ortaya çıkarır ve verileri değiştirmek için SSOT, diğer tiplerin çağırabileceği fonksiyonlari ortaya çıkarır veya eventleri receive eder. Bu model birden fazla fayda sağlar: . | Belirli bir veri türündeki tüm değişiklikleri tek bir yerde merkezileştirir. | Diğer tiplerin kurcalamaması için verileri korur. | Verilerdeki değişiklikleri daha izlenebilir hale getirir. Böylece buglarin fark edilmesi daha kolaydır. | . Offline-first bir uygulamada, uygulama verilerinin doğruluğunun kaynağı(ssot) tipik olarak bir veritabanıdır. Diğer bazı durumlarda, kaynak bir ViewModel veya hatta UI olabilir. Unidirectional Data Flow . Doğruluğun tek kaynağı ilkesi(single source of truth principle(ssot)), Tek Yönlü Veri Akışı (UDF) modeliyle birlikte kılavuzlarımızda sıklıkla kullanılmaktadır. UDF’de state sadece bir yönde akar. Event ise veri akışını ters yönde değiştirendir. Android’de, state veya veriler genellikle hiyerarşinin yüksek scope türlerinden daha düşük scope türlere doğru akar. Eventler, ilgili veri türü için SSOT’a ulaşana kadar genellikle daha düşük scope türlerden tetiklenir. Örneğin, uygulama verileri genellikle veri kaynaklarından kullanıcı arayüzüne akar. Button basmaları gibi kullanıcı eventleri, uygulama verilerinin değiştirildiği ve immutable bir türde gösterildiği UI’den SSOT’a akar. Bu pattern, veri tutarlılığını daha iyi garanti eder, hatalara daha az eğilimlidir, hata ayıklaması(debug) daha kolaydır ve SSOT patterinin tüm avantajlarını beraberinde getirir . Recommended app architecture . Bu bölüm, önerilen best practiseleri izleyerek uygulamanızı nasıl yapılandıracağınızı gösterir. Not: Bu sayfada sunulan öneriler ve best practiseler, ölçeklenmelerine, kalite ve sağlamlığı artırmalarına ve test edilmelerini kolaylaştırmalarına olanak sağlamak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Bahsedilen ortak mimari ilkeler göz önüne alındığında, her uygulamada en az iki katman olmalıdır: . | Uygulama verilerini ekranda görüntüleyen UI layer. | Uygulamanızın iş mantığını(business logic) içeren ve uygulama verilerini ortaya çıkaran data layer. | . Kullanıcı arabirimi(UI) ve veri katmanları arasındaki etkileşimleri basitleştirmek ve yeniden kullanmak için domain layer adı verilen ek bir katman ekleyebilirsiniz. Tipik bir uygulama mimari diagrami bu sekilde gorunur. Not:Buradaki oklar katmanlar arasi bagimliliklari gostermektedir. Mesela domain layer, data layer a bagimlidir. Modern App Architecture . Bu Modern App Architecture, diğerlerinin yanı sıra aşağıdaki tekniklerin kullanılmasını teşvik eder: . | Reaktif ve katmanlı bir mimari. | Uygulamanın tüm katmanlarında Tek Yönlü Veri Akışı (UDF). | UI’nin karmaşıklığını yönetmek için state holder’ları olan bir UI layer’ı. | Coroutine’ler ve flow’lar. | Dependency injection best practiceleri. | . Daha fazla bilgi için aşağıdaki bölümlere, içindekiler tablosundaki diğer Architecture sayfalarına ve en önemli best practice’lerin bir özetini içeren öneriler sayfasına bakın. UI Layer . UI katmanının (veya presentation katmanının) rolü, uygulama verilerini ekranda görüntülemektir. Veriler, kullanıcı etkileşimi(user interaction) (bir butona basmak gibi) veya external input(network response gibi) nedeniyle değiştiğinde, UI değişiklikleri yansıtacak şekilde güncellenmelidir. UI katmanı iki şeyden oluşur: . | Ekrandaki verileri handle eden UI elementleri. Bu öğeleri Views veya Jetpack Compose fonksiyonlarini kullanarak oluşturursunuz. | Verileri tutan, kullanıcı arayüzüne(UI) sunan ve mantığı(logic) handle eden state holderlar (ViewModel sınıfları gibi). | . Bu katman hakkında daha fazla bilgi edinmek için UI layer sayfasına bakın. Data Layer . Bir uygulamanın veri katmanı, iş mantığını(business logic) içerir. İş mantığı, uygulamanıza değer veren şeydir; uygulamanızın verileri nasıl oluşturduğunu, depoladığını ve değiştirdiğini belirleyen kurallardan oluşur. Veri katmanı, her biri sıfır ila birçok veri kaynağı içerebilen repositorylerden oluşur. Uygulamanızda handle edilen her farklı veri türü için bir repository sınıfı oluşturmalısınız. Örneğin, filmlerle ilgili veriler için bir MoviesRepository sınıfı veya ödemelerle ilgili veriler için bir PaymentsRepository sınıfı oluşturabilirsiniz. Repository sınıfları aşağıdaki görevlerden sorumludur: . | Verileri uygulamanın geri kalanına göstermek. | Verilerdeki değişiklikleri merkezileştirmek. | Birden çok veri kaynağı arasındaki çakışmaları çözmek. | Uygulamanın geri kalanından veri kaynaklarını soyutlamak. | Business logic içermek. | . Her veri kaynağı sınıfı(data source class), yalnızca tek bir veri kaynağıyla çalışma sorumluluğuna sahip olmalıdır ; bu veri kaynaklari dosya, ağ kaynağı(network source) veya yerel veritabanı(local database) olabilir. Veri kaynağı sınıfları, veri işlemleri için uygulama ile sistem arasındaki köprüdür. Bu katman hakkında daha fazla bilgi edinmek için data layer sayfasına bakın. Domain Layer . Domain katmanı(domain layer), kullanıcı arayüzü(UI layer) ve veri katmanları(data layer) arasında bulunan isteğe bağlı bir katmandır. Domain katmanı, karmaşık business logic’in veya birden fazla ViewModel tarafından yeniden kullanılan basit business logic’in enkapsüle edilmesinden sorumludur. Bu katman isteğe bağlıdır çünkü tüm uygulamalar bu gereksinimlere sahip olmayacaktır. Yalnızca gerektiğinde, örneğin karmaşıklığı yönetmek veya yeniden kullanılabilirliği desteklemek için kullanmalısınız. Bu katmandaki sınıflara yaygın olarak use case veya interactors denir. Her use case`in tek bir fonksiyonalite üzerinde sorumluluğu olmalıdır. Örneğin, birden fazla ViewModels, ekranda doğru mesajı görüntülemek için saat dilimlerine ihtiyac duyuyorsa, uygulamanız bir GetTimeZoneUseCase sınıfına sahip olabilir. Bu katman hakkında daha fazla bilgi edinmek için domain layer sayfasına bakın. Manage dependencies between components . Uygulamanızdaki sınıflar, düzgün çalışması için diğer sınıflara bağlıdır. Belirli bir sınıfın bağımlılıklarını toplamak için aşağıdaki design patternlerinden birini kullanabilirsiniz: . Dependency Injection: siniflarin bagimliliklarini olusturmadan tanimlamalarina izin verir. Runtime’da , bu bagimliliklari saglamaktan baska bir sinif sorumludur. Service Locater: siniflarin bagimliliklarini olusturmak yerine elde edebilecekleri registry saglar. Bu patternler, kodu çoğaltmadan veya karmaşıklık eklemeden bağımlılıkları yönetmek için clear pattern sağladıkları için kodunuzu ölçeklendirmenize olanak tanır. Ayrıca bu patternler, test ve production implementasyonlari arasında hızla geçiş yapmanızı sağlar. Android official olarak dependency leri yonetmek icin HILT librarysini onermektedir. Hilt, bağımlılık ağacında dolaşarak nesneleri otomatik olarak oluşturur, bağımlılıklara ilişkin derleme zamanı garantileri sağlar ve Android çerçeve sınıfları için bağımlılık containerlari oluşturur. General Best Practices . Programlama yaratıcı bir alandır ve Android uygulamaları oluşturmak da bir istisna değildir. Bir sorunu çözmenin birçok yolu vardır; verileri birden fazla activity veya fragment arasında iletebilir, uzaktaki verileri alıp offline mod için local olarak tutabilir veya basit olmayan uygulamaların karşılaştığı diğer yaygın senaryoları ele alabilirsiniz. Aşağıdaki öneriler zorunlu olmamakla birlikte, çoğu durumda bunları uygulamak kod tabanınızı uzun vadede daha sağlam, test edilebilir ve sürdürülebilir hale getirir: . Don`t store data in app components. Uygulamanizin activitileri, servisleri ve broadcast receiverlari gibi entry pointlerini veri kaynagi olarak belirlemekten kacinin. Veri kaynagi olarak belirlemek yerine o entry pointler ilgili veri alt kumelerini geri almak icin diger comoponentler ile koordine olmalidir. Her uygulama componenti, kullanıcının cihazıyla etkileşimine ve sistemin genel mevcut durumuna bağlı olarak oldukça kısa ömürlüdür. Reduce dependencies on Android classes. Uygulama componentleriniz, Context veya Toast gibi Android framework SDK API’lerine dayanan tek sınıf olmalıdır. Uygulamanızdaki diğer sınıfları onlardan soyutlamak, test edilebilirliğe yardımcı olur ve uygulamanızdaki coupling i azaltır. Create well-defined boundaries(sinirlari) of responsibility between various(cesitli) modules in your app. Örneğin, ağdan veri yükleyen kodu kod tabanınızdaki birden fazla sınıfa veya pakete yaymayın. Benzer şekilde, aynı sınıfta data caching ve data binding gibi birden fazla ilgisiz sorumluluk tanımlamayın. Önerilen uygulama mimarisini takip etmek bu konuda size yardımcı olacaktır. Modüllere mümkün olduğunca az maruz kalın.( Expose as little as possible from each module.) . Örneğin, bir modülden dahili bir implementasyon ayrıntısını ortaya cikaran bir kısayol oluşturmaya cezbedilmeyin. Kısa vadede biraz zaman kazanabilirsiniz, ancak code baseniz geliştikçe birçok kez teknik borçla karşılaşmanız olasıdır. Focus on the unique core of your app so it stands out from other apps. Ayni boilerplate(basmakalip) kodu tekrar tekrar yazarak tekerlegi yeniden icat etmeye gerek yoktur. Bunun yerine, zamanınızı ve enerjinizi uygulamanızı benzersiz kılan şeylere odaklayın ,Jetpack kutuphanelerinin ve önerilen diğer kutuphanelerin tekrar eden boilerplateleri handle etmesine izin verin. Consider how to make each part of your app testable in isolation.(Uygulamanizin her parcasini nasil ayri ayri test edilebilir hale gelecegini dusunun ) . Örneğin, ağdan veri almak için iyi tanımlanmış bir API’ye sahip olmak, bu verileri yerel bir veritabanında tutan modülün test edilmesini kolaylaştırır. Bunun yerine, bu iki modülün mantığını tek bir yerde mixlerseniz veya ağ kodunuzu tüm cade base e dağıtırsanız, etkili bir şekilde test etmek çok daha zor - imkansız değilse de - olur. Tipler, eşzamanlılık(concurrency) ilkelerinden sorumludur. Bir tip long-running blocking işi yapıyorsa, bu computation’u doğru thread e taşımaktan sorumlu olmalıdır. Bu belirli tip, yaptığı hesaplamanın tipini ve hangi threadde yürütülmesi gerektiğini bilir. Tipler main thread için main safe olmalıdır, yani bloklanmadan main threadden safe call etmektir. Mümkün olduğu kadar alakalı ve yeni verilerde ısrar edin. Bu şekilde kullanıcılar, cihazları çevrimdışı moddayken bile uygulamanızın işlevselliğinin keyfini çıkarabilir. Tüm kullanıcılarınızın sürekli, yüksek hızlı bağlantıya sahip olmadığına, sahip olsalar bile kalabalık yerlerde kötü sinyal alabileceklerini unutmayın. Benefits of Architecture (Mimarinin faydalari) . Uygulamanızda iyi bir Mimarinin uygulanması, proje ve mühendislik ekiplerine birçok fayda sağlar: . | Uygulamanin genel gidisatini, sürdürülebilirliğini, kalitesini ve sağlamlığını artırır. | Uygulamanın ölçeklenmesini sağlar. Daha fazla kişi ve daha fazla takim, minimum kod çakışmasıyla aynı code base e katkıda bulunabilir. | Alışmaya yardımcı olur. Mimari projenize tutarlılık katarken, ekibin yeni üyeleri hızla hızlanabilir ve daha kısa sürede daha verimli olabilir. | Test etmek daha kolaydır. İyi bir Mimari, genellikle test edilmesi daha kolay olan daha basit türleri teşvik eder. | Buglar, iyi tanımlanmış süreçlerle metodik olarak araştırılabilir. | . Mimariye yatırım yapmanın kullanıcılarınız üzerinde de doğrudan bir etkisi vardır. Daha istikrarlı bir uygulamadan ve daha üretken bir mühendislik ekibi sayesinde daha fazla özellikten faydalanırlar. Bununla birlikte, Mimari aynı zamanda öncelikli bir zaman yatırımı gerektirir. Bu zamanı şirketinizin geri kalanına gerekçelendirmenize yardımcı olması için, diğer şirketlerin uygulamalarında iyi bir mimariye sahip olduklarında başarı hikayelerini paylaştıkları bu vaka çalışmalarına bir göz atın. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/about-app-architecture/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/about-app-architecture/"
  },"1": {
    "doc": "About App Bundles",
    "title": "About Android App Bundles",
    "content": "Önemli: Ağustos 2021’den itibaren yeni uygulamaların Google Play’de Android App Bundle ile yayınlanması gerekmektedir. Artık 150 MB’tan büyük yeni uygulamalar Play Feature Delivery veya Play Asset Delivery tarafından desteklenmektedir. Android App Bundle, uygulamanızın tüm derlenmiş kodunu ve kaynaklarını içeren ve APK oluşturma ve imzalama işlemlerini Google Play’e bırakan bir yayınlama biçimidir. Google Play, her cihaz yapılandırması için optimize edilmiş APK’lar oluşturmak ve sunmak için app bundle’ınızı kullanır, böylece uygulamanızı çalıştırmak için yalnızca belirli bir cihaz için gereken kod ve kaynaklar indirilir. Artık farklı cihazlara yönelik desteği optimize etmek için birden fazla APK oluşturmanız, imzalamanız ve yönetmeniz gerekmiyor ve kullanıcılar daha küçük, daha optimize edilmiş indirmeler elde ediyor. Çoğu uygulama projesi, optimize edilmiş APK’ların sunulmasını destekleyen app bundle’ları oluşturmak için fazla çaba gerektirmez. Örneğin, uygulamanızın kodunu ve kaynaklarını zaten yerleşik kurallara göre düzenliyorsanız, Android Studio’yu veya komut satırını kullanarak imzalı Android App Bundle’ları oluşturmanız ve bunları Google Play’e yüklemeniz yeterlidir. Optimize edilmiş APK hizmeti otomatik bir avantaj haline gelir. Uygulamanızı yayınlamak için app bundle biçimini kullandığınızda, isteğe bağlı olarak uygulama projenize feature modülleri eklemenize olanak tanıyan Play Feature Delivery özelliğinden de yararlanabilirsiniz. Bu modüller, yalnızca sizin belirlediğiniz koşullara bağlı olarak uygulamanıza dahil edilen veya daha sonra çalışma zamanında Play Core Library kullanılarak indirilebilen özellikler ve kaynaklar içerir. Uygulamalarını app bundle’larla yayınlayan oyun geliştiricileri Play Asset Delivery’yi kullanabilir: Google Play’in geliştiricilere esnek sunum yöntemleri ve yüksek performans sunan büyük miktarda oyun asset’i sunma çözümü. Uygulamanızı neden Android App Bundle’ları kullanarak yayınlamanız gerektiğine dair genel bir bakış için aşağıdaki videoyu izleyin. Top 7 takeaways for Android App Bundles . Compressed download size restriction . Android App Bundle’lar ile yayınlamak, kullanıcılarınızın uygulamanızı mümkün olan en küçük indirme ile yüklemelerine yardımcı olur ve sıkıştırılmış indirme boyutu sınırını 150 MB’a çıkarır. Yani, bir kullanıcı uygulamanızı indirdiğinde, uygulamanızı yüklemek için gereken sıkıştırılmış APK’ların toplam boyutu (örneğin, temel APK + yapılandırma APK’ları) 150 MB’den fazla olmamalıdır. İsteğe bağlı olarak bir feature modülünün (ve yapılandırma APK’larının) indirilmesi gibi sonraki tüm indirmeler de bu sıkıştırılmış indirme boyutu kısıtlamasını karşılamalıdır. Asset paketleri bu boyut sınırına katkıda bulunmaz, ancak başka boyut kısıtlamaları vardır. Uygulama paketinizi yüklediğinizde, Play Console uygulamanızın veya isteğe bağlı özelliklerinin olası indirmelerinden herhangi birinin 150 MB’tan fazla olduğunu tespit ederse bir hata alırsınız. Android App Bundle’ların APK genişletme (*.obb) dosyalarını desteklemediğini unutmayın. Bu nedenle, app bundle’ınızı yayınlarken bu hatayla karşılaşırsanız, sıkıştırılmış APK indirme boyutlarını azaltmak için aşağıdaki kaynaklardan birini kullanın: . | Her yapılandırma APK’sı türü için enableSplit = true ayarını yaparak tüm yapılandırma APK’larını etkinleştirdiğinizden emin olun. Bu, kullanıcıların yalnızca uygulamanızı cihazlarında çalıştırmak için ihtiyaç duydukları kodu ve kaynakları indirmelerini sağlar. | Kullanılmayan kod ve kaynakları kaldırarak uygulamanızı küçülttüğünüzden emin olun. | Uygulama boyutunu daha da azaltmak için en iyi uygulamaları izleyin. | Yalnızca bazı kullanıcılarınız tarafından kullanılan özellikleri, uygulamanızın daha sonra isteğe bağlı olarak indirebileceği feature modüllerine dönüştürmeyi düşünün. Bunun uygulamanızın yeniden düzenlenmesini gerektirebileceğini unutmayın, bu nedenle önce yukarıda açıklanan diğer önerileri denediğinizden emin olun. | . Other considerations . Aşağıda, uygulamanızı Android App Bundle’lar ile oluştururken veya sunarken şu anda bilinen sorunlar yer almaktadır. Aşağıda açıklanmayan sorunlarla karşılaşırsanız, lütfen bir hata bildirin. | Google Play Store kullanılarak yüklenmeyen ve bir veya daha fazla required split APK’sı eksik olan sideloaded uygulamaların kısmi yüklemeleri, Google onaylı tüm cihazlarda ve Android 10 (API düzeyi 29) veya daha üstünü çalıştıran cihazlarda başarısız olur. Uygulamanızı Google Play Store üzerinden indirirken Google, uygulamanın gerekli tüm bileşenlerinin yüklenmesini sağlar.\\ . | Kaynak tablolarını dinamik olarak değiştiren araçlar kullanırsanız, app bundle’lardan oluşturulan APK’lar beklenmedik şekilde davranabilir. Bu nedenle, bir app bundle oluştururken bu tür araçları devre dışı bırakmanız önerilir. | Şu anda bir feature modülünün derleme yapılandırmasında temel (veya diğer) modüllerdekilerle çakışan özellikler yapılandırmak mümkündür. Örneğin, temel modülde buildTypes.release.debuggable = true olarak ayarlayabilir ve bir feature modülünde bunu false olarak ayarlayabilirsiniz. Bu tür çakışmalar derleme ve çalışma zamanı sorunlarına neden olabilir. Varsayılan olarak, feature modüllerinin bazı derleme yapılandırmalarını temel modülden miras aldığını unutmayın. Bu nedenle, feature modülü derleme yapılandırmanızda hangi yapılandırmaları tutmanız ve hangilerini çıkarmanız gerektiğini anladığınızdan emin olun. | . ",
    "url": "/docs/core-topics/android-app-bundles/about-app-bundles/#about-android-app-bundles",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-app-bundles/#about-android-app-bundles"
  },"2": {
    "doc": "About App Bundles",
    "title": "Additional resources",
    "content": "Android App Bundle’lar hakkında daha fazla bilgi edinmek için aşağıdaki kaynaklara başvurun. Blogs . Videos . ",
    "url": "/docs/core-topics/android-app-bundles/about-app-bundles/#additional-resources",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-app-bundles/#additional-resources"
  },"3": {
    "doc": "About App Bundles",
    "title": "About App Bundles",
    "content": " ",
    "url": "/docs/core-topics/android-app-bundles/about-app-bundles/",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-app-bundles/"
  },"4": {
    "doc": "About app links",
    "title": "About app links",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/about-app-links/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/about-app-links/"
  },"5": {
    "doc": "About app manifests",
    "title": "About app manifests",
    "content": "Her uygulama projesinin, proje kaynak kümesinin rootunda bir AndroidManifest.xml dosyası (tam olarak bu ada sahip) olması gerekir. Manifest dosyası, uygulamanızla ilgili temel bilgileri Android build toollarina, Android işletim sistemine ve Google Play’e açıklar. Diğer birçok şeyin yanı sıra, manifest dosyasının aşağıdakileri bildirmesi gerekir: . | Uygulamanin componentleri, tum activityleri, serviceleri, broadcast receiverlari, ve content providerlari icerir. Her component temel özellikleri tanımlamalıdır; Kotlin veya Java sınıfının adı gibi. Ayrıca, hangi cihaz konfigürasyonlarını destekleyebilecegi ve componentleri nasıl başlatılabileceğini açıklayan intent filterlar gibi yetenekleri de bildirebilir. | Sistemin korumalı bölümlerine veya diğer uygulamalara erişmek için uygulamanın ihtiyaç duyduğu izinler. Ayrıca, bu uygulamadan içeriğe erişmek istiyorlarsa diğer uygulamaların sahip olması gereken izinleri de bildirir. | Uygulamanın gerektirdiği donanım ve yazılım özellikleri, uygulamayı Google Play’den hangi cihazların yükleyebileceğini etkiler. Manifest icerisind bu bilgileride beyan ederiz. | . Uygulamanızı oluşturmak için Android Studio kullanıyorsanız, manifest dosyası sizin için oluşturulur ve temel manifest öğelerinin çoğu, uygulamanızı oluştururken eklenir (özellikle kod şablonlarını kullanırken). ",
    "url": "/docs/app-basics/about-app-manifests/",
    
    "relUrl": "/docs/app-basics/about-app-manifests/"
  },"6": {
    "doc": "About app manifests",
    "title": "File features",
    "content": "Aşağıdaki bölümlerde, uygulamanızın en önemli özelliklerinden bazılarının manifest dosyasına nasıl eklendigi açıklanmaktadır. App components . Uygulamanızda oluşturduğunuz her uygulama componenti için manifest dosyasında karşılık gelen bir XML öğesi bildirmeniz gerekir: . - Activityler için &lt;activity&gt; elementi - Service'ler için &lt;service&gt; elementi - Broadcast receiver'lar için &lt;receiver&gt; elementi - Content provider'lar için &lt;provider&gt; elementi . Bu componentlerden herhangi birini manifest dosyasında bildirmeden alt sınıflara ayırırsanız, sistem onu ​​başlatamaz. Alt sınıfınızın adı, tam paket adi kullanılarak name attribute ile belirtilmelidir. Örneğin, bir Activity alt sınıfı aşağıdaki gibi bildirilebilir: . &lt;manifest ... &gt; &lt;application ... &gt; &lt;activity android:name=\"com.example.myapp.MainActivity\" ... &gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; . Ancak, name değerindeki ilk karakter bir noktaysa, uygulamanın namespace i (modül düzeyindeki build.gradle dosyasının namespace özelliğinden) name in önüne cozumlenirken eklenir. Örneğin, namespace “com.example.myapp” ise, aşağıdaki activity adı “com.example.myapp.MainActivity”` olarak çözümlenir: . &lt;manifest ... &gt; &lt;application ... &gt; &lt;activity android:name=\".MainActivity\" ... &gt; ... &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; . Alt paketlerde (com.example.myapp.purchases gibi) bulunan uygulama componentleriniz varsa, name değeri eksik alt paket adlarını (“.purchases.PayActivity” gibi) eklemeli veya fully qualified (nitelikli) paket adı kullanmalıdır. Intent filters . Uygulama activityleri, serviceleri, and broadcast receiverlari intentlere göre etkinleştirilir. Bir intent, üzerinde işlem(action) yapılacak veriler, işlemi (acton) gerçekleştirmesi gereken component kategorisi ve diğer talimatlar dahil, gerçekleştirilecek bir eylemi tanımlayan bir Intent objesi tarafından tanımlanan bir mesajdır. Bir uygulama sisteme bir intent tanimladiginda, sistem, her uygulamanın manifest dosyasındaki Intent filter bildirimlerine dayalı olarak Intenti handle edebilecek bir uygulama bileşeni bulur. Sistem, eşleşen componentin bir instanceni başlatır ve Intent nesnesini bu componente iletir. Birden fazla uygulama intenti handle edebiliyorsa, kullanıcı hangi uygulamayi kullanılacağını seçebilir. Mesela galerimizden bir fotograf paylasacagiz, fotografi secip paylas butonuna tikladigimizda sistem yukaridaki islemleri yapar ve fb, insta, whatsapp gibi secenekler gosterir. Bir uygulama componenti, her biri o componentin farklı bir yeteneğini tanımlayan herhangi bir sayıda intent filter a ( öğesiyle tanımlanır) sahip olabilir. Icons and labels . Bir dizi manifest elementi, ilgili uygulama componenti için kullanıcılara sırasıyla küçük bir icon ve bir text label görüntülemek için icon ve label attributelerine sahiptir. Her durumda, bir parent elementde set edilen icon ve label, tüm child elementler için varsayılan icon ve label değeri olur. Örneğin, elementinde ayarlanan icon ve label, uygulamanın her bir componenti için (tüm activityler gibi) varsayılan icon ve labeldir. Bir componentin içinde ayarlanan icon ve label, o component bir intenti yerine getirmek için bir seçenek olarak sunulduğunda kullanıcıya gösterilir. Default olarak, bu icon, parent component için bildirilen icondan ( veya elementi) devralanir, seçici iletişim kutusunda(chooser dialog) daha iyi belirtmek istediğiniz unique bir eylem sağlıyorsa, bir intent filterin iconunu değiştirmek isteyebilirsiniz. Permissions . Android uygulamaları, hassas kullanıcı verilerine (kişiler ve SMS gibi) veya belirli sistem özelliklerine (kamera ve internet erişimi gibi) erişmek için izin istemelidir. Her izin unique bir label ile tanımlanır(“android.permission.SEND_SMS“ gibi). Örneğin, SMS mesajları göndermesi gereken bir uygulamanın manifest dosyasinda şu satırı olması gerekir: . &lt;manifest ... &gt; &lt;uses-permission android:name=\"android.permission.SEND_SMS\"/&gt; ... &lt;/manifest&gt; . Android 6.0’dan (API düzeyi 23) başlayarak, kullanıcı runtimeda bazı uygulama izinlerini onaylayabilir veya reddedebilir. Ancak uygulamanızın hangi Android sürümünü desteklediği önemli değil, tüm izin isteklerini manifest dosyasinda bir elementi ile bildirmeniz gerekir. Kullanici izin verirse, uygulama korunan özellikleri kullanabilir. Izin vermezse, bu özelliklere erişme girişimleri başarısız olur. Uygulamanız ayrıca kendi componentilerini izinlerle koruyabilir. Android.Manifest.permission içinde listelendiği gibi Android tarafından tanımlanan izinlerden herhangi birini veya başka bir uygulamada bildirilen bir izni kullanabilir. Uygulamanız kendi izinlerini de tanımlayabilir. elementi ile yeni bir izin bildirilebilir. Device compatibility . Manifest dosyası ayrıca, uygulamanızın ne tür donanım veya yazılım özelliklerini gerektirdiğini ve dolayısıyla uygulamanızın hangi tür cihazlarla uyumlu olduğunu bildirebileceğiniz yerdir. Google Play Store, uygulamanızın gerektirdiği özellikleri veya sistem sürümünü sağlamayan cihazlara uygulamanızın yüklenmesine izin vermez. Uygulamanızın hangi cihazlarla uyumlu olduğunu tanımlayan birkaç manifest tagi vardır. Aşağıdakiler en yaygın etiketlerden sadece birkaçıdır. ***:*** elementi, uygulamanızın ihtiyaç duyduğu donanım ve yazılım özelliklerini bildirmenize olanak tanır. Örneğin, uygulamanız pusula sensörü olmayan bir cihazda temel işlevleri gerçekleştiremezse pusula sensörünü aşağıdaki manifest tagiyle gerektiği gibi bildirebilirsiniz: . &lt;manifest ... &gt; &lt;uses-feature android:name=\"android.hardware.sensor.compass\" android:required=\"true\" /&gt; ... &lt;/manifest&gt; . ***:*** Birbirini izleyen her platform sürümü, genellikle önceki sürümde bulunmayan yeni API'ler ekler. Uygulamanızın uyumlu olduğu minimum sürümü belirtmek için manifestiniz `` tagini ve minSdkVersion attributeni içermelidir. Ancak, elementindeki attributelerin build.gradle dosyasındaki karşılık gelen propertyler tarafından override edildigine dikkat edin. Dolayısıyla, Android Studio kullanıyorsanız, bunun yerine minSdkVersion ve targetSdkVersion değerlerini belirtmelisiniz: . android { defaultConfig { applicationId 'com.example.myapp' // Defines the minimum API level required to run the app. minSdkVersion 21 // Specifies the API level used to test the app. targetSdkVersion 33 ... } } . ",
    "url": "/docs/app-basics/about-app-manifests/#file-features",
    
    "relUrl": "/docs/app-basics/about-app-manifests/#file-features"
  },"7": {
    "doc": "About app manifests",
    "title": "File conventions",
    "content": "Bu bölüm, manifest dosyasındaki tüm elementler ve attributeslere genel olarak uygulanan sözleşmeler ve kurallari açıklar. Elements Yalnızca &lt;manifest&gt; ve &lt;application&gt; elementleri gereklidir. Her biri yalnızca bir kez yazilir. Diğer elementlerin çoğu sıfır veya daha fazla kez oluşabilir. Ancak, manifest dosyasının kullanışlı olması için bazılarının mevcut olması gerekir. Tüm değerler, bir öğe içindeki karakter verileri olarak değil, attributeler aracılığıyla ayarlanır. Aynı seviyedeki elementler genellikle sıralanmaz. Örneğin, &lt;activity&gt;, &lt;provider&gt; ve &lt;service&gt; öğeleri herhangi bir sırada yerleştirilebilir. Bu kuralın iki önemli istisnası vardır: . Bir &lt;activity-alias&gt; öğesi, diğer adı olan &lt;activity&gt; öğesini izlemelidir. &lt;application&gt; öğesi, &lt;manifest&gt; öğesi içindeki son element olmalıdır. Attributes . Teknik olarak, butun attributeler opsiyoneldi. Ancak, bir elementin amacını gerçekleştirebilmesi için bircok attribute belirtilmek zorundadir. Gercekten opsiyonel attributeler, referans dokumantasyonda default degerleri ile gosterilir. Root &lt;manifest&gt; elementinin bazi attributeleri disinda, butun attributelerin adlari android: oneki(prefix) ile baslar. Ornegin, android:alwaysRetainTaskState. Cunku prefixler evrenseldir, bu dokumantasyon, attributelere isimle atıfta bulunurken genellikle prefixi atlar. Multiple Values . Birden fazla değer belirtilebilirse, tek bir element içinde birden çok değerin listelenmesi yerine, element hemen hemen her zaman tekrarlanır. Örneğin, bir intent filter birkaç action listeleyebilir: . &lt;intent-filter ... &gt; &lt;action android:name=\"android.intent.action.EDIT\" /&gt; &lt;action android:name=\"android.intent.action.INSERT\" /&gt; &lt;action android:name=\"android.intent.action.DELETE\" /&gt; ... &lt;/intent-filter&gt; . Resource values . Bazı attributelerin, bir activitynin başlığı veya uygulamanızın iconu gibi kullanıcılara görüntülenen değerleri vardır. Bu attributelerin değeri, kullanıcının diline veya diğer cihaz konfigürasyonlarına (cihazın piksel yoğunluğuna göre farklı bir icon boyutu sağlamak gibi) bağlı olarak farklılık gösterebilir, bu nedenle manifest dosyasına sabit kodlanmış değerler yerine bir kaynaktan veya temadan ayarlanmalıdır. Guncel değer daha sonra farklı cihaz konfigürasyonları için sağladığınız alternatif kaynaklara göre değişebilir. Kaynaklar, aşağıdaki formatta değerler olarak ifade edilir: \"@[package:]type/name\" . Kaynak uygulamanız tarafından sağlanıyorsa paket adını atlayabilirsiniz (library kaynakları sizinkiyle birleştirildiğinden(merge), bir library bağımlılığı tarafından sağlanıp sağlanmadığı dahil). Android frameworkunden bir kaynak kullanmak istediğinizde, tek geçerli paket adı, android dir. Type, string veya drawable gibi bir kaynak türüdür ve name, belirli kaynağı tanımlayan addır. İşte bir örnek: . &lt;activity android:icon=\"@drawable/smallPic\" ... &gt; . String values . Attribute değeri bir string olduğunda, karakterlerden kaçmak için çift ters eğik çizgi (\\) kullanmalısınız, örneğin yeni satır için \\n veya Unicode karakter için \\uxxxx gibi. ## Manifest elements reference . ",
    "url": "/docs/app-basics/about-app-manifests/#file-conventions",
    
    "relUrl": "/docs/app-basics/about-app-manifests/#file-conventions"
  },"8": {
    "doc": "About app manifests",
    "title": "Example manifest file",
    "content": "Aşağıdaki XML, uygulama için iki activity bildiren basit bir AndroidManifest.xml örneğidir. &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:versionCode=\"1\" android:versionName=\"1.0\"&gt; &lt;!-- Beware that these values are overridden by the build.gradle file --&gt; &lt;uses-sdk android:minSdkVersion=\"15\" android:targetSdkVersion=\"26\" /&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;!-- This name is resolved to com.example.myapp.MainActivity based on the namespace property in the build.gradle file --&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".DisplayMessageActivity\" android:parentActivityName=\".MainActivity\" /&gt; &lt;/application&gt; &lt;/manifest&gt; . ",
    "url": "/docs/app-basics/about-app-manifests/#example-manifest-file",
    
    "relUrl": "/docs/app-basics/about-app-manifests/#example-manifest-file"
  },"9": {
    "doc": "About app resources",
    "title": "App resources",
    "content": " ",
    "url": "/docs/app-basics/app-resources/about-app-resources/#app-resources",
    
    "relUrl": "/docs/app-basics/app-resources/about-app-resources/#app-resources"
  },"10": {
    "doc": "About app resources",
    "title": "About app resources",
    "content": "Resources, bitmap’ler, layout tanımları, kullanıcı arabirimi(UI) stringleri, animasyon yönergeleri ve daha fazlası gibi kodunuzun kullandığı ek dosyalar ve statik içeriktir. Imageler ve stringler gibi uygulama resourcelerini her zaman kodunuzdan dışsallaştırmalısınız, böylece bunları bağımsız olarak koruyabilirsiniz. Ayrıca, bunları özel olarak adlandırılan kaynak dizinlerinde gruplayarak belirli aygıt yapılandırmaları için alternatif kaynaklar(resources) sağlamalısınız. Çalışma zamanında Android, geçerli yapılandırmaya göre uygun kaynağı kullanır. Örneğin, ekran boyutuna bağlı olarak farklı bir UI düzeni veya dil ayarına bağlı olarak farklı stringler sağlamak isteyebilirsiniz. Uygulama kaynaklarınızı haricileştirdikten sonra, projenizin R sınıfında oluşturulan resource IDlerini kullanarak bunlara erişebilirsiniz. Bu dokuman, Android projenizde kaynaklarınızı nasıl gruplayacağınızı ve belirli cihaz yapılandırmaları için alternatif kaynaklar nasıl sağlayacağınızı ve ardından bunlara uygulama kodunuzdan veya diğer XML dosyalarından nasıl erişeceğinizi gösterir. Grouping resource types . Her tür kaynağı projenizin res/ dizininin belirli bir alt dizinine yerleştirmelisiniz. Örneğin, basit bir proje için dosya hiyerarşisi şu şekildedir: . MyProject/ src/ MyActivity.java res/ drawable/ graphic.png layout/ main.xml info.xml mipmap/ icon.png values/ strings.xml . Bu örnekte görebileceğiniz gibi, res/ dizini tüm kaynakları (alt dizinlerde) içerir: bir görüntü kaynağı, iki layout kaynağı, launcher iconlar için mipmap/ dizinler ve bir string kaynak dosyası. Kaynak dizini adları önemlidir. Not: Mipmap klasörlerini kullanma hakkında daha fazla bilgi için, bkz. Uygulama simgelerini mipmap dizinlerine yerleştirme. Proje res/ dizini içinde desteklenen kaynak dizinleri: . | Directory | Resource Type | . | animator/ | Property animasyonlarını tanımlayan XML dosyaları. | . | anim/ | Gecis animasyonlarını( tween animations.) tanımlayan XML dosyaları. (Özellik animasyonları da bu dizine kaydedilebilir, ancak özellik animasyonlarının iki türü ayırt etmesi için animatör/ dizini tercih edilir.) | . | color/ | Renklerin state listesini tanımlayan XML dosyaları | . | drawable/ | Aşağıdaki drawable resources alt türlerinde derlenen bitmap dosyaları (.png, .9.png, .jpg, .gif) veya XML dosyaları: Bitmap dosyaları, Nine-Patches (yeniden boyutlandırılabilir bitmapler), State listeleri, Şekiller, Animasyon drawables , Diğer drawabler Bkz. Drawable Resources. | . | mipmap/ | Farklı başlatıcı simge yoğunlukları(densities) için çizilebilir dosyalar. Başlatıcı simgelerini mipmap/klasörlerle yönetme hakkında daha fazla bilgi için, bkz. Put app icons in mipmap directories. | . | layout/ | Bir kullanıcı arabirimi düzenini tanımlayan XML dosyaları. | . | menu/ | Seçenekler Menüsü, Bağlam Menüsü veya Alt Menü gibi uygulama menülerini tanımlayan XML dosyaları. | . | raw/ | Ham formlarında kaydedilecek keyfi dosyalar. Bu kaynakları bir ham InputStream, ile açmak için, R.raw.filename olan kaynak kimliğiyle Resources.openRawResource()’u arayın. Ancak, orijinal dosya adlarına ve dosya hiyerarşisine erişmeniz gerekiyorsa, bazı kaynakları assets/ dizinine (res/raw/ yerine) kaydetmeyi düşünebilirsiniz. assets/ dosyalara bir kaynak kimliği verilmez, bu nedenle bunları yalnızca AssetManager.kullanarak okuyabilirsiniz. | . | values/ | Stirngler, integer ve renkler gibi basit değerler içeren XML dosyaları. Diğer res/ alt dizinlerindeki XML kaynak dosyaları, XML dosya adına dayalı olarak tek bir kaynağı tanımlarken, values/ dizindeki dosyalar birden çok kaynağı tanımlar. Bu dizindeki bir dosya için elementinin her bir alt elementi tek bir kaynak tanımlar. Örneğin, bir elementi bir R.string kaynağı oluşturur ve bir elementi bir R.color kaynağı oluşturur.Her kaynak kendi XML öğesiyle tanımlandığından, dosyayı istediğiniz gibi adlandırabilir ve farklı kaynak türlerini tek bir dosyaya yerleştirebilirsiniz. Ancak, netlik sağlamak için benzersiz kaynak türlerini farklı dosyalara yerleştirmek isteyebilirsiniz. Örneğin, bu dizinde oluşturabileceğiniz kaynaklar için bazı dosya adı kuralları şunlardır:&lt;/br&gt;arrays.xml for resource arrays ([typed arrays](https://developer.android.com/guide/topics/resources/more-resources#TypedArray)).&lt;/br&gt;colors.xml for [color values](https://developer.android.com/guide/topics/resources/more-resources#Color)&lt;/br&gt;dimens.xml for [dimension values](https://developer.android.com/guide/topics/resources/more-resources#Dimension).&lt;/br&gt;strings.xml for [string values](https://developer.android.com/guide/topics/resources/string-resource). &lt;/br&gt;styles.xml for [styles](https://developer.android.com/guide/topics/resources/style-resource).&lt;/br&gt;See [String Resources](https://developer.android.com/guide/topics/resources/string-resource), [Style Resource](https://developer.android.com/guide/topics/resources/style-resource), and [More Resource Types](https://developer.android.com/guide/topics/resources/more-resources). | . | xml/ | Resources.getXML(). çağrılarak çalışma zamanında okunabilen keyfi XML dosyaları. searchable configuration gibi çeşitli XML konfigürasyon dosyaları buraya kaydedilmelidir. | . | font/ | Font/ .ttf, .otf veya .ttc gibi uzantılara sahip yazı tipi dosyaları veya bir öğesi içeren XML dosyaları. Kaynak olarak yazı tipleri hakkında daha fazla bilgi için [Fonts in XML](https://developer.android.com/guide/topics/ui/look-and-feel/fonts-in-xml).'e gidin. | . Dikkat: Kaynak dosyalarını asla doğrudan res/ dizininin içine kaydetmeyin; bu bir derleyici hatasına neden olur. Belirli kaynak türleri hakkında daha fazla bilgi için bkz. Resource Types . Yukarida tanımlanan alt dizinlere kaydettiğiniz kaynaklar, “varsayılan” kaynaklarınızdır. Yani bu kaynaklar, uygulamanız için varsayılan tasarımı ve içeriği tanımlar. Bununla birlikte, farklı Android destekli cihaz türleri, farklı türde kaynaklar gerektirebilir. Örneğin, bir cihazın ekranı normalden daha büyükse, ekstra ekran alanından yararlanan farklı layout kaynakları sağlamalısınız. Veya bir aygıtın farklı bir dil ayarı varsa, metni kullanıcı arabiriminizde çeviren farklı string kaynakları sağlamalısınız. Bu farklı kaynakları farklı cihaz yapılandırmaları için sağlamak için varsayılan kaynaklarınıza ek olarak alternatif kaynaklar sağlamanız gerekir. Providing alternative resources . Hemen hemen her uygulama, belirli cihaz yapılandırmalarını desteklemek için alternatif kaynaklar sağlamalıdır. Örneğin, farklı ekran yoğunlukları için alternatif drawable kaynaklar ve farklı diller için alternatif string kaynakları eklemelisiniz. Çalışma zamanında Android, mevcut cihaz yapılandırmasını algılar ve uygulamanız için uygun kaynakları yükler. Bir dizi kaynağa konfigürasyona özel alternatifler belirtmek için: . | res/ içinde - biçiminde adlandırılmış yeni bir dizin oluşturun. | , karşılık gelen varsayılan kaynakların dizin adıdır | , bu kaynakların kullanılacağı ayri bir yapılandırmayı belirten bir addır. Birden fazla ekleyebilirsiniz. Her birini bir tire ile ayırın. | . Dikkat: Birden çok qualifier eklerken, bunları listelendikleri sırayla yerleştirmelisiniz. Qualifierlar yanlış sıralanırsa kaynaklar yok sayılır. | İlgili alternatif kaynakları bu yeni dizine kaydedin. Kaynak dosyaları, varsayılan kaynak dosyalarıyla tam olarak aynı şekilde adlandırılmalıdır. Örneğin, bazı varsayılan ve alternatif kaynaklar şunlardır: res/ drawable/ icon.png background.png drawable-hdpi/ icon.png background.png . | . hdpi qualifieri, o dizindeki kaynakların yüksek yoğunluklu ekrana sahip cihazlar için olduğunu belirtir. Bu drawable dizinlerinin her birindeki görüntüler, belirli bir ekran yoğunluğu için boyutlandırılmıştır, ancak dosya adları tamamen aynıdır. Bu şekilde, icon.png veya background.png görüntüsüne başvurmak için kullandığınız kaynak ID her zaman aynıdır, ancak Android, cihaz yapılandırma bilgilerini aşağıdaki kaynak dizini adındaki niteleyicilerle karşılaştırarak mevcut cihazla en iyi eşleşen her kaynağın sürümünü seçer. Dikkat: Alternatif bir kaynak tanımlarken, kaynağı varsayılan bir konfigürasyonda da tanımladığınızdan emin olun. Aksi takdirde, cihaz bir yapılandırmayı değiştirdiğinde uygulamanız çalışma zamanı istisnalarıyla karşılaşabilir. Örneğin, values değil, yalnızca values-en diye bir dizin eklerseniz, kullanıcı varsayılan sistem dilini değiştirdiğinde uygulamanız bir Kaynak Bulunamadı istisnasıyla karşılaşabilir. Android birkaç yapılandırma niteleyicisini destekler ve her qualifieri bir tire ile ayırarak bir dizin adına birden çok qualifier ekleyebilirsiniz. Tabloda, geçerli yapılandırma niteleyicilerini öncelik sırasına göre listeler—bir kaynak dizini için birden çok qualifier kullanıyorsanız, bunları tabloda listelendikleri sırayla dizin adına eklemeniz gerekir. Quealifier name rules . Yapılandırma niteleyici adlarını kullanmayla ilgili bazı kurallar şunlardır: . | Tek bir kaynak için tire ile ayrılmış birden çok qualifier belirtebilirsiniz. Örneğin, drawable-en-rUS-land, yatay yöndeki ABD-İngilizce cihazlar için geçerlidir. | Qualifierler tablo 2’de listelenen sırada olmalıdır. Örneğin: Wrong:drawable-hdpi-port/ Correct:drawable-port-hdpi/ | Alternatif kaynak dizinleri iç içe yerleştirilemez. Örneğin, res/drawable/drawable-en/’e sahip olamazsınız. | Değerler büyük/küçük harfe duyarsızdır. Kaynak derleyici, büyük/küçük harfe duyarlı olmayan dosya sistemlerinde sorunları önlemek için işlemden önce dizin adlarını küçük harfe dönüştürür. Adlardaki herhangi bir büyük harf kullanımı yalnızca okunabilirliğe fayda sağlamak içindir. | Her qualifier türü için yalnızca bir değer desteklenir. Örneğin, İspanya ve Fransa için aynı drawable dosyaları kullanmak istiyorsanız, drawable-es-fr/ adlı bir dizine sahip olamazsınız. Bunun yerine, uygun dosyaları içeren drawable-es/ ve drawable-fr/ gibi iki kaynak dizinine ihtiyacınız vardır. Ancak, aynı dosyaları her iki konumda da çoğaltmanız gerekmez. Bunun yerine, bir kaynağa takma ad oluşturabilirsiniz. Aşağıdaki Creating alias resources konusuna bakın. | . Alternatif kaynakları bu qualifierler ile adlandırılmış dizinlere kaydettikten sonra Android, mevcut cihaz yapılandırmasına göre uygulamanızdaki kaynakları otomatik olarak uygular. Bir kaynak her istendiğinde, Android, istenen kaynak dosyasını içeren alternatif kaynak dizinlerini kontrol eder ve ardından en uygun kaynağı bulur (aşağıda tartışılmıştır). Belirli bir cihaz yapılandırmasıyla eşleşen alternatif kaynak yoksa, Android karşılık gelen varsayılan kaynakları kullanır. Creating alias resources . Birden fazla cihaz yapılandırması için kullanmak istediğiniz (ancak varsayılan kaynak olarak olarak kullanmak istemediğiniz) bir kaynağınız olduğunda, aynı kaynağı birden fazla alternatif kaynak dizinine koymanız gerekmez. Bunun yerine (bazı durumlarda) varsayılan kaynak dizininizde kayıtlı bir kaynak için takma ad görevi gören alternatif bir kaynak oluşturabilirsiniz. Not: Tüm kaynaklar, başka bir kaynağa takma ad oluşturabileceğiniz bir mekanizma sunmaz. Özellikle xml/ dizinindeki anim, menu, raw ve diğer belirtilmemiş kaynaklar bu özelliği sunmaz. Örneğin, icon.png adlı bir uygulama simgeniz olduğunu ve bunun farklı yerel bolgeler için benzersiz bir sürümüne ihtiyacınız olduğunu hayal edin. Ancak, İngilizce-Kanada ve Fransızca-Kanada olmak üzere iki yerel bolgenin aynı sürümü kullanması gerekir. Aynı görüntüyü hem İngilizce-Kanada dili hem de Fransızca-Kanada dili için kaynak dizinine kopyalamanız gerektiğini varsayabilirsiniz, ancak bu doğru değildir. Bunun yerine, her ikisi için kullanılan resmi icon_ca.png (icon.png dışında herhangi bir ad) olarak kaydedebilir ve varsayılan res/drawable/ dizinine koyabilirsiniz. Ardından, öğesini kullanarak res/drawable-en-rCA/ ve res/drawable-fr-rCA/ içinde icon_ca.png kaynağına atıfta bulunan bir icon.xml dosyası oluşturun. Bu, PNG dosyasının yalnızca bir sürümünü ve ona işaret eden iki küçük XML dosyasını saklamanıza olanak tanır. (Örnek bir XML dosyası aşağıda gösterilmiştir.) . | Drawable:Mevcut bir drawable elemente bir takma ad oluşturmak için elementini kullanın. Örneğin: ```xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; | . @drawable/icon_ca Bu dosyayı icon.xml (res/values-en-rCA/ gibi alternatif bir kaynak dizininde) olarak kaydederseniz, R.drawable.icon olarak başvurabileceğiniz bir kaynağa derlenir, ancak aslında R.drawable.icon_ca kaynağı için bir aliastir. (res/drawable/ içinde kaydedilir). 2. Layout ```xml &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;merge&gt; &lt;include layout=\"@layout/main_ltr\"/&gt; &lt;/merge&gt; . | Strings and other simple values: Varolan bir dizeye takma ad oluşturmak için, yeni dizenin değeri olarak istenen dizenin kaynak IDsini kullanmanız yeterlidir. Örneğin: | . &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;resources&gt; &lt;string name=\"hello\"&gt;Hello&lt;/string&gt; &lt;string name=\"hi\"&gt;@string/hello&lt;/string&gt; &lt;/resources&gt; . R.string.hi kaynağı artık R.string.hello için bir takma addır. Diğer basit değerler de aynı şekilde çalışır. Örneğin, bir renk: . &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;resources&gt; &lt;color name=\"red\"&gt;#f00&lt;/color&gt; &lt;color name=\"highlight\"&gt;@color/red&lt;/color&gt; &lt;/resources&gt; . Accessing your app resources . Uygulamanızda bir kaynak sağladıktan sonra, kaynak IDsine başvurarak onu uygulayabilirsiniz. Tüm kaynak IDleri, projenizin aapt toolunun otomatik olarak oluşturduğu R sınıfında tanımlanır. Uygulamanız derlendiğinde aapt, res/ dizininizdeki tüm kaynaklar için kaynak IDlerini içeren R sınıfını oluşturur. Her kaynak türü için bir R alt sınıfı vardır (örneğin, tüm drawable kaynaklar için R.drawable) ve bu türdeki her kaynak için bir statik integer (örneğin, R.drawable.icon) vardır. Bu integer kaynağınızı almak için kullanabileceğiniz kaynak IDsidir. R sınıfı, kaynak IDlerinin belirtildiği yer olsa da, bir kaynak IDsini keşfetmek için asla oraya bakmanız gerekmez. Bir kaynak IDsi her zaman şunlardan oluşur: . | Kaynak tipi: Her kaynak, string, drawable ve layout gibi bir “tip” olarak gruplanır. Farklı tipler hakkında daha fazla bilgi için bkz. Kaynak Tipleri . | Aşağıdakilerden biri olan kaynak adı: uzantı hariç dosya adı veya kaynak basit bir değerse (örneğin bir string) XML android:name attributendeki değer. | . Bir kaynağa erişmenin iki yolu vardır: . | Kodda: R sınıfınızın bir alt sınıfından statik bir integer kullanma, örneğin: R.string.hello string, kaynak tipidir ve hello, kaynak adıdır. Bu biçimde bir kaynak IDsi sağladığınızda kaynaklarınıza erişebilen birçok Android API’si vardır. Bkz. Koddaki Kaynaklara Erişme. | XML’de: R sınıfınızda tanımlanan kaynak IDsine de karşılık gelen özel bir XML syntax kullanma, örneğin: @string/hello . | . Accessing resources in code . Kaynak IDsini method parametresi olarak ileterek koddaki bir kaynağı kullanabilirsiniz. Örneğin, setImageResource() kullanarak res/drawable/myimage.png kaynağını kullanmak için bir ImageView ayarlayabilirsiniz: . val imageView = findViewById(R.id.myimageview) as ImageView imageView.setImageResource(R.drawable.myimage) . getResources() ile bir örneğini alabileceğiniz Resource’daki methodlari kullanarak tek tek kaynakları da alabilirsiniz. Accessing resources from XML . Accessing original files . Accessing platform resources . Providing the best device compatibility with resources . How Android finds the best-matching resources . ",
    "url": "/docs/app-basics/app-resources/about-app-resources/",
    
    "relUrl": "/docs/app-basics/app-resources/about-app-resources/"
  },"11": {
    "doc": "About app shortcuts",
    "title": "About app shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/about-app-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/about-app-shortcuts/"
  },"12": {
    "doc": "About data binding",
    "title": "About data binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/about-data-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/about-data-binding/"
  },"13": {
    "doc": "About dependency injection",
    "title": "About dependency injection",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/about-dependency-injection/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/about-dependency-injection/"
  },"14": {
    "doc": "About fragments",
    "title": "About fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/about-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/about-fragments/"
  },"15": {
    "doc": "About modularization",
    "title": "About modularization",
    "content": " ",
    "url": "/docs/app-architecture/modularization/about-modularization/",
    
    "relUrl": "/docs/app-architecture/modularization/about-modularization/"
  },"16": {
    "doc": "About Paging 2",
    "title": "About Paging 2",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/about-paging-2/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/about-paging-2/"
  },"17": {
    "doc": "About paging",
    "title": "About paging",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/about-paging/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/about-paging/"
  },"18": {
    "doc": "About Play Feature Delivery",
    "title": "Overview of Play Feature Delivery",
    "content": "Google Play’in uygulama sunma modeli, her kullanıcının cihaz yapılandırması için optimize edilmiş APK’lar oluşturmak ve sunmak için Android App Bundle‘ları kullanır, böylece kullanıcılar yalnızca uygulamanızı çalıştırmak için ihtiyaç duydukları kodu ve kaynakları indirir. Play Feature Delivery, app bundle’ların gelişmiş özelliklerini kullanarak uygulamanızın belirli özelliklerinin koşullu olarak sunulmasına veya isteğe bağlı olarak indirilmesine olanak tanır. Bunu yapmak için öncelikle bu özellikleri base app’inizden feature modüllerine ayırmanız gerekir. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#overview-of-play-feature-delivery",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#overview-of-play-feature-delivery"
  },"19": {
    "doc": "About Play Feature Delivery",
    "title": "Feature module build configuration",
    "content": "Android Studio kullanarak yeni bir feature modülü oluşturduğunuzda, IDE aşağıdaki Gradle eklentisini modülün build.gradle dosyasına uygular. // The following applies the dynamic-feature plugin to your feature module. // The plugin includes the Gradle tasks and properties required to configure and build // an app bundle that includes your feature module. plugins { id 'com.android.dynamic-feature' } . Standart application plugin için kullanılabilen özelliklerin çoğu feature modülünüz için de kullanılabilir. Aşağıdaki bölümlerde, feature modülünüzün build configuration’ına dahil etmeniz ve etmemeniz gereken özellikler açıklanmaktadır. What not to include in the feature module build configuration . Her feature modülü base modüle bağlı olduğundan, belirli yapılandırmaları da miras alır. Bu nedenle, feature modülünün build.gradle dosyasında aşağıdakileri eklememelisiniz: . | Signing configurations: App bundle’lar, base modülde belirttiğiniz signing configurations kullanılarak imzalanır. | The minifyEnabled property: Tüm uygulama projeniz için kod küçültmeyi yalnızca base modülün build configuration’undan etkinleştirebilirsiniz. Bu nedenle, bu özelliği feature modüllerinden çıkarmanız gerekir. Bununla birlikte, her feature modülü için ek ProGuard kuralları belirleyebilirsiniz. | versionCode ve versionName: Gradle, app bundle’ınızı oluştururken base modülün sağladığı app versiyon bilgilerini kullanır. Bu özellikleri feature modülünüzün build.gradle dosyasından çıkarmanız gerekir. | . Establish a relationship to the base module . Android Studio feature modülünüzü oluşturduğunda, aşağıda gösterildiği gibi base modülün build.gradle dosyasına android.dynamicFeatures property’sini ekleyerek onu base modül için görünür hale getirir: . // In the base module’s build.gradle file. android { ... // Specifies feature modules that have a dependency on // this base module. dynamicFeatures = [\":dynamic_feature\", \":dynamic_feature2\"] } . Ayrıca Android Studio, aşağıda gösterildiği gibi base modülü feature modülünün bir bağımlılığı olarak içerir: . // In the feature module’s build.gradle file: ... dependencies { ... // Declares a dependency on the base module, ':app'. implementation project(':app') } . Specify additional ProGuard rules . Yalnızca base modülün build configuration’ı uygulama projeniz için kod küçültmeyi etkinleştirebilse de, aşağıda gösterildiği gibi proguardFiles özelliğini kullanarak her feature modülüyle birlikte özel ProGuard kuralları sağlayabilirsiniz. android.buildTypes { release { // You must use the following property to specify additional ProGuard // rules for feature modules. proguardFiles 'proguard-rules-dynamic-features.pro' } } . Bu ProGuard kurallarının derleme sırasında diğer modüllerdekilerle (base modül dahil) birleştirildiğini unutmayın. Dolayısıyla, her feature modülü yeni bir kural kümesi belirleyebilse de, bu kurallar uygulama projesindeki tüm modüller için geçerlidir. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#feature-module-build-configuration",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#feature-module-build-configuration"
  },"20": {
    "doc": "About Play Feature Delivery",
    "title": "Deploy your app",
    "content": "Uygulamanızı feature modülleri desteğiyle geliştirirken, menü çubuğundan Run &gt; Run’ı seçerek (veya araç çubuğunda Run’a tıklayarak) uygulamanızı normalde yaptığınız gibi bağlı bir cihaza deploy edebilirsiniz. Uygulama projeniz bir veya daha fazla feature modülü içeriyorsa, mevcut run/debug configuration‘nızı aşağıdaki gibi değiştirerek uygulamanızı deploy ederken hangi özelliklerin dahil edileceğini seçebilirsiniz: . | Menü çubuğundan Run (Çalıştır) &gt; Edit Configurations (Yapılandırmaları Düzenle) öğesini seçin. | Çalıştır/Debug Yapılandırmaları iletişim kutusunun sol panelinden istediğiniz Android App configuration seçin. | Genel sekmesindeki Dağıtılacak dinamik özellikler altında, uygulamanızı dağıtırken dahil etmek istediğiniz her özellik modülünün yanındaki kutuyu işaretleyin. | Tamam’a tıklayın. | . Varsayılan olarak, Android Studio uygulamanızı deploy etmek için app bundle’ları kullanmaz. Bunun yerine IDE, APK boyutu yerine deployment hızı için optimize edilmiş APK’lar oluşturur ve cihazınıza yükler. Android Studio’yu bunun yerine APK’ları ve anlık deneyimleri bir app bundle’dan derleyip deploy edecek şekilde yapılandırmak için run/debug configuration’ınızı değiştirin. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#deploy-your-app",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#deploy-your-app"
  },"21": {
    "doc": "About Play Feature Delivery",
    "title": "Use feature modules for custom delivery",
    "content": "Feature modüllerinin benzersiz bir avantajı, uygulamanızın farklı özelliklerinin Android 5.0 (API düzeyi 21) veya daha yüksek sürümleri çalıştıran cihazlara nasıl ve ne zaman indirileceğini özelleştirebilmenizdir. Örneğin, uygulamanızın ilk indirme boyutunu azaltmak için, belirli özellikleri isteğe bağlı olarak indirilecek şekilde ya da yalnızca fotoğraf çekme veya artırılmış gerçeklik özelliklerini destekleme gibi belirli özellikleri destekleyen cihazlar tarafından indirilecek şekilde yapılandırabilirsiniz. Uygulamanızı bir app bundle olarak yüklediğinizde varsayılan olarak son derece optimize edilmiş indirmeler elde etseniz de, daha gelişmiş ve özelleştirilebilir feature delivery seçenekleri, feature modülleri kullanarak uygulamanızın özelliklerinin ek yapılandırılmasını ve modüler hale getirilmesini gerektirir. Yani feature modülleri, her biri gerektiğinde indirilecek şekilde yapılandırabileceğiniz modüler özellikler oluşturmak için yapı taşları sağlar. Kullanıcılarınızın çevrimiçi bir pazarda mal alıp satmasına olanak tanıyan bir uygulama düşünün. Uygulamanın aşağıdaki işlevlerinin her birini ayrı feature modülleri halinde makul bir şekilde modüler hale getirebilirsiniz: . | Hesap girişi ve oluşturma | Pazaryerinde gezinme | Satış için bir ürün yerleştirme | Ödemelerin işlenmesi | . Aşağıdaki tabloda feature modüllerinin desteklediği farklı teslimat seçenekleri ve bunların örnek market uygulamasının ilk indirme boyutunu optimize etmek için nasıl kullanılabileceği açıklanmaktadır. | Delivery option | Behavior | Sample use-case | Getting started | . | Install-time delivery | Yukarıda açıklanan teslim seçeneklerinden herhangi birini yapılandırmayan feature modülleri, varsayılan olarak uygulama yüklendiğinde indirilir. Bu önemli bir davranıştır çünkü gelişmiş teslimat seçeneklerini kademeli olarak benimseyebileceğiniz anlamına gelir. Örneğin, uygulamanızın özelliklerini modüler hale getirmekten faydalanabilir ve isteğe bağlı teslimi(on-demand delivery) ancak Play Feature Delivery Library’yi kullanarak isteğe bağlı indirmeleri tam olarak uyguladıktan sonra etkinleştirebilirsiniz. Buna ek olarak, uygulamanız özellikleri daha sonra kaldırmayı talep edebilir. Yani, uygulama yüklenirken belirli özelliklere ihtiyaç duyuyor ancak sonrasında ihtiyaç duymuyorsanız, özelliğin cihazdan kaldırılmasını talep ederek yükleme boyutunu azaltabilirsiniz. | Uygulamanın, pazaryerinde nasıl ürün alınıp satılacağına ilişkin etkileşimli bir kılavuz gibi belirli eğitim activityleri varsa, bu özelliği varsayılan olarak uygulama yüklemesine dahil edebilirsiniz.&lt;/br&gt;Ancak, uygulamanın yüklü boyutunu azaltmak için, kullanıcı eğitimi tamamladıktan sonra uygulama feature’ı silmeyi talep edebilir. | Gelişmiş delivery seçeneklerini yapılandırmayan feature modüllerini kullanarak Modularize your app.&lt;/br&gt;Kullanıcının artık ihtiyaç duymayabileceği belirli feature modüllerini kaldırarak uygulamanızın yüklü boyutunu nasıl azaltacağınızı öğrenmek için Manage installed modules bölümünü okuyun. | . | On demand delivery | Uygulamanızın gerektiğinde feature modülleri talep etmesini ve indirmesini sağlar. | Pazaryeri uygulamasını kullananların yalnızca %20’si satış için ürün gönderiyorsa, kullanıcıların çoğunluğu için ilk indirme boyutunu azaltmak için iyi bir strateji, fotoğraf çekme, ürün açıklaması ekleme ve satış için bir ürün yerleştirme işlevlerini isteğe bağlı indirme olarak kullanılabilir hale getirmektir. Yani, uygulamanın satış işlevi için feature modülünü yalnızca bir kullanıcı pazaryerine satılık ürün yerleştirmeye ilgi gösterdiğinde indirilecek şekilde yapılandırabilirsiniz.&lt;/br&gt;Ek olarak, kullanıcı belirli bir süre sonra artık ürün satmazsa, uygulama özelliği kaldırmayı talep ederek yüklü boyutunu azaltabilir. | Bir feature modülü ve configure on demand delivery oluşturun. Uygulamanız daha sonra modülü on demand(talep uzerine) indirmeyi istemek için Play Feature Delivery Library kullanabilir. | . | Conditional delivery | Modülerleştirilmiş bir özelliğin uygulama yüklemesinde indirilip indirilmeyeceğini belirlemek için donanım özellikleri, yerel ayar ve minimum API düzeyi gibi belirli kullanıcı cihazı gereksinimlerini belirtmenize olanak tanır. | Pazaryeri uygulaması küresel erişime sahipse, yalnızca belirli bölgelerde veya yerel halkta popüler olan ödeme yöntemlerini desteklemeniz gerekebilir. İlk uygulama indirme boyutunu azaltmak için, belirli ödeme yöntemlerini işlemek üzere ayrı feature modülleri oluşturabilir ve bunların kayıtlı yerel ayarlarına göre kullanıcının cihazına koşullu olarak yüklenmesini sağlayabilirsiniz. | Bir feature modülü oluşturun ve conditional delivery‘i yapılandırın. | . | Instant delivery | Google Play Instant, kullanıcıların uygulamayı cihazlarına yüklemelerine gerek kalmadan uygulamanızla etkileşime geçmelerini sağlar. Bunun yerine, Google Play Store’daki “Şimdi Dene” düğmesi veya sizin oluşturduğunuz bir URL aracılığıyla uygulamanızı deneyimleyebilirler. Bu içerik sunma biçimi, uygulamanızla etkileşimi artırmanızı kolaylaştırır. &lt;/br&gt;Instant delivery ile, kullanıcılarınızın uygulamanızın belirli özelliklerini yükleme yapmadan anında deneyimlemelerini sağlamak için Google Play Instant’ı kullanabilirsiniz. | Oyunun ilk birkaç seviyesini hafif bir feature modülüne dahil eden bir oyun düşünün. Bu modülü instant-enable edeblirsiniz, böylece kullanıcılar uygulama yüklemeden bir URL bağlantısı veya “Şimdi Dene” düğmesi aracılığıyla oyunu anında deneyimleyebilirler. | Bir feature modülü oluşturun ve instant delivery’i yapılandırın. Uygulamanız daha sonra modülü talep üzerine(on demand) indirmeyi istemek için Play Feature Delivery Library’yi kullanabilir.&lt;/br&gt;Uygulama özelliklerinizi feature modülleri kullanarak modüler hale getirmenin yalnızca ilk adım olduğunu unutmayın. Google Play Instant’ı desteklemek için, uygulamanızın temel modülünün ve instant-enabled özelliğinin indirme boyutunun katı boyut kısıtlamalarını karşılaması gerekir. Daha fazla bilgi edinmek için Uygulama veya oyun boyutunu küçülterek anlık deneyimleri etkinleştirin başlıklı makaleyi okuyun. | . ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#use-feature-modules-for-custom-delivery",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#use-feature-modules-for-custom-delivery"
  },"22": {
    "doc": "About Play Feature Delivery",
    "title": "Buildig a URI for a resource",
    "content": "Bir URI kullanarak bir feature modülünde depolanan bir kaynağa erişmek istiyorsanız, Uri.Builder() kullanarak bir feature modülü kaynak URI’sinin nasıl oluşturulacağı aşağıda açıklanmıştır: . val uri = Uri.Builder() .scheme(ContentResolver.SCHEME_ANDROID_RESOURCE) .authority(context.getPackageName()) // Look up the resources in the application with its splits loaded .appendPath(resources.getResourceTypeName(resId)) .appendPath(String.format(\"%s:%s\", resources.getResourcePackageName(resId), // Look up the dynamic resource in the split namespace. resources.getResourceEntryName(resId) )) .build() . Kaynağa giden yolun her bir parçası çalışma zamanında oluşturulur ve split APK’lar yüklendikten sonra doğru namespace’in oluşturulmasını sağlar. URI’nin nasıl oluşturulduğuna bir örnek olarak, aşağıdaki adlara sahip bir uygulamanız ve feature modülleriniz olduğunu varsayalım: . | Uygulama paketinin adı: com.example.my_app_package | Özelliğin kaynak paket adı: com.example.my_app_package.my_dynamic_feature | . Yukarıdaki kod parçasında resId, feature modülünüzde “my_video” adlı bir ham dosya kaynağını ifade ediyorsa, yukarıdaki Uri.Builder() kodu aşağıdaki çıktıyı verecektir: . android.resource://com.example.my_app_package/raw/com.example.my_app_package.my_dynamic_feature:my_video . Bu URI daha sonra uygulamanız tarafından feature modülünün kaynağına erişmek için kullanılabilir. URI’nizdeki yolları doğrulamak için, feature modülü APK’nızı incelemek ve paket adını belirlemek üzere APK Analyzer kullanabilirsiniz: . Şekil 2. Derlenmiş bir kaynak dosyasındaki paket adını incelemek için APK Analyzer’ı kullanın. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#buildig-a-uri-for-a-resource",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#buildig-a-uri-for-a-resource"
  },"23": {
    "doc": "About Play Feature Delivery",
    "title": "Considerations for feature modules",
    "content": "Feature modülleri ile derleme hızını ve mühendislik hızını artırabilir ve uygulamanızın boyutunu küçültmek için uygulamanızın özelliklerinin dağıtımını kapsamlı bir şekilde özelleştirebilirsiniz. Ancak feature modüllerini kullanırken akılda tutulması gereken bazı kısıtlamalar ve istisnai durumlar vardır: . | Koşullu(conditional) veya isteğe bağlı(on-demand) dağıtım yoluyla tek bir cihaza 50 veya daha fazla feature modülü yüklemek performans sorunlarına yol açabilir. Kaldırılabilir olarak yapılandırılmayan yükleme zamanı(install-time) modülleri otomatik olarak base modüle dahil edilir ve her cihazda yalnızca bir feature modülü olarak sayılır. | Yükleme zamanı(install-time) delivery için kaldırılabilir olarak yapılandırdığınız modül sayısını 10 veya daha az ile sınırlandırın. Aksi takdirde, uygulamanızın indirme ve yükleme süresi artabilir. | Yalnızca Android 5.0 (API düzeyi 21) ve üzeri sürümleri çalıştıran cihazlar talep üzerine(on-demand) özellik indirmeyi ve yüklemeyi destekler. Özelliğinizi Android’in önceki sürümlerinde kullanılabilir hale getirmek için, bir feature modülü oluşturduğunuzda [Fusing] özelliğini etkinleştirin. | SplitCompat‘ı etkinleştirin, böylece uygulamanız talep üzerine teslim edilen (on-demand delivery)indirilmiş feature modüllerine erişebilir. | Feature modülleri, manifestolarında android:exported true olarak ayarlanmış activityleri belirtmemelidir. Bunun nedeni, başka bir uygulama activity’yi başlatmaya çalıştığında cihazın feature modülünü indirdiğine dair bir garanti olmamasıdır. Ayrıca, uygulamanız koduna ve kaynaklarına erişmeye çalışmadan önce bir özelliğin indirildiğini onaylamalıdır. Daha fazla bilgi edinmek için Managed Installed modules bölümünü okuyun. | Play Feature Delivery, uygulamanızı bir app bundle kullanarak yayınlamanızı gerektirdiğinden, app bundle’ın bilinen sorunlarından haberdar olduğunuzdan emin olun. | . ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#considerations-for-feature-modules",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#considerations-for-feature-modules"
  },"24": {
    "doc": "About Play Feature Delivery",
    "title": "Feature module manifest reference",
    "content": "Android Studio kullanarak yeni bir feature module oluştururken, IDE modülün bir feature module gibi davranması için gereken manifesto niteliklerinin çoğunu içerir. Ayrıca, bazı özellikler derleme sırasında derleme sistemi tarafından enjekte edilir, bu nedenle bunları sizin belirtmeniz veya değiştirmeniz gerekmez. Aşağıdaki tabloda feature modüller için önemli olan manifesto attributeleri açıklanmaktadır. | Attribute | Description | . | &lt;manifest&lt;/br&gt; … | - | . | xmlns:dist=”http://schemas.android.com/apk/distribution” | - | . | split=”split_name” | - | . | android:isFeatureSplit=”true | false”&gt; | - | . | &lt;dist:module | - | . | dist:instant=”true | false” | - | . | dist:title=”@string/feature_name” | - | . | &lt;/dist:module&gt; | - | . | | - | . | | - | . | | - | . | &lt;/dist:install-time&gt; | - | . | | - | . | &lt;/dist:delivery&gt; | - | . | ... | - | . Not: Feature modülleri, manifestolarında android:exported değeri true olarak ayarlanmış aktiviteleri belirtmemelidir. Bunun nedeni, başka bir uygulama activity’yi başlatmaya çalıştığında cihazın feature modülünü indirdiğine dair bir garanti olmamasıdır. Ayrıca, uygulamanız koduna ve kaynaklarına erişmeye çalışmadan önce bir özelliğin indirildiğini onaylamalıdır. ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#feature-module-manifest-reference",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#feature-module-manifest-reference"
  },"25": {
    "doc": "About Play Feature Delivery",
    "title": "Additional resources",
    "content": "Feature modüllerini kullanma hakkında daha fazla bilgi edinmek için aşağıdaki kaynakları deneyin. Blog posts . Videos . ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#additional-resources",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/#additional-resources"
  },"26": {
    "doc": "About Play Feature Delivery",
    "title": "About Play Feature Delivery",
    "content": " ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/about-play-feature-delivery/"
  },"27": {
    "doc": "About resource types",
    "title": "About resource types",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/about-resource-types/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/about-resource-types/"
  },"28": {
    "doc": "About The Android App Bundle format",
    "title": "The Android App Bundle format",
    "content": "Android App Bundle, Google Play’e yüklediğiniz bir dosyadır (.aab dosya uzantılı). App bundle’lar, uygulamanızın kodunu ve kaynaklarını şekil 1’de gösterildiği gibi modüller halinde düzenleyen imzalı binary’lerdir. Her modülün kodu ve kaynakları, bir APK’da bulacağınıza benzer şekilde düzenlenir ve bu mantıklıdır çünkü bu modüllerin her biri ayrı APK’lar olarak oluşturulabilir. Google Play daha sonra base APK, feature APK’ları, configuration APK’ları ve ( split APK’ları desteklemeyen cihazlar için) multi-APK’lar gibi kullanıcılara sunulan çeşitli APK’ları oluşturmak için app bundle’ı kullanır. Drawable/, values/ ve lib/ dizinleri gibi mavi renkli dizinler, Google Play’in her modül için konfigürasyon APK’ları oluşturmak için kullandığı kod ve kaynakları temsil eder. Şekil 1. Android App Bundle. Bir base modül, iki feature modülü ve iki asset paketi içeren bir Android App Bundle’ın içeriği. Not: Her benzersiz uygulama veya applicationID için bir app bundle oluşturursunuz. Yani, tek bir uygulama projesinden uygulamanızın birden çok sürümünü oluşturmak için product flavors kullanıyorsanız ve bu sürümlerin her biri benzersiz bir applicationID kullanıyorsa, uygulamanızın her sürümü için ayrı bir app bundle oluşturmanız gerekir. Aşağıdaki listede app bundle’ın bazı dosya ve dizinleri daha ayrıntılı olarak açıklanmaktadır: . | base/, feature1/ ve feature2/: Bu top-level dizinlerin her biri uygulamanızın farklı bir modülünü temsil eder. Uygulamanızın base modülü her zaman app bundle’ın base dizininde bulunur. Ancak her bir feature modülünün dizinine, modülün manifestosundaki split attribute’i tarafından belirtilen ad verilir. Daha fazla bilgi edinmek için feature module manifest hakkında bilgi edinin. | asset_pack_1/ ve asset_pack_2/: Büyük, grafik gerektiren uygulamalar veya oyunlar için assetleri asset paketleri halinde modülerleştirebilirsiniz. Asset paketleri, büyük boyut sınırları nedeniyle oyunlar için idealdir. Her bir asset paketinin bir cihaza nasıl ve ne zaman indirileceğini üç teslim moduna göre özelleştirebilirsiniz: yükleme zamanı(install-time), hızlı takip(fast-follow) ve talep üzerine(on-demand). Tüm asset paketleri Google Play’de barındırılır ve buradan sunulur. App bundle’ınıza asset paketlerini nasıl ekleyeceğiniz hakkında daha fazla bilgi edinmek için Play Asset Delivery‘ye genel bakış bölümüne bakın. | BUNDLE-METADATA/: Bu dizin, araçlar veya uygulama mağazaları için yararlı bilgiler içeren meta data dosyalarını içerir. Bu tür meta data dosyaları ProGuard eşlemelerini ve uygulamanızın DEX dosyalarının tam listesini içerebilir. Bu dizindeki dosyalar uygulamanızın APK’larında paketlenmez. | Module Protocol Buffer (.pb) dosyaları:* Bu dosyalar, Google Play gibi uygulama mağazalarına her bir uygulama modülünün içeriğini açıklamaya yardımcı olan meta datalar sağlar. Örneğin, BundleConfig.pb, app bundle’ı oluşturmak için derleme araçlarının hangi sürümünün kullanıldığı gibi bundle’ın kendisi hakkında bilgi sağlar ve native.pb ve resources.pb, Google Play APK’ları farklı cihaz yapılandırmaları için optimize ederken yararlı olan her modüldeki kodu ve kaynakları açıklar. | manifest/: APK’ların aksine, app bundle’lar her modülün AndroidManifest.xml dosyasını bu ayrı dizinde saklar. | dex/: APK’ların aksine, app bundle’lar her modül için DEX dosyalarını bu ayrı dizinde saklar. | res/, lib/ ve assets/: Bu dizinler tipik bir APK’daki dizinlerle aynıdır. App bundle’ınızı yüklediğinizde, Google Play bu dizinleri inceler ve dosya yollarını koruyarak yalnızca hedef cihaz yapılandırmasını karşılayan dosyaları paketler. | root/: Bu dizin, daha sonra bu dizinin bulunduğu modülü içeren herhangi bir APK’nın root’una taşınacak dosyaları depolar. Örneğin, bir app bundle’ın base/root/ dizini, uygulamanızın Class.getResource() kullanarak yüklediği Java tabanlı kaynakları içerebilir. Bu dosyalar daha sonra uygulamanızın base APK’sının ve Google Play’in oluşturduğu her çoklu APK’nın root dizinine taşınır. Bu dizin içindeki path’ler de korunur. Yani, dizinler (ve alt dizinleri) de APK’nın root dizinine taşınır. | . Dikkat: Bu dizindeki içerik APK’nın root dizinindeki diğer dosya ve dizinlerle çakışırsa, Play Console yükleme sırasında tüm app bundle’ı reddeder. Örneğin, bir root/lib/ dizini ekleyemezsiniz çünkü bu, her APK’nın zaten içerdiği lib diziniyle çakışır. ",
    "url": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/#the-android-app-bundle-format",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/#the-android-app-bundle-format"
  },"29": {
    "doc": "About The Android App Bundle format",
    "title": "Overview of split APKs",
    "content": "Optimize edilmiş uygulamalar sunmanın temel bileşenlerinden biri Android 5.0 (API seviyesi 21) ve üzeri sürümlerde bulunan split APK mekanizmasıdır. Split APK’lar normal APK’lara çok benzer; derlenmiş DEX bytecode, kaynaklar ve bir Android manifestosu içerirler. Ancak, Android platformu birden fazla yüklü split APK’yı tek bir uygulama olarak değerlendirebilir. Yani, ortak kod ve kaynaklara erişimi olan birden fazla split APK yükleyebilir ve cihazda yüklü tek bir uygulama olarak görünebilirsiniz. Split APK’ların avantajı, monolitik bir APK’yı (yani uygulamanızın desteklediği tüm özellikler ve cihaz yapılandırmaları için kod ve kaynaklar içeren bir APK), kullanıcının cihazına gerektiği gibi yüklenen daha küçük, ayrı paketlere ayırma yeteneğidir. Örneğin, bir split APK yalnızca birkaç kullanıcınızın ihtiyaç duyduğu ek bir özelliğin kodunu ve kaynaklarını içerirken, başka bir split APK yalnızca belirli bir dil veya ekran yoğunluğu için kaynakları içerebilir. Bu split APK’ların her biri, kullanıcı talep ettiğinde veya cihaz tarafından gerekli görüldüğünde indirilir ve yüklenir. Aşağıda, tam uygulama deneyiminizi oluşturmak için bir cihaza birlikte yüklenebilecek farklı APK türleri açıklanmaktadır. Uygulama projenizi bu APK’ları destekleyecek şekilde nasıl yapılandıracağınızı bu sayfanın ilerleyen bölümlerinde öğreneceksiniz. | Base APK: Bu APK, diğer tüm split APK’ların erişebileceği kod ve kaynakları içerir ve uygulamanız için temel işlevselliği sağlar. Bir kullanıcı uygulamanızı indirmek istediğinde, ilk olarak bu APK indirilir ve yüklenir. Bunun nedeni, yalnızca base APK’nın manifestosunun uygulamanızın servisleri, content providerlari, izinleri, platform sürümü gereksinimleri ve sistem özelliklerine olan bağımlılıklarının tam bir bildirimini içermesidir. Google Play, uygulamanız için base APK’yı projenizin app (veya base) modülünden oluşturur. Uygulamanızın ilk indirme boyutunu küçültmekle ilgileniyorsanız, bu modüle dahil edilen tüm kod ve kaynakların uygulamanızın base APK’sına dahil edildiğini aklınızda bulundurmanız önemlidir. | Configuration APKs: Bu APK’ların her biri belirli bir ekran yoğunluğu, CPU mimarisi veya dil için yerel kütüphaneler ve kaynaklar içerir. Bir kullanıcı uygulamanızı indirdiğinde, cihazı yalnızca kendi cihazını hedefleyen configuration APK’ları indirir ve yükler. Her configuration APK, bir base APK veya feature module APK’nın bağımlılığıdır. Yani, kod ve kaynak sağladıkları APK ile birlikte indirilir ve yüklenirler. Base ve feature modüllerinin aksine, configuration APK’lar için ayrı bir modül oluşturmazsınız. Base ve feature modülleriniz için alternatif, configuration’a özgü kaynakları düzenlemek üzere standart pratikler kullanırsanız, Google Play sizin için configuration APK’ları otomatik olarak oluşturur. | Feature module APKs: Bu APK’ların her biri, feature modülleri kullanarak modüler hale getirdiğiniz uygulamanızın bir özelliği için kod ve kaynaklar içerir. Daha sonra bu özelliğin bir cihaza nasıl ve ne zaman indirileceğini özelleştirebilirsiniz. Örneğin, Play Core Library kullanılarak, kullanıcıya ek işlevsellik sağlamak için base APK cihaza yüklendikten sonra özellikler isteğe bağlı olarak yüklenebilir. Fotoğraf çekme ve gönderme özelliğini yalnızca kullanıcı bu işlevi kullanmayı talep ettiğinde indirip yükleyen bir sohbet uygulaması düşünün. Feature modülleri yükleme sırasında mevcut olmayabileceğinden, tüm ortak kod ve kaynakları base APK’ya dahil etmelisiniz. Yani, feature modülünüz yükleme sırasında yalnızca base APK’nın kod ve kaynaklarının mevcut olduğunu varsaymalıdır. Google Play, projenizin feature modüllerinden uygulamanız için feature modül APK’ları oluşturur. | . Üç feature modülüne sahip ve birden fazla cihaz yapılandırmasını destekleyen bir uygulama düşünün. Aşağıdaki Şekil 1, uygulamanın çeşitli APK’ları için bağımlılık ağacının nasıl görünebileceğini göstermektedir. Base APK’nın ağacın başını oluşturduğunu ve diğer tüm APK’ların base APK’ya bağlı olduğunu unutmayın. (Bu APK’lar için modüllerin bir Android App Bundle’da nasıl temsil edildiğini merak ediyorsanız, Android App Bundle formatına bakın) . Şekil 1. Split APK’lar kullanılarak sunulan bir uygulama için bağımlılık ağacı . Unutmayın, bu APK’ları kendiniz oluşturmanıza gerek yoktur; Google Play, Android Studio ile oluşturduğunuz tek bir imzalı app bundle kullanarak bunu sizin için yapar. App Bundle formatı ve nasıl oluşturulacağı hakkında daha fazla bilgi edinmek için Android App Bundle’ları oluşturma, dağıtma ve yükleme bölümü ne gidin. Devices running Android 4.4 (API level 19) and lower . Android 4.4 (API düzeyi 19) ve daha düşük sürümleri çalıştıran cihazlar split APK’ların indirilmesini ve yüklenmesini desteklemediğinden, Google Play bunun yerine bu cihazlara multi-APK adı verilen ve cihazın yapılandırması için optimize edilmiş tek bir APK sunar. Yani, multi-APK’ler tam uygulama deneyiminizi temsil eder ancak diğer ekran yoğunlukları ve CPU mimarileri için olanlar gibi gereksiz kod ve kaynakları içermez. Bununla birlikte, uygulamanızın desteklediği tüm diller için kaynaklar içerirler. Bu, örneğin kullanıcıların farklı bir multi-APK indirmek zorunda kalmadan uygulamanızın tercih ettiği dil ayarını değiştirmesine olanak tanır. Multi-APK’ler, feature modüllerini daha sonra isteğe bağlı olarak indirme özelliğine sahip değildir. Bu APK’ya bir feature modülü eklemek için, feature modülünü oluştururken Talep Üzerine(On-demand) özelliğini devre dışı bırakmanız veya Fusing özelliğini etkinleştirmeniz gerekir. App Bundle’larda uygulamanızın desteklediği her cihaz yapılandırması için APK oluşturmanız, imzalamanız, yüklemeniz ve yönetmeniz gerekmediğini unutmayın. Yine de tüm uygulamanız için tek bir app bundle oluşturup yüklüyorsunuz ve gerisini Google Play sizin için hallediyor. Dolayısıyla, Android 4.4 veya daha düşük sürümleri çalıştıran cihazları desteklemeyi planlasanız da planlamasanız da, Google Play hem siz hem de kullanıcılarınız için esnek bir hizmet mekanizması sağlar. User language changes . App bundle’lar ile cihazlar yalnızca uygulamanızı çalıştırmak için ihtiyaç duydukları kodu ve kaynakları indirir. Dolayısıyla, dil kaynakları için, kullanıcının cihazı yalnızca cihaz ayarlarında seçili olan bir veya daha fazla dille eşleşen uygulamanızın dil kaynaklarını indirir. Bir kullanıcı cihaz ayarlarında dilini değiştirdiğinde, uygulamanın yeni dilde görüntülenebilmesi için Google Play’in bazı ek split APK’ları indirmesi ve yüklemesi gerekebilir. Google Play, geçişten hemen sonra ek dilleri indirmeye çalışır. Kullanıcı cihazı çevrimdışıysa, indirme başarısız olursa veya kaynaklar çok büyükse Google Play, cihaz koşulları daha uygun olduğunda arka planda indirmeyi tekrar dener. Android 9.0 (API seviyesi 28) veya daha düşük bir cihazda çalışırken, yeni language split APK’ların yüklenmesi sırasında uygulamanız ön plandaysa, uygulama öldürülür. Uygulamanız tüm dillerin cihazda her zaman kullanılabilir olmasını gerektiriyorsa, derleme yapılandırmanızda language split’i devre dışı bırakabilirsiniz. Uygulamanız cihaz ayarlarında seçilen kullanıcı dillerinden bağımsız olarak ek dillerin indirilmesini gerektiriyorsa ( örneğin uygulama içi bir dil seçici uygulamak için), bunları isteğe bağlı olarak indirmek için Play Core kütüphanesini kullanabilirsiniz. ",
    "url": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/#overview-of-split-apks",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/#overview-of-split-apks"
  },"30": {
    "doc": "About The Android App Bundle format",
    "title": "About The Android App Bundle format",
    "content": " ",
    "url": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/",
    
    "relUrl": "/docs/core-topics/android-app-bundles/about-the-app-bundle-format/"
  },"31": {
    "doc": "About the data layer",
    "title": "Data Layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer/#data-layer",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer/#data-layer"
  },"32": {
    "doc": "About the data layer",
    "title": "About the data layer",
    "content": "UI katmanı UI ile ilgili state ve UI logic’i içerirken, data katmanı uygulama verilerini ve business logic’i içerir. Business logic (iş mantığı) uygulamanıza değer katan şeydir; uygulama verilerinin nasıl oluşturulması, saklanması ve değiştirilmesi gerektiğini belirleyen gerçek dünya iş kurallarından oluşur. Separation of concerns ilkesinin bu sekilde olması, veri katmanının birden fazla ekranda kullanılmasına, uygulamanın farklı bölümleri arasında bilgi paylaşılmasına ve birim testi için iş mantığının kullanıcı arayüzünün dışında yeniden üretilmesine olanak tanır. Data katmanının faydaları hakkında daha fazla bilgi için Architecture Overview sayfasına göz atın. ot: Bu sayfada yer alan öneriler ve best practiceler, ölçeklenmelerini sağlamak, kaliteyi ve sağlamlığı artırmak ve test edilmelerini kolaylaştırmak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Architecture: The data layer - MAD Skills . Data layer architecture . Data katmanı, her biri sıfır ila çok sayıda veri kaynağı içerebilen repository’lerden oluşur. Uygulamanızda işlediğiniz her farklı veri türü için bir repository sınıfı oluşturmalısınız. Örneğin, filmlerle ilgili veriler için bir MoviesRepository sınıfı veya ödemelerle ilgili veriler için bir PaymentsRepository sınıfı oluşturabilirsiniz. Repository sınıfları aşağıdaki görevlerden sorumludur: . | Verilerin uygulamanın geri kalanına sunulması. | Verilerdeki değişiklikleri merkezileştirme. | Birden fazla veri kaynağı arasındaki çakışmaları çözme. | Uygulamanın geri kalanından veri kaynaklarını soyutlama. | Business logic’i içermek. | . Her veri kaynağı sınıfı(data source class) , bir dosya, bir network kaynağı veya local veritabanı olabilen sadece tek bir veri kaynağı ile çalışma sorumluluğuna sahip olmalıdır. Veri kaynağı sınıfları, veri işlemleri için uygulama ile sistem arasındaki köprüdür. Hiyerarşideki diğer katmanlar veri kaynaklarına asla doğrudan erişmemelidir; data katmanına entry pointler her zaman repository sınıflarıdır. State holder sınıfları (UI katmanı kılavuzuna bakın) veya use case sınıfları (domain katmanı kılavuzuna bakın) hiçbir zaman doğrudan bir bağımlılık olarak bir veri kaynağına sahip olmamalıdır. Repository sınıflarının entry point olarak kullanılması, mimarinin farklı katmanlarının bağımsız olarak ölçeklenebilmesini sağlar. Bu katman tarafından açığa çıkarılan veriler immutable olmalıdır, böylece diğer sınıflar tarafından kurcalanamaz, bu da değerlerini tutarsız bir duruma sokma riski taşır. Immutable veriler birden fazla thread tarafından da güvenli bir şekilde işlenebilir. Daha fazla ayrıntı için thread bölümüne bakın. Dependency injection best practices‘i takiben, repository veri kaynaklarını constructor’ında dependency olarak alır: . class ExampleRepository( private val exampleRemoteDataSource: ExampleRemoteDataSource, // network private val exampleLocalDataSource: ExampleLocalDataSource // database ) { /* ... */ } . Not: Genellikle, bir repository yalnızca tek bir veri kaynağı içerdiğinde ve diğer repository’lere bağlı olmadığında, geliştiriciler repository’lerin ve veri kaynaklarının sorumluluklarını repository sınıfında birleştirir. Bunu yaparsanız, uygulamanızın sonraki bir sürümünde repository’nin başka bir kaynaktan gelen verileri işlemesi gerekiyorsa fonksiyonları bölmeyi unutmayın. Expose APIs . Data katmanındaki sınıflar genellikle tek seferlik Create, Read, Update ve Delete (CRUD) çağrıları gerçekleştirmek veya zaman içindeki veri değişikliklerinden haberdar olmak için fonksiyonları kullanıma sunar. Data katmanı bu durumların her biri için aşağıdakileri sağlamalıdır: . | Tek seferlik işlemler: Data katmanı Kotlin’de suspend fonksiyonlarını kullanıma sunmalıdır; ve Java programlama dili için, data katmanı işlemin sonucunu bildirmek için bir callback sağlayan fonksiyonları veya RxJava Single, Maybe veya Completable tiplerini kullanıma sunmalıdır. | Zaman içindeki veri değişikliklerinden haberdar olmak için: Data katmanı Kotlin’de flow‘ları kullanıma sunmalıdır; ve Java programlama dili için data katmanı yeni veriyi veya RxJava Observable veya Flowable türünü yayınlayan bir callback’i kullanıma sunmalıdır. | . class ExampleRepository( private val exampleRemoteDataSource: ExampleRemoteDataSource, // network private val exampleLocalDataSource: ExampleLocalDataSource // database ) { val data: Flow&lt;Example&gt; = ... suspend fun modifyData(example: Example) { ... } } . Naming conventions in this guide . Bu kılavuzda, repository sınıfları sorumlu oldukları verilere göre adlandırılmıştır. Kurallar aşağıdaki gibidir: . veri türü + Repository. Örneğin: NewsRepository, MoviesRepository veya PaymentsRepository. Veri kaynağı sınıfları, sorumlu oldukları verilerden ve kullandıkları kaynaktan sonra adlandırılır. Kurallar aşağıdaki gibidir: . veri türü + kaynak türü + DataSource. Veri türü için, uygulamalar değişebileceğinden daha genel olması için Remote veya Local kullanın. Örneğin: NewsRemoteDataSource veya NewsLocalDataSource. Kaynağın önemli olması durumunda daha spesifik olmak için kaynağın türünü kullanın. Örneğin: NewsNetworkDataSource veya NewsDiskDataSource. Veri kaynağını bir uygulama detayına göre adlandırmayın (örneğin UserSharedPreferencesDataSource) çünkü bu veri kaynağını kullanan repository’ler verilerin nasıl kaydedildiğini bilmemelidir. Bu kurala uyarsanız, veri kaynağının uygulamasını, bu kaynağı çağıran katmanı etkilemeden değiştirebilirsiniz ( örneğin, SharedPreferences’ tan DataStore‘a geçiş). Not: Bir veri kaynağının yeni bir implementasyonuna geçerken, veri kaynağı için bir interface oluşturabilir ve veri kaynağının iki implementasyonuna sahip olabilirsiniz: biri eski backing teknolojisi için, diğeri de yenisi için. Bu durumda, veri kaynağı sınıf adları için teknolojinin adını kullanmanızda bir sakınca yoktur (bu bir uygulama ayrıntısı olsa bile) çünkü repository veri kaynağı sınıflarının kendisini değil yalnızca interface'i görür. Taşıma işlemini tamamladığınızda, yeni sınıfı, adında uygulama ayrıntısı içermeyecek şekilde yeniden adlandırabilirsiniz. Multiple levels of repositories . Daha karmaşık iş gereksinimlerini içeren bazı durumlarda, bir repository’nin diğer repository’lere bağımlı olması gerekebilir. Bunun nedeni, ilgili verilerin birden fazla veri kaynağından toplanması veya sorumluluğun başka bir repository sınıfında encapsulated edilmesi gerekliligi olabilir. Örneğin, kullanıcı kimlik doğrulama verilerini işleyen bir repository, UserRepository, gereksinimlerini yerine getirmek için LoginRepository ve RegistrationRepository gibi diğer repository’lere bağımlı olabilir. Not: Geleneksel olarak, bazı geliştiriciler diğer repository sınıflarına bağlı olan repository sınıflarını manager olarak adlandırırlar; örneğin UserRepository yerine UserManager. İsterseniz bu adlandırma kuralını kullanabilirsiniz. Source of truth . Her repository’nin tek bir doğruluk kaynağı(single source of truth) tanımlaması önemlidir. Doğruluk kaynağı her zaman tutarlı, doğru ve güncel veriler içerir. Aslında, repository’den açığa çıkan veriler her zaman doğrudan doğruluk kaynağından gelen veriler olmalıdır. Doğruluk kaynağı bir veri kaynağı (örneğin veri tabanı) ya da repository’nin içerebileceği bir in-memory cache olabilir. Repository’ler farklı veri kaynaklarını birleştirir ve veri kaynakları arasındaki olası çakışmaları çözerek tek doğruluk kaynağını düzenli olarak veya bir user input event nedeniyle günceller. Uygulamanızdaki farklı veri repositoryleri farklı doğruluk kaynaklarına sahip olabilir. Örneğin, LoginRepository sınıfı doğruluk kaynağı olarak cache’ini kullanabilir ve PaymentsRepository sınıfı network veri kaynağını kullanabilir. Offline-first desteği sağlamak için, veritabanı gibi local bir veri kaynağı önerilen doğruluk kaynağıdır. Threading . Veri kaynaklarını ve repository’leri çağırmak, main thread’den çağırmak için main-safe/güvenli olmalıdır. Bu sınıflar, uzun süreli bloklama operasyonları gerçekleştirirken logiclerinin yürütülmesini uygun thread’e taşımaktan sorumludur. Örneğin, bir veri kaynağının bir dosyadan okuma yapması ya da bir veri repository’sinin büyük bir liste üzerinde yüklü filtreleme yapması main-safe olmalıdır. Çoğu veri kaynağının Room, Retrofit veya Ktor tarafından sağlanan suspend metot çağrıları gibi main-safe API’leri zaten sağladığını unutmayın. Repositoryniz, kullanılabilir olduklarında bu API’lerden yararlanabilir. Threading hakkında daha fazla bilgi edinmek için background processing kılavuzuna bakın. Kotlin kullanıcıları için coroutine’ler önerilen seçenektir. Java programlama dili için önerilen seçenekler için Android task’larını background thread’lerde çalıştırma bölümüne bakın. Lifecycle . Data katmanındaki sınıfların instance’ları, bir garbage collection root’undan (genellikle uygulamanızdaki diğer nesnelerden referans alınarak) erişilebilir oldukları sürece bellekte kalırlar. Bir sınıf in-memory veriler içeriyorsa (örneğin bir cache), bu sınıfın aynı instance’ını belirli bir süre için yeniden kullanmak isteyebilirsiniz. Bu, sınıf instance’ının yaşam döngüsü olarak da adlandırılır. Sınıfın sorumluluğu tüm uygulama için çok önemliyse, bu sınıfın bir instance’ını Application sınıfına scope edebilirsiniz. Bu, instance’ın uygulamanın yaşam döngüsünü takip etmesini sağlar. Alternatif olarak, aynı instance’ı yalnızca uygulamanızdaki belirli bir akışta (örneğin, kayıt veya oturum açma akışı) yeniden kullanmanız gerekiyorsa, instance’ı bu akışın yaşam döngüsüne sahip olan sınıfa scope etmelisiniz. Örneğin, in-memory veriler içeren bir RegistrationRepository’yi RegistrationActivity’ye veya kayıt akışının navigation graph’ine scope edebilirsiniz. Her bir instance’ın yaşam döngüsü, uygulamanızda bağımlılıkları nasıl sağlayacağınıza karar vermede kritik bir faktördür. Bağımlılıkların yönetildiği ve bağımlılık contaitnerlarina scop edilebildiği dependency injection best practicelerini takip etmeniz önerilir. Android’de scoping hakkında daha fazla bilgi edinmek için Android’de Scoping ve Hilt blog gönderisine bakın. Represent business models . Data katmanından göstermek istediğiniz veri modelleri, farklı veri kaynaklarından aldığınız bilgilerin bir alt kümesi olabilir. İdeal olarak, farklı veri kaynakları (hem network hem de local) yalnızca uygulamanızın ihtiyaç duyduğu bilgileri döndürmelidir; ancak durum genellikle böyle değildir. Örneğin, yalnızca makale bilgilerini değil, aynı zamanda düzenleme geçmişini, kullanıcı yorumlarını ve bazı meta verileri de döndüren bir News API sunucusu düşünün: . data class ArticleApiModel( val id: Long, val title: String, val content: String, val publicationDate: Date, val modifications: Array&lt;ArticleApiModel&gt;, val comments: Array&lt;CommentApiModel&gt;, val lastModificationDate: Date, val authorId: Long, val authorName: String, val authorDateOfBirth: Date, val readTimeMin: Int ) . Uygulama, makale hakkında çok fazla bilgiye ihtiyaç duymaz çünkü ekranda yalnızca makalenin içeriğini ve yazarıyla ilgili temel bilgileri görüntüler. Model sınıflarını ayırmak ve repository’lerinizin yalnızca hiyerarşinin diğer katmanlarının ihtiyaç duyduğu verileri göstermesini sağlamak iyi bir pratiktir. Örneğin, bir Article model sınıfını domain ve UI katmanlarına göstermek için ArticleApiModel’i ağdan şu şekilde kırpabilirsiniz: . data class Article( val id: Long, val title: String, val content: String, val publicationDate: Date, val authorName: String, val readTimeMin: Int ) . Model sınıflarını ayırmak aşağıdaki şekillerde faydalıdır: . | Verileri yalnızca ihtiyaç duyulana indirgeyerek uygulama belleğinden tasarruf sağlar. | Harici veri türlerini uygulamanız tarafından kullanılan veri türlerine uyarlar - örneğin, uygulamanız tarihleri temsil etmek için farklı bir veri türü kullanabilir. | Separation of concers ilkesini daha iyi sağlar; örneğin, model sınıfı önceden tanımlanırsa büyük bir ekibin üyeleri bir feature’in network ve UI katmanları üzerinde ayrı ayrı çalışabilir. | . Bu pratiği genişletebilir ve uygulama mimarinizin diğer bölümlerinde de ayrı model sınıfları tanımlayabilirsiniz; örneğin veri kaynağı sınıflarında ve ViewModel’lerde. Ancak bu, düzgün bir şekilde belgelemeniz ve test etmeniz gereken ekstra sınıflar ve logic tanımlamanızı gerektirir. En azından, bir veri kaynağının uygulamanızın geri kalanının beklediği verilerle eşleşmeyen veriler aldığı her durumda yeni modeller oluşturmanız önerilir. Types of daya operations . Data katmanı, ne kadar kritik olduklarına bağlı olarak değişen işlem türleriyle çalışabilir:UI-oriented, app-oriented, and business-oriented operations. UI-oriented operations . UI odaklı işlemler yalnızca kullanıcı belirli bir ekrandayken geçerlidir ve kullanıcı o ekrandan ayrıldığında iptal edilirler. Veritabanından elde edilen bazı verilerin görüntülenmesi buna bir örnektir. UI odaklı işlemler genellikle UI katmanı tarafından tetiklenir ve çağıranın yaşam döngüsünü (örneğin ViewModel’in yaşam döngüsü) takip eder. UI odaklı bir işlem örneği için Network isteği yapma bölümüne bakın. App-oriented operations . Uygulama odaklı işlemler, uygulama açık olduğu sürece geçerlidir. Uygulama kapatılırsa veya işlem öldürülürse, bu işlemler iptal edilir. Bir network isteğinin sonucunun, gerektiğinde daha sonra kullanılabilmesi için önbelleğe alınması buna bir örnektir. Daha fazla bilgi için in-memory data caching bölümüne bakın. Bu işlemler genellikle Application sınıfının veya data katmanının yaşam döngüsünü takip eder. Bir örnek için, Bir işlemi ekrandan daha uzun süre yaşatın bölümüne bakın. Business-oriented operations . İş odaklı işlemler iptal edilemez. İşlem ölümünden sağ çıkmalıdırlar. Kullanıcının profiline göndermek istediği bir fotoğrafın yüklemesini bitirmek buna bir örnektir. İş odaklı işlemler için öneri WorkManager kullanmaktır. Daha fazla bilgi edinmek için WorkManager kullanarak görevleri zamanlama bölümüne bakın. Expose errors . Repositorylerle ve veri kaynaklarıyla etkileşimler başarılı olabilir veya bir hata oluştuğunda bir exception fırlatabilir. Coroutine’ler ve flow’lar için Kotlin’in yerleşik hata işleme mekanizmasını kullanmalısınız. Suspend fonksiyonları tarafından tetiklenebilecek hatalar için, uygun olduğunda try/catch bloklarını kullanın; ve flow’larda catch operatörünü kullanın. Bu yaklaşımla, UI katmanının data katmanını çağırırken exception’ları ele alması beklenir. Data katmanı farklı hata türlerini anlayabilir ve işleyebilir ve bunları özel exception’lar (örneğin UserNotAuthenticatedException) kullanarak gösterebilir. Not: Data katmanı ile etkileşimlerin sonucunu modellemenin bir başka yolu da bir Result sınıfı kullanmaktır. Bu model, sonucun işlenmesinin bir parçası olarak ortaya çıkabilecek hataları ve diğer sinyalleri modeller. Bu modelde, data katmanı T yerine bir Result tipi döndürerek UI'nin belirli senaryolarda oluşabilecek bilinen hatalardan haberdar olmasını sağlar. Bu, [LiveData]gibi uygun exception handling'e sahip olmayan reaktif programlama API'leri için gereklidir. Coroutine’lerdeki hatalar hakkında daha fazla bilgi edinmek için Exceptions in coroutines blog gönderisine bakın. Common tasks . Aşağıdaki bölümlerde, Android uygulamalarında yaygın olan belirli görevleri gerçekleştirmek için data katmanının nasıl kullanılacağına ve tasarlanacağına dair örnekler sunulmaktadır. Örnekler, kılavuzun önceki bölümlerinde bahsedilen tipik News uygulamasını temel almaktadır. Make a network request . Ağ isteği yapmak, bir Android uygulamasının gerçekleştirebileceği en yaygın görevlerden biridir. News uygulamasının kullanıcıya ağdan alınan en son haberleri sunması gerekir. Bu nedenle, uygulamanın ağ işlemlerini yönetmek için bir veri kaynağı sınıfına ihtiyacı vardır: NewsRemoteDataSource. Bilgileri uygulamanın geri kalanına göstermek için, haber verileri üzerindeki işlemleri gerçekleştiren yeni bir repository oluşturulur: NewsRepository. Gereklilik, kullanıcı ekranı açtığında en son haberlerin her zaman güncellenmesi gerektiğidir. Dolayısıyla, bu UI odaklı(UI-oriented) bir operasyondur. Create the data source . Veri kaynağının en son haberleri döndüren bir fonksiyon sunması gerekir: ArticleHeadline instancelarının bir listesi. Veri kaynağının ağdan en son haberleri almak için main-safe bir yol sağlaması gerekir. Bunun için, task’in çalıştırılacağı CoroutineDispatcher ya da Executor’a dependency(bağımlılık) alması gerekir. Bir ağ isteği yapmak, yeni bir fetchLatestNews() metodu tarafından yürütülen tek seferlik bir çağrıdır: . class NewsRemoteDataSource( private val newsApi: NewsApi, private val ioDispatcher: CoroutineDispatcher ) { /** * Fetches the latest news from the network and returns the result. * This executes on an IO-optimized thread pool, the function is main-safe. */ suspend fun fetchLatestNews(): List&lt;ArticleHeadline&gt; = // Move the execution to an IO-optimized thread since the ApiService // doesn't support coroutines and makes synchronous requests. withContext(ioDispatcher) { newsApi.fetchLatestNews() } } // Makes news-related network synchronous requests. interface NewsApi { fun fetchLatestNews(): List&lt;ArticleHeadline&gt; } . NewsApi interface’i network API client’ının implementasyonunu gizler; interface’in Retrofit veya HttpURLConnection tarafından desteklenmesi fark etmez. Interface’lere güvenmek, API implementasyonlarını uygulamanızda değiştirilebilir hale getirir. Püf Noktası: Interface’lere güvenmek, API implementasyonlarını uygulamanızda değiştirilebilir hale getirir. Ölçeklenebilirlik sağlamanın ve bağımlılıkları daha kolay değiştirmenize izin vermenin yanı sıra, testlere sahte veri kaynağı uygulamaları ekleyebildiğiniz için test edilebilirliği de destekler. Create the repository . Bu görev için repository sınıfında ekstra bir mantık gerekmediğinden, NewsRepository network veri kaynağı için bir proxy görevi görür. Bu ekstra soyutlama katmanını eklemenin faydaları in-memory caching bölümünde açıklanmıştır. // NewsRepository is consumed from other layers of the hierarchy. class NewsRepository( private val newsRemoteDataSource: NewsRemoteDataSource ) { suspend fun fetchLatestNews(): List&lt;ArticleHeadline&gt; = newsRemoteDataSource.fetchLatestNews() } . Repository sınıfını doğrudan UI katmanından nasıl kullanacağınızı öğrenmek için UI layer kılavuzuna bakın. Implement in-memory data caching . News uygulaması için yeni bir gereksinim getirildiğini varsayalım: kullanıcı ekranı açtığında, daha önce bir istek yapılmışsa cache’lenmiş haberler kullanıcıya sunulmalıdır. Aksi takdirde, uygulama en son haberleri almak için bir network isteği yapmalıdır. Yeni gereksinim göz önüne alındığında, uygulama, kullanıcı uygulamayı açık tuttuğu sürece en son haberleri bellekte tutmalıdır. Dolayısıyla, bu app-oriented operation (uygulama odaklı işlem)dur. Caches . In-memory data caching (bellek içi veri önbellekleme) ekleyerek kullanıcı uygulamanızdayken verileri koruyabilirsiniz. Cache’ler, bazı bilgileri belirli bir süre boyunca (bu durumda kullanıcı uygulamada olduğu sürece) bellekte saklamak içindir. Cache implementasyonları farklı şekillerde olabilir. Basit bir değiştirilebilir değişkenden, birden fazla thread üzerinde okuma/yazma işlemlerinden koruyan daha sofistike bir sınıfa kadar değişebilir. Kullanım durumuna bağlı olarak, caching repository’de veya veri kaynağı sınıflarında uygulanabilir. Cache the result of the network request . Basitlik açısından NewsRepository, en son haberleri cache’lemek için mutable bir değişken kullanır. Farklı thread’lerden gelen okuma ve yazmaları korumak için bir Mutex kullanılır. Paylaşılan mutable state ve concurrency hakkında daha fazla bilgi edinmek için Kotlin belgelerine bakın. Aşağıdaki implementasyon, en son haber bilgilerini repository’de bir Mutex ile yazma korumalı bir değişkene cache’ler. Network isteğinin sonucu başarılı olursa, veriler latestNews değişkenine atanır. class NewsRepository( private val newsRemoteDataSource: NewsRemoteDataSource ) { // Mutex to make writes to cached values thread-safe. private val latestNewsMutex = Mutex() // Cache of the latest news got from the network. private var latestNews: List&lt;ArticleHeadline&gt; = emptyList() suspend fun getLatestNews(refresh: Boolean = false): List&lt;ArticleHeadline&gt; { if (refresh || latestNews.isEmpty()) { val networkResult = newsRemoteDataSource.fetchLatestNews() // Thread-safe write to latestNews latestNewsMutex.withLock { this.latestNews = networkResult } } return latestNewsMutex.withLock { this.latestNews } } } . Make an operation live longer than the screen . Ağ isteği devam ederken kullanıcı ekrandan uzaklaşırsa, istek iptal edilir ve sonuç cache’lenmez. NewsRepository bu logici gerçekleştirmek için Caller’ın CoroutineScope’unu kullanmamalıdır. Bunun yerine, NewsRepository kendi yaşam döngüsüne bağlı bir CoroutineScope kullanmalıdır. En son haberleri getirmenin app-oriented bir operasyon olması gerekir. Dependency injection best practicelerini takip etmek için NewsRepository kendi CoroutineScope’unu oluşturmak yerine constructor’ında parametre olarak bir scope almalıdır. Repository’lerin işlerinin çoğunu background thread’lerde yapması gerektiğinden, CoroutineScope’u Dispatchers.Default ya da kendi thread havuzunuz ile yapılandırmalısınız. class NewsRepository( ..., // This could be CoroutineScope(SupervisorJob() + Dispatchers.Default). private val externalScope: CoroutineScope ) { ... } . NewsRepository harici CoroutineScope ile app oriented operasyonlar gerçekleştirmeye hazır olduğundan, veri kaynağına çağrıyı gerçekleştirmeli ve sonucunu bu scope tarafından başlatılan yeni bir coroutine ile kaydetmelidir: . class NewsRepository( private val newsRemoteDataSource: NewsRemoteDataSource, private val externalScope: CoroutineScope ) { /* ... */ suspend fun getLatestNews(refresh: Boolean = false): List&lt;ArticleHeadline&gt; { return if (refresh) { externalScope.async { newsRemoteDataSource.fetchLatestNews().also { networkResult -&gt; // Thread-safe write to latestNews. latestNewsMutex.withLock { latestNews = networkResult } } }.await() } else { return latestNewsMutex.withLock { this.latestNews } } } } . async, coroutine’i harici scope’da başlatmak için kullanılır. await, network isteği geri gelene ve sonuç cache’e kaydedilene kadar askıya almak için yeni coroutine üzerinde çağrılır. O zamana kadar kullanıcı hala ekrandaysa, en son haberleri görecektir; kullanıcı ekrandan uzaklaşırsa, await iptal edilir ancak async içindeki logic çalışmaya devam eder. CoroutineScope patternleri hakkında daha fazla bilgi edinmek için bu blog yazısına bakın. Save and retrieve data from disk . Bookmark edilmiş haberler ve kullanıcı tercihleri gibi verileri kaydetmek istediğinizi varsayalım. Bu tür verilerin process death’den kurtulması ve kullanıcı network’e bağlı olmasa bile erişilebilir olması gerekir. Üzerinde çalıştığınız verilerin process death’den kurtulması gerekiyorsa, aşağıdaki yollardan biriyle diskte saklamanız gerekir: . -Sorgulanması gereken, referans bütünlüğüne ihtiyaç duyan veya kısmi güncellemelere ihtiyaç duyan büyük veri kümeleri için verileri bir Room veritabanına kaydedin. News uygulaması örneğinde, haber makaleleri veya yazarları veritabanına kaydedilebilir. -Yalnızca alınması ve ayarlanması gereken (sorgulanmayan veya kısmen güncellenmeyen) küçük veri kümeleri için DataStore kullanın. News uygulaması örneğinde, kullanıcının tercih ettiği tarih biçimi veya diğer görüntüleme tercihleri DataStore’a kaydedilebilir. -JSON nesnesi gibi veri parçaları için bir dosya kullanın. Source of truth bölümünde belirtildiği gibi, her veri kaynağı yalnızca bir kaynakla çalışır ve belirli bir veri türüne karşılık gelir (örneğin, News, Authors, NewsAndAuthors veya UserPreferences). Veri kaynağını kullanan sınıflar, verilerin nasıl kaydedildiğini bilmemelidir (örneğin, bir veritabanına veya bir dosyaya). Room as a data source . Her veri kaynağının belirli bir veri türü için yalnızca bir kaynakla çalışma sorumluluğuna sahip olması gerektiğinden, bir Room veri kaynağı parametre olarak ya bir veri erişim nesnesi (DAO) ya da veritabanının kendisini alacaktır. Örneğin, NewsLocalDataSource parametre olarak NewsDao’nun bir instance’ını alabilir ve AuthorsLocalDataSource AuthorsDao’nun bir instance’ını alabilir. Bazı durumlarda, ekstra bir lojik gerekmiyorsa, DAO testlerde kolayca değiştirebileceğiniz bir interface olduğundan, DAO’yu doğrudan repository’ye enjekte edebilirsiniz. Room API’leri ile çalışma hakkında daha fazla bilgi edinmek için Room kılavuzlarına bakın. DataStore as a data source . DataStore, kullanıcı ayarları gibi key-value çiftlerini saklamak için mükemmeldir. Örnekler arasında zaman biçimi, bildirim tercihleri ve kullanıcı okuduktan sonra haber öğelerinin gösterilip gösterilmeyeceği veya gizlenip gizlenmeyeceği yer alabilir. DataStore aynı zamanda protocol buffer‘ları olan tiplendirilmiş nesneleri de depolayabilir. Diğer tüm nesnelerde olduğu gibi, DataStore tarafından desteklenen bir veri kaynağı, belirli bir türe veya uygulamanın belirli bir bölümüne karşılık gelen verileri içermelidir. Bu durum DataStore için daha da geçerlidir çünkü DataStore okumaları, bir değer her güncellendiğinde yayılan bir akış olarak açığa çıkar. Bu nedenle, ilgili tercihleri aynı DataStore’da saklamalısınız. Örneğin, yalnızca bildirimle ilgili tercihleri işleyen bir NotificationsDataStore’a ve yalnızca haber ekranıyla ilgili tercihleri işleyen bir NewsPreferencesDataStore’a sahip olabilirsiniz. Bu şekilde, newsScreenPreferencesDataStore.data akışı yalnızca o ekranla ilgili bir tercih değiştirildiğinde yayıldığı için güncellemeleri daha iyi kapsamlandırabilirsiniz. Bu aynı zamanda nesnenin yaşam döngüsünün daha kısa olabileceği anlamına gelir çünkü yalnızca haber ekranı görüntülendiği sürece yaşayabilir. DataStore API’leri ile çalışma hakkında daha fazla bilgi edinmek için DataStore kılavuzlarına bakın. A file as a data source . JSON nesnesi veya bitmap gibi büyük nesnelerle çalışırken, bir File nesnesiyle çalışmanız ve thread’leri değiştirmeniz gerekir. Storage ile çalışma hakkında daha fazla bilgi edinmek için Storage oveview sayfasına bakın. Schedule tasks using WorkManager . News uygulaması için yeni bir gereksinim daha getirildiğini varsayalım: Uygulama, kullanıcıya cihaz şarjda olduğu ve kesintisiz bir ağa bağlı olduğu sürece en son haberleri düzenli ve otomatik olarak alma seçeneği sunmalıdır. Bu da bunu business-oriented operation haline getiriyor. Bu gereklilik, kullanıcı uygulamayı açtığında cihazın bağlantısı olmasa bile kullanıcının en son haberleri görebilmesini sağlar. WorkManager, asenkron ve güvenilir iş planlamayı kolaylaştırır ve kısıtlama yönetimiyle ilgilenebilir. Kalıcı işler için önerilen kütüphanedir. Yukarıda tanımlanan görevi gerçekleştirmek için bir Worker sınıfı oluşturulur: RefreshLatestNewsWorker. Bu sınıf, en son haberleri getirmek ve diske cache’lemek için NewsRepository’yi dependency olarak alır. class RefreshLatestNewsWorker( private val newsRepository: NewsRepository, context: Context, params: WorkerParameters ) : CoroutineWorker(context, params) { override suspend fun doWork(): Result = try { newsRepository.refreshLatestNews() Result.success() } catch (error: Throwable) { Result.failure() } } . Bu tür görevler için business logic kendi sınıfında kapsüllenmeli ve ayrı bir veri kaynağı olarak ele alınmalıdır. WorkManager daha sonra yalnızca tüm kısıtlamalar karşılandığında işin bir background thread üzerinde yürütülmesini sağlamaktan sorumlu olacaktır. Bu kalıba bağlı kalarak, gerektiğinde farklı ortamlardaki uygulamaları hızlı bir şekilde değiştirebilirsiniz. Bu örnekte, haberlerle ilgili bu görev, bağımlılık olarak yeni bir veri kaynağı alacak olan NewsRepository’den çağrılmalıdır: NewsTasksDataSource, aşağıdaki gibi implemente edilmiştir: . private const val REFRESH_RATE_HOURS = 4L private const val FETCH_LATEST_NEWS_TASK = \"FetchLatestNewsTask\" private const val TAG_FETCH_LATEST_NEWS = \"FetchLatestNewsTaskTag\" class NewsTasksDataSource( private val workManager: WorkManager ) { fun fetchNewsPeriodically() { val fetchNewsRequest = PeriodicWorkRequestBuilder&lt;RefreshLatestNewsWorker&gt;( REFRESH_RATE_HOURS, TimeUnit.HOURS ).setConstraints( Constraints.Builder() .setRequiredNetworkType(NetworkType.TEMPORARILY_UNMETERED) .setRequiresCharging(true) .build() ) .addTag(TAG_FETCH_LATEST_NEWS) workManager.enqueueUniquePeriodicWork( FETCH_LATEST_NEWS_TASK, ExistingPeriodicWorkPolicy.KEEP, fetchNewsRequest.build() ) } fun cancelFetchingNewsPeriodically() { workManager.cancelAllWorkByTag(TAG_FETCH_LATEST_NEWS) } } . Bu tür sınıflar sorumlu oldukları verilere göre adlandırılır; örneğin NewsTasksDataSource veya PaymentsTasksDataSource. Belirli bir veri türüyle ilgili tüm görevler aynı sınıfta kapsüllenmelidir. Görevin uygulama başlangıcında tetiklenmesi gerekiyorsa, repository’i bir Initializer‘dan çağıran App Startup kütüphanesini kullanarak WorkManager isteğini tetiklemeniz önerilir. WorkManager API’leri ile çalışma hakkında daha fazla bilgi edinmek için WorkManager kılavuzlarına bakın. Testing . Dependency injection best practiceleri, uygulamanızı test ederken yardımcı olur. Harici kaynaklarla iletişim kuran sınıflar için interface’lere güvenmek de faydalıdır. Bir birimi test ederken, testi deterministik ve güvenilir hale getirmek için bağımlılıklarının sahte sürümlerini enjekte edebilirsiniz. Unit tests . Veri katmanını test ederken genel test yönergeleri geçerlidir. Birim testleri için, gerektiğinde gerçek nesneler kullanın ve bir dosyadan okuma veya ağdan okuma gibi harici kaynaklara ulaşan bağımlılıkları taklit edin. Integration tests . Harici kaynaklara erişen entegrasyon testleri, gerçek bir cihaz üzerinde çalıştırılmaları gerektiğinden daha az deterministik olma eğilimindedir. Entegrasyon testlerini daha güvenilir hale getirmek için bu testleri kontrollü bir ortamda yürütmeniz önerilir. Room, veritabanları için testlerinizde tamamen kontrol edebileceğiniz bir in-memory database oluşturmanıza olanak tanır. Daha fazla bilgi edinmek için Test and debug your database sayfasına bakın. Networking için, WireMock veya MockWebServer gibi HTTP ve HTTPS çağrılarını taklit etmenize ve isteklerin beklendiği gibi yapıldığını doğrulamanıza olanak tanıyan popüler kütüphaneler vardır. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer/"
  },"33": {
    "doc": "About the navigation components",
    "title": "About the navigation components",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/about-the-navigation-components/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/about-the-navigation-components/"
  },"34": {
    "doc": "About the UI layer",
    "title": "UI Layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer/#ui-layer",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer/#ui-layer"
  },"35": {
    "doc": "About the UI layer",
    "title": "About the UI layer",
    "content": "Kullanıcı arayüzünün(UI) rolü, uygulama verilerini ekranda görüntülemek ve ayrıca kullanıcı etkileşiminin(user interaction) birincil noktası olarak hizmet etmektir. Veriler, kullanıcı etkileşimi (bir butona basmak gibi) veya harici giriş (bir network response gibi) nedeniyle değiştiğinde, kullanıcı arayüzü bu değişiklikleri yansıtacak şekilde güncellenmelidir. Yani, UI, data katmanından alınan uygulama state’inin görsel bir temsilidir. Ancak data katmanından aldığınız uygulama verileri genellikle görüntülemeniz gereken bilgilerden farklı bir formattadır. Örneğin, UI için verilerin yalnızca bir kısmına ihtiyacınız olabilir veya kullanıcıyla ilgili bilgileri sunmak için iki farklı veri kaynağını birleştirmeniz gerekebilir. Uyguladığınız logic ne olursa olsun, tam olarak işlemesi için ihtiyaç duyduğu tüm bilgileri UI’ye iletmeniz gerekir. UI katmanı, uygulama veri değişikliklerini UI’in sunabileceği bir forma dönüştüren ve ardından bunu görüntüleyen piplinedir. Şekil 1. Uygulama mimarisinde UI katmanının rolü; . Not: Bu sayfada sunulan öneriler ve best practiceler, ölçeklenmelerine, kalite ve sağlamlığı artırmalarına ve test edilmelerini kolaylaştırmalarına olanak sağlamak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Architecture: The UI Layer - MAD Skills . A basic case study . Bir kullanıcının okuması için haber makaleleri getiren bir uygulama düşünün. Uygulama, okunabilecek makaleler sunan bir makaleler ekranına sahiptir ve ayrıca oturum açmış kullanıcıların gerçekten öne çıkan makalelere yer işareti koymasına olanak tanır. Her an çok sayıda makale olabileceği göz önüne alındığında, okuyucunun makalelere kategorilere göre göz atabilmesi gerekir. Özetle, uygulama, kullanıcıların aşağıdakileri yapmasına izin verir: . | Okunabilecek makaleleri görüntüleyin. | Makalelere kategoriye göre göz atın. | Oturum açın ve belirli makalelere yer işareti koyun. | Uygunsa bazı premium özelliklere erişin. | . Aşağıdaki bölümler, bu örneği, tek yönlü veri akışı ilkelerini tanıtmak ve bu ilkelerin UI katmanı için uygulama mimarisi bağlamında çözmeye yardımcı olduğu sorunları göstermek için bir use case olarak kullanır. UI layer Architecture . UI terimi, bunu yapmak için hangi API’leri kullandıklarından bağımsız olarak (Views veya Jetpack Compose) verileri görüntüleyen activity ve fragment gibi UI elementlerini ifade eder. Data katmanının rolü uygulama verilerini tutmak, yönetmek ve bunlara erişim sağlamak olduğundan, UI katmanı aşağıdaki adımları gerçekleştirmelidir: . | Uygulama verilerini tüketin(consume etmek) ve UI’in kolayca render edilebilecegi verilere dönüştürün. | UI ile render edilebilir verileri tüketin ve kullanıcıya sunulmak üzere UI elementlerine dönüştürün. | Bu birleştirilmiş UI elementlerinden kullanıcı input eventlerini tüketin ve etkilerini gerektiği gibi UI verilerine yansıtın. | 1’den 3’e kadar olan adımları gerektiği kadar tekrarlayın. | . Bu kılavuzun geri kalanı, bu adımları gerçekleştiren bir UI katmanının nasıl implementasyonunu gösterir. Bu kılavuz özellikle aşağıdaki görevleri ve kavramları kapsar: . | UI state nasıl tanımlanır. | UI state’ini üretme(produce) ve yönetme aracı olarak tek yönlü veri akışı ((Undirectional Data Flow)UDF). | UDF ilkelerine göre observable veri türleriyle UI state’i nasıl ortaya çıkar. | Observable UI state’ini tüketen UI nasıl implement edilir. Bunlardan en temel olanı UI state’inin tanımıdır. | . Define UI State . Daha önce özetlenen case study üzerinden devam edelim. Kısacası, kullanıcı arayüzü her makale için bazı metadata ile birlikte bir makale listesi gösterir. Uygulamanın kullanıcıya sunduğu bu bilgiler, UI state’dir. Başka bir deyişle: UI, kullanıcının gördüğü şeyse, UI state, uygulamanın görmeleri gerektiğini söylediği şeydir. Aynı madalyonun iki yüzü gibi, UI da UI state’in görsel temsilidir. UI state’indeki herhangi bir değişiklik, hemen UI’ye yansıtılır. Use case incelemesini düşünün; News uygulamasının gereksinimlerini karşılamak için, kullanıcı arayüzünü tam olarak oluşturmak için gereken bilgiler, aşağıdaki gibi tanımlanan bir NewsUiState data classda encapsule edilebilir: . data class NewsUiState( val isSignedIn: Boolean = false, val isPremium: Boolean = false, val newsItems: List&lt;NewsItemUiState&gt; = listOf(), val userMessages: List&lt;Message&gt; = listOf() ) data class NewsItemUiState( val title: String, val body: String, val bookmarked: Boolean = false, ... ) . Immutability . Yukarıdaki örnekteki UI state tanımı immutabledir(degismez). Bunun en önemli faydası, immutable nesnelerin zamanın bir anında uygulamanın state’ine ilişkin garantiler sağlamasıdır. Bu, UI’i tek bir role odaklanmak için serbest bırakır: state’i okumak ve UI elementlerini buna göre güncellemek. Sonuç olarak, UI verilerinin tek kaynağı(ssot) UI’nin kendisi olmadığı sürece UI state’ini asla doğrudan UI’de değiştirmemelisiniz. Bu ilkeyi ihlal etmek, aynı bilgi parçası için birden fazla doğruluk kaynağına(multiple source of truth istenmeyen durumdur) yol açarak veri tutarsızlıklarına ve ince hatalara neden olur. Örneğin, use casedeki UI state’ten bir NewsItemUiState nesnesindeki bookmarked flag’i Activity sınıfında güncellenseydi, bu flag bir makalenin bookmarked statüsünün kaynağı olarak data katmanı ile rekabet halinde olacaktı. Immutable data class’lar bu tür antipattern’leri önlemek için çok kullanışlıdır. Kilit Nokta: Yalnızca veri kaynakları veya ownerlari, ortaya koydukları verilerin güncellenmesinden sorumlu olmalıdır. Naming conventions in this guide . Bu kılavuzda, UI state sınıfları, ekranın veya tanımladıkları ekranın bir bölümünün fonksiyonalitesine göre adlandırılır. Sözleşme şu şekildedir: fonksiyonalite + UiState. Örneğin, haberleri görüntüleyen bir ekranın state’i NewsUiState olarak adlandırılabilir ve haber öğeleri listesindeki bir haber öğesinin state’i NewsItemUiState olabilir. Manage State with Undirectional Data Flow . Önceki bölüm, UI state’inin, UI’in oluşturması için gereken ayrıntıların immutable bir snapshot olduğunu belirttik. Ancak, uygulamalardaki verilerin dinamik doğası geregi, bu state’in zaman içinde değişebileceği anlamına gelir. Bunun nedeni, uygulamayı doldurmak(populate) için kullanılan temel verileri değiştiren kullanıcı etkileşimi(user interaction) veya diğer eventlar olabilir. Bu etkileşimler, bunları işlemek, her event’e uygulanacak logic’i tanımlamak ve UI state ini oluşturmak için backing data resource lerine gerekli transformationlari gerçekleştirmek için bir arabulucudan(mediator) yararlanabilir. Bu etkileşimler ve bunların logici kullanıcı arayüzünün kendisinde barındırılabilir, ancak kullanıcı arayüzü adından da anlaşılacağı gibi data owner, producer, transformer ve daha fazlası haline gelmeye başladıkça bu durum hızla hantallaşabilir. Ayrıca, ortaya çıkan kod, ayırt edilebilir sınırları olmayan tightly coupled bir karışım olduğundan, bu durum test edilebilirliği etkileyebilir. Sonuç olarak, kullanıcı arayüzü azaltılmış yükten faydalanmaya hazırdır. UI state’i çok basit olmadığı sürece, UI’nin tek sorumluluğu UI state’ini kullanmak ve görüntülemek olmalıdır. Bu bölümde, healthy separation of responsibility uygulanmasına yardımcı olan bir mimari model olan Tek Yönlü Veri Akışı (unidirectional data flow (UDF) ele alınmaktadır. State Holders . UI state’inin üretilmesinden sorumlu olan ve o görev için gerekli logici içeren sınıflara state holder denir. State Holderlar, yönettikleri ilgili UI elementlerinin scope una bağlı olarak, bottom appbar gibi tek bir widget öğesinden tüm ekrana veya bir navigation hedefine kadar çeşitli boyutlarda gelir. İkinci durumda, tipik uygulama bir ViewModel örneğidir, ancak uygulamanın gereksinimlerine bağlı olarak basit bir sınıf yeterli olabilir. Yukarıdaki case study deki News uygulaması, örneğin, o bölümde görüntülenen ekran için UI state oluşturmak üzere state holder olarak bir NewsViewModel sınıfını kullanır. Kilit Nokta: ViewModel türü, veri katmanına erişimle birlikte ekran düzeyinde Ui state’inin yönetimi için önerilen implementasyondur. Ayrıca, yapılandırma değişikliklerinden(configuration changes) otomatik olarak kurtulur. ViewModel sınıfları, uygulamadaki eventlara uygulanacak logic’i tanımlar ve sonuç olarak güncellenmiş state’i üretir. UI ile state producer arasındaki karşılıklı bağımlılığı modellemenin birçok yolu vardır. Bununla birlikte,UI ile ViewModel sınıfı arasındaki etkileşim, büyük ölçüde event input ve ardından gelen state output olarak anlaşılabileceğinden, ilişki aşağıdaki şemada gösterildiği gibi gösterilebilir: State’in aşağı doğru aktığı ve eventlarin yukarı doğru aktığı patterne tek yönlü veri akışı(unidirectional data flow) ( UDF) denir. Uygulama mimarisi için bu modelin sonuçları aşağıdaki gibidir: . | ViewModel, UI tarafından tüketilecek state’i tutar ve gösterir. UI state’i,ViewModel tarafından dönüştürülen uygulama verileridir. | UI, kullanıcı eventlerini ViewModel’e bildirir. | ViewModel, kullanıcı eylemlerini işler ve state’i günceller. | Güncellenen state, işlenmek üzere kullanıcı arayüzüne(UI) geri beslenir. | Yukarıdaki durum, bir state değişimine neden olan herhangi bir event için tekrarlanır. | . Navigation destinations veya ekranlar için ViewModel, veri almak ve bunları UI state’ine dönüştürmek için repository’ler veya use case sınıfları ile birlikte çalışır ve aynı zamanda state’in değişmesine neden olabilecek event’lerin etkilerini de dahil eder. Daha önce bahsedilen case study, her biri bir başlık, açıklama, kaynak, yazar adı, yayın tarihi ve bookmarked olup olmadığına sahip bir makale listesi içerir. Her bir makale öğesi için UI aşağıdaki gibi görünür: . Bir makaleye bookmark koymak isteyen bir kullanıcı, state değişimlerine neden olabilecek bir event’a örnektir. State producer olarak, ViewModel’in sorumluluğundaki sey; UI state’in deki tüm alanları doldurmak ve UI’in tam olarak işlemesi için gereken eventlari handle etmek amaciyla gereken tüm logici tanımlamaktır. Aşağıdaki bölümlerde, state değişikliklerine neden olan eventlere ve bunların UDF kullanılarak nasıl handle edilebilecegine daha yakından bakılmaktadır. Types of Logic . Bir makaleyi bookmarklamak, uygulamanıza değer kattığı için bir iş mantığı(business logic) örneğidir. Bununla ilgili daha fazla bilgi edinmek için veri katmanı(data layer) sayfasına bakın. Ancak, tanımlanması önemli olan farklı logic türleri vardır: . | Business logic, uygulama verileri için ürün gereksinimlerinin implement edilmesidir. Daha önce belirtildiği gibi, case study uygulamasında bir makaleye bookmark koymaktır. Business logic genellikle domain veya data katmanlarına yerleştirilir, ancak asla UI katmanına yerleştirilmez. | UI behavior logic veya UI logic, state değişikliklerinin ekranda nasıl görüntüleneceğidir. Örnekler arasında, Android Resourcelerini kullanarak ekranda gösterilecek doğru metni elde etmek, kullanıcı bir butonu tıkladığında belirli bir ekrana gitmek veya bir toast veya snackbar kullanarak ekranda bir kullanıcı mesajı görüntülemek yer alır. | . UI logici, özellikle Context gibi UI türlerini içerdiğinde, ViewModel’de değil UI’de yaşamalıdır. UI’in karmaşıklığı artarsa ve UI logicini test edilebilirliği ve endişelerin ayrılmasını(separation of concerns) desteklemek için başka bir sınıfa devretmek istiyorsanız, state holder olarak basit bir sınıf oluşturabilirsiniz. UI’de oluşturulan basit sınıflar, UI’nin yaşam döngüsünü takip ettikleri için Android SDK bağımlılıklarını alabilir; ViewModel nesnelerinin ömrü daha uzundur. State holderlar ve bunların UI oluşturmaya yardımcı olma bağlamına nasıl uydukları hakkında daha fazla bilgi için Jetpack Compose State kılavuzuna bakın. Why use UDF? . UDF, state değişimlerinin başladığı yeri, dönüştüğü yeri ve nihai olarak tüketildiği yeri de ayırır. Bu ayrım, kullanıcı arayüzünün tam olarak adının ima ettiği şeyi yapmasına olanak tanır yani state değişikliklerini gözlemleyerek(observe) bilgileri görüntüleyin ve bu değişiklikleri ViewModel’e ileterek user’in amacını iletin. Başka bir deyişle, UDF aşağıdakilere izin verir: . | Veri tutarlılığı. Kullanıcı arayüzü için tek bir doğruluk kaynağı(ssot) vardır. | Test edilebilirlik. State kaynağı yalıtılmıştır ve bu nedenle kullanıcı arabiriminden bağımsız olarak test edilebilir. | Bakım kolaylığı. State degisikligi, degisikliklerin hem kullanıcı eventlerinin hem de çektikleri veri kaynaklarının bir sonucu olduğu iyi tanımlanmış bir model izler. | . Expose UI State . UI state’inizi tanımlayıp, o state’in üretimini(produce) nasıl yöneteceğinizi belirledikten sonra sıra, üretilen state’i UI’ye sunmaktır. State’in üretimini yönetmek için UDF kullandığınız için, üretilen state’i bir stream olarak düşünebilirsiniz; başka bir deyişle, state’in birden çok sürümü zaman içinde üretilecektir. Sonuç olarak, UI state’ini LiveData veya StateFlow gibi gözlemlenebilir bir data holderla göstermelisiniz. Bunun nedeni, kullanıcı arabiriminin, verileri doğrudan ViewModel’den manuel olarak çekmek zorunda kalmadan state’de yapılan herhangi bir değişikliğe tepki verebilmesidir. Bu tipler ayrıca, yapılandırma değişikliklerinden sonra hızlı durum geri yüklemesi için yararlı olan, kullanıcı arayüzü state’inin her zaman en son sürümünün önbelleğe alınması avantajına sahiptir. //views class NewsViewModel(...) : ViewModel() { val uiState: StateFlow&lt;NewsUiState&gt; = … } . //compose class NewsViewModel(...) : ViewModel() { val uiState: NewsUiState = … } . Observable bir data holder olarak LiveData’ya giriş için bu codelab‘e bakın. Kotlin flowlara benzer bir giriş için bkz. Android’de Kotlin flows. Not: Jetpack Compose uygulamalarında, UI state’inin gösterilmesi için Compose'un mutableStateOf veya snapshotFlow gibi gözlemlenebilir State API'lerini kullanabilirsiniz. Bu kılavuzda gördüğünüz StateFlow veya LiveData gibi her türlü gözlemlenebilir data holder, uygun extensionlar kullanılarak Compose'da kolayca tüketilebilir. UI’ye maruz kalan verilerin nispeten basit olduğu durumlarda, state holderin yayılımı(emission) ile ilişkili ekran veya UI elementi arasındaki ilişkiyi aktardığı için genellikle verileri bir UI state tipine sarmaya değer. Ayrıca, UI elementi daha karmaşık hale geldikçe, UI elementini render etmek için gereken ekstra bilgileri barındırmak için UI state tanımına ekleme yapmak her zaman daha kolaydır. Bir UiState akışı oluşturmanın yaygın bir yolu, backing mutable stream’i ViewModel’den immutable stream olarak göstermektir; örneğin, MutableStateFlow'i StateFlow olarak göstermek gibi. //views class NewsViewModel(...) : ViewModel() { private val _uiState = MutableStateFlow(NewsUiState()) val uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow() ... } //compose class NewsViewModel(...) : ViewModel() { var uiState by mutableStateOf(NewsUiState()) private set ... } . ViewModel daha sonra state’i dahili olarak değiştiren methodlari expose edebilir ve UI’in tüketmesi için güncellemeler yayınlayabilir. Örneğin, asenkron bir action’in gerçekleştirilmesi gereken durumu ele alalım; viewModelScope kullanılarak bir coroutine başlatılabilir ve mutable state tamamlandıktan sonra güncellenebilir. //views class NewsViewModel( private val repository: NewsRepository, ... ) : ViewModel() { private val _uiState = MutableStateFlow(NewsUiState()) val uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow() private var fetchJob: Job? = null fun fetchArticles(category: String) { fetchJob?.cancel() fetchJob = viewModelScope.launch { try { val newsItems = repository.newsItemsForCategory(category) _uiState.update { it.copy(newsItems = newsItems) } } catch (ioe: IOException) { // Handle the error and notify the UI when appropriate. _uiState.update { val messages = getMessagesFromThrowable(ioe) it.copy(userMessages = messages) } } } } } //compose class NewsViewModel( private val repository: NewsRepository, ... ) : ViewModel() { var uiState by mutableStateOf(NewsUiState()) private set private var fetchJob: Job? = null fun fetchArticles(category: String) { fetchJob?.cancel() fetchJob = viewModelScope.launch { try { val newsItems = repository.newsItemsForCategory(category) uiState = uiState.copy(newsItems = newsItems) } catch (ioe: IOException) { // Handle the error and notify the UI when appropriate. val messages = getMessagesFromThrowable(ioe) uiState = uiState.copy(userMessages = messages) } } } } . Yukarıdaki örnekte, NewsViewModel sınıfı, belirli bir kategori için makaleleri getirmeye çalışır ve ardından, girişimin sonucunu (başarılı veya başarısız) UI’in buna uygun şekilde tepki verebileceği UI state’inde yansıtır. Hata handle etme hakkında daha fazla bilgi edinmek için Show errors on the screen bölümüne bakın . Not: State’in ViewModel’deki fonksiyonlar aracılığıyla değiştirildiği yukarıdaki örnekte gösterilen pattern, tek yönlü veri akışının(UDF) en popüler uygulamalarından biridir. Additional considerations . Önceki kılavuza ek olarak, UI state’ini gösterirken aşağıdakileri göz önünde bulundurun: . | Bir UI state object, birbiriyle ilişkili stateleri handle edebilmelidir. Bu, daha az tutarsızlığa yol açar ve kodun anlaşılmasını kolaylaştırır. News item listesini ve bookmarlarin sayısını iki farklı streamde gösterirseniz, birinin güncellenip diğerinin güncellenmediği bir durumla karşılaşabilirsiniz. Tek bir stream kullandığınızda, her iki element de güncel tutulur. Ayrıca, bazı business logic, resourcelerin bir kombinasyonunu gerektirebilir. Örneğin, yalnızca kullanıcı oturum açmışsa ve bu kullanıcı bir premium haber hizmetine aboneyse, bir bookmark butonunu göstermeniz gerekebilir. Bir UI state sınıfını aşağıdaki gibi tanımlayabilirsiniz: | . data class NewsUiState( val isSignedIn: Boolean = false, val isPremium: Boolean = false, val newsItems: List&lt;NewsItemUiState&gt; = listOf() ) val NewsUiState.canBookmarkNews: Boolean get() = isSignedIn &amp;&amp; isPremium . Bu bildirimde, bookmark butonunun görünürlüğü diğer iki propertynin türetilmiş bir propertysidir. Business logic daha karmaşık hale geldikçe, tüm propertylerin anında kullanılabilir olduğu tek bir UiState sınıfına sahip olmak giderek daha önemli hale geliyor. | Ui stateleri: tek stream mı yoksa multiple stream mı? UI stateinin tek bir akışta veya birden çok akışta göstermek arasında seçim yapmak için temel yol gösterici ilke, previous bullet pointtir: emit edilmis itemler arasındaki ilişki. Tek akış gosteriminin en büyük avantajı kolaylık ve veri tutarlılığıdır: statedeki tüketiciler her zaman her an en son bilgilere sahiptir. Ancak, ViewModel’den ayrı state akışlarının uygun olabileceği durumlar vardır: . | İlişkisiz veri türleri: Kullanıcı arayüzünü oluşturmak için gereken bazı stateler birbirinden tamamen bağımsız olabilir. Bu gibi durumlarda, özellikle bu statelerden biri diğerinden daha sık güncelleniyorsa, bu farklı stateleri bir araya getirmenin maliyeti faydalarından daha ağır basabilir. | UiState diffing: Bir UiState nesnesinde ne kadar çok field varsa, fieldlarindan birinin güncellenmesi sonucunda akışın emit etme(yayilma) olasılığı o kadar yüksektir. Viewlerin, ardışık yaymalari farklı mı yoksa aynı mı olduğunu anlamak için farklılaştırma mekanizması olmadığından, her yayma, viewde bir güncellemeye neden olur. Bu, LiveData’da Flow API’lerini veya distinctUntilChanged() gibi methodlari kullanarak hafifletmenin gerekli olabileceği anlamına gelir. | . | . Consume UI State . UI’deki UiState objelerinin streamini tüketmek için, kullandığınız gözlemlenebilir veri türü için terminal operatorunu kullanırsınız. Örneğin, LiveData için observe() methodunu, Kotlin flowlar için ise collect() methodunu veya onun varyasyonlarını kullanırsınız. UI’da observable data holder kullanırken, UI’in yaşam döngüsünü dikkate aldığınızdan emin olun. View kullanıcıya gösterilmediğinde UI’ in state’ini gözlemlememesi gerektiğinden bu önemlidir. Bu konu hakkında daha fazla bilgi edinmek için bu blog gönderisine bakın. LifecycleOwner, LiveData’yı kullanırken implicit olarak yaşam döngüsü endişelerini giderir. Flowlari kullanırken, bunu uygun coroutine kapsamı ve repeatOnLifecycle API’si ile halletmek en iyisidir: . //views class NewsActivity : AppCompatActivity() { private val viewModel: NewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { ... lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { // Update UI elements } } } } } //compose @Composable fun LatestNewsScreen( viewModel: NewsViewModel = viewModel() ) { // Show UI elements based on the viewModel.uiState } . Not: Bu örnekte kullanılan belirli StateFlow objectleri, active collectorleri olmadığında çalışmayı durdurmaz, ancak flowlarla çalışırken bunların nasıl uygulandığını bilmeyebilirsiniz. Yaşam döngüsüne duyarlı flow collection kullanmak, daha sonra downstream collector kodunu tekrar ziyaret etmeden ViewModel flowlarinda bu tür değişiklikleri yapmanızı sağlar. Show in-progress operations . Bir UiState sınıfında yükleme statelerini temsil etmenin basit bir yolu, bir boole alanı kullanmaktır: . data class NewsUiState( val isFetchingArticles: Boolean = false, ... ) . Bu flag’in değeri, UI’de bir progress bar’in varlığını veya yokluğunu temsil eder. //views class NewsActivity : AppCompatActivity() { private val viewModel: NewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { ... lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { // Bind the visibility of the progressBar to the state // of isFetchingArticles. viewModel.uiState .map { it.isFetchingArticles } .distinctUntilChanged() .collect { progressBar.isVisible = it } } } } } //compose @Composable fun LatestNewsScreen( modifier: Modifier = Modifier, viewModel: NewsViewModel = viewModel() ) { Box(modifier.fillMaxSize()) { if (viewModel.uiState.isFetchingArticles) { CircularProgressIndicator(Modifier.align(Alignment.Center)) } // Add other UI elements. For example, the list. } } . Show errors on the screen . UI’de hataların gösterilmesi, devam eden işlemleri göstermeye benzer çünkü her ikisi de varlıklarını veya yokluklarını gösteren boolean değerlerle kolayca temsil edilir. Ancak hatalar, kullanıcıya geri iletmek için ilişkili bir mesajı veya başarısız işlemi yeniden deneyen bunlarla ilişkili bir action de içerebilir. Bu nedenle, devam eden bir işlem yüklenirken veya yüklenmezken, hata durumlarının, hatanın bağlamına uygun meta verileri barındıran data classlar ile modellenmesi gerekebilir. Örneğin, makaleler getirilirken bir progress bar gösteren önceki bölümdeki örneği ele alalım. Bu işlem bir hatayla sonuçlanırsa, kullanıcıya neyin yanlış gittiğini açıklayan bir veya daha fazla mesaj görüntülemek isteyebilirsiniz. data class Message(val id: Long, val message: String) data class NewsUiState( val userMessages: List&lt;Message&gt; = listOf(), ... ) . Hata mesajları daha sonra kullanıcıya snackbar gibi UI elementleri biçiminde sunulabilir. Bu, UI eventlerinin nasıl üretildiği ve tüketildiği ile ilgili olduğundan, daha fazla bilgi edinmek için UI eventleri sayfasına bakın. Threading and concurrency . Bir ViewModel’de gerçekleştirilen herhangi bir çalışma, main threadden çağrı yapmak için main-safe olmalıdır. Bunun nedeni, işi farklı bir threade taşımaktan data ve domain layerlarin sorumlu olmasıdır. Bir ViewModel uzun süren işlemler gerçekleştiriyorsa, bu logici bir background threade taşımaktan da sorumludur. Kotlin coroutineler, concurrent operasyonlari yönetmenin harika bir yoludur ve Jetpack Architecture Components, bunlar için yerleşik destek sağlar. Android uygulamalarında coroutineleri kullanma hakkında daha fazla bilgi edinmek için bkz. Kotlin coroutines on Android. Navigation . Uygulama navigationdaki değişiklikler genellikle event benzeri yayilmalardan(emission) kaynaklanır. Örneğin, bir SignInViewModel sınıfı bir oturum açma gerçekleştirdikten sonra, UiState’in isSignedIn fieldi true olarak ayarlanmış olabilir. Bunun gibi tetikleyiciler, consumption implementasyonunun Navigation componentini ertelemesi dışında, yukarıdaki Consume UI State bölümünde kapsananlar gibi tüketilmelidir. Paging . Paging library, UI’de PagingData adlı bir tip ile tüketilir. PagingData, zaman içinde değişebilen öğeleri temsil ettiğinden ve içerdiğinden - başka bir deyişle immutable bir tip değildir - sabit bir UI state’inde temsil edilmemelidir. Bunun yerine, ViewModel’den bağımsız olarak kendi akışında göstermelisiniz. Bunun belirli bir örneği için Android Paging codelab bakın. Animations . Akıcı ve sorunsuz top level navigation transitions sağlamak için, animasyona başlamadan önce ikinci ekranın veri yüklemesini beklemek isteyebilirsiniz. Android view framework, postponeEnterTransition() ve startPostponedEnterTransition() API’leri ile fragment destinationslari arasındaki geçişleri(transitions) geciktirmek için hook sağlar. Bu API’ler, ikinci ekrandaki UI elementleri (genellikle ağdan getirilen bir görüntü), kullanıcı arabirimi bu ekrana geçişi animate etmeden önce görüntülenmeye hazır olmasını sağlamanın bir yolunu sağlar. Daha fazla ayrıntı ve uygulama özellikleri için Android Motion örneğine bakın. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer/"
  },"36": {
    "doc": "About view binding",
    "title": "About view binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/about-view-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/about-view-binding/"
  },"37": {
    "doc": "About ViewModel",
    "title": "About ViewModel",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/about-viewmodel/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/about-viewmodel/"
  },"38": {
    "doc": "About WorkManager",
    "title": "About WorkManager",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/about-workmanager/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/about-workmanager/"
  },"39": {
    "doc": "Activities",
    "title": "Activities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/activities/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/activities/"
  },"40": {
    "doc": "Activity state changes",
    "title": "Activity state changes",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/activity-state-changes/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/activity-state-changes/"
  },"41": {
    "doc": "Add capabilities",
    "title": "Add capabilities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/add-capabilities/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/add-capabilities/"
  },"42": {
    "doc": "Add new destination types",
    "title": "Add new destination types",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/add-new-destination-types/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/add-new-destination-types/"
  },"43": {
    "doc": "Add support for back navigation",
    "title": "Add support for back navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/add-support-for-back-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/add-support-for-back-navigation/"
  },"44": {
    "doc": "Advanced concepts",
    "title": "Advanced concepts",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/advanced-concepts/advanced-concepts/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/advanced-concepts/advanced-concepts/"
  },"45": {
    "doc": "Android App Bundles",
    "title": "Android App Bundles",
    "content": " ",
    "url": "/docs/core-topics/android-app-bundles/android-app-bundles/",
    
    "relUrl": "/docs/core-topics/android-app-bundles/android-app-bundles/"
  },"46": {
    "doc": "Animate transitions between destinations",
    "title": "Animate transitions between destinations",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/animate-transitions-between-destinations/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/animate-transitions-between-destinations/"
  },"47": {
    "doc": "Animate transitions between fragments",
    "title": "Animate transitions between fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/animate-transitions-between-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/animate-transitions-between-fragments/"
  },"48": {
    "doc": "Animation",
    "title": "Animation",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/animation/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/animation/"
  },"49": {
    "doc": "App architecture",
    "title": "App architecture",
    "content": " ",
    "url": "/docs/app-architecture",
    
    "relUrl": "/docs/app-architecture"
  },"50": {
    "doc": "App basics",
    "title": "App basics",
    "content": " ",
    "url": "/docs/app-basics",
    
    "relUrl": "/docs/app-basics"
  },"51": {
    "doc": "App basics",
    "title": "Introduction",
    "content": "Google Codelabs . Training Courses | Android Developers . ",
    "url": "/docs/app-basics#introduction",
    
    "relUrl": "/docs/app-basics#introduction"
  },"52": {
    "doc": "App entry points",
    "title": "App entry points",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-entry-points/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-entry-points/"
  },"53": {
    "doc": "App fundamentals",
    "title": "Application fundamentals",
    "content": "Android uygulamaları Kotlin, Java ve C++ dilleri kullanılarak yazılabilir. Android SDK araçları, kodunuzu herhangi bir veri ve kaynak dosyasıyla birlikte bir APK veya Android App Bundle’da derler. Android dosyalari derlendikten sonra .apk dosya uzantisina sahip olarak paketlenirler. Bu uzanti sayesinde uygulama Android destekli bütün cihazlara yüklenebilir hale gelir. Android App Bundle ise .aab uzantisi ile derlenirler. Apk dosyalarına göre daha küçük boyutlara sahiptirler içinde gereksiz kullanilmamis yapilar bulunmaz. Google play’de uygulamalari yayınlamak için bu formatta yuklenir. Android cihazlara direkt olarak yuklenemez. Google play kendisi içerde uygulamalari apk ya çevirip indirilmeye hazir hale getirir. Örneğin, uygulamanızı Google Play üzerinden yayinlarken, Google Play’in sunucuları, yalnızca uygulamanın yüklenmesini isteyen belirli bir cihazın gerektirdiği kaynakları ve kodu içeren optimize edilmiş APK’lar oluşturur. Her android uygulamasi kendi guvenli sanal alaninda(sandbox) yasar, bu alanlar Androidin bazi ozellikleri sayesinde korunur: . | Android işletim sistemi her uygulamayi(app) farkli bir kullanici olarak goren multi user Linux sistemidir. | Sistem her uygulamaya bir Linux user ID si atar. Bu ID sadece sistemin kendisi tarafindan bilinir diğer uygulamalar bilmez. Sistem otomatik olarak uygulamadaki tüm dosyalara erisebilmesi icin o uygulamaya atanan ID ye özel izin ayarlar. | Her işlemin kendi sanal makinesi(VM) olusturulur, bu nedenle bir uygulamanin kodu diğer uygulamalardan ayri olarak calisir. | Yani her uygulama kendi linux surecinde calisir, Android sistemi uygulama açıldığında uygulamanın componentlerini baslatir ve artık ihtiyaç kalmadığında veya sistemin diğer uygulamalar için belleği kurtarması gerektiğinde işlemi kapatır. | . Android sistemi, principle of least privilege (en az ayricalik ilkesini) uygular. Yani her uygulama isini yapmak icin gerekli islemlere ulaşabilir , fazlasina ulaşamaz. Böylece uygulamaya izin verildigi olcude sistemin bölümlerine erişebilir. Bu da guvenli bir ortam yaratmis olur. Ancak bir uygulamanin diger uygulamalara ulasmasi gereken veya sistem servislerine ulasmasini gerektirecek durumlar vardir. Bu durumlarda: . | Aynı Linux kullanıcı kimliğini paylaşacak iki uygulama ayarlamak mümkündür, bu durumda birbirlerinin dosyalarına erişebilirler. Sistem kaynaklarını korumak için, aynı kullanıcı kimliğine sahip uygulamalar aynı Linux sürecinde çalışacak ve aynı VM(sanal makineyi)’yi paylaşacak şekilde düzenlenebilir. Uygulamalar da aynı sertifika ile imzalanmalıdır. | Bir uygulama, cihazın konumu, kamerası ve Bluetooth bağlantısı gibi cihaz verilerine erişmek için izin isteyebilir. Kullanıcının bu izinleri açıkça vermesi gerekir. Daha fazla bilgi için bkz. Sistem İzinleriyle Çalışma. | . ",
    "url": "/docs/app-basics/app-fundamentals/#application-fundamentals",
    
    "relUrl": "/docs/app-basics/app-fundamentals/#application-fundamentals"
  },"54": {
    "doc": "App fundamentals",
    "title": "App components",
    "content": "Uygulama componentleri, bir Android uygulamasının temel yapı taşlarıdır. Her component, sistemin veya kullanıcının uygulamanıza girebileceği bir giriş noktasıdır. Bazı componentler diğerlerine bağlıdır. Dört farklı türde uygulama componenti vardır: . | Activities | Services | Broadcast receivers | Content providers Her component farklı bir amaca hizmet eder, her biri nasıl oluşturulacağını ve yok edileceğini tanımlayan farklı bir yaşam döngüsüne sahiptir. Bu 4 componenti daha yakından tanıyalım: | . Activities . Bir activity, kullanıcı ile etkileşim için giriş noktasıdır. Kullanıcı arayüzü olarak tek bir ekranı temsil eder. Örneğin, bir e-posta uygulamasının; yeni e-postaların listesini gösteren bir activitysi, bir e-posta oluşturmak için başka bir activitysi ve e-postaları okumak için başka bir activitysi olabilir. Activityler, e-posta uygulamasında uyumlu bir kullanıcı deneyimi oluşturmak için birlikte çalışsa da, her biri diğerlerinden bağımsızdır. Bu nedenle, e-posta uygulaması izin veriyorsa, farklı bir uygulama bu activitylerden herhangi birini başlatabilir. Örneğin, bir kamera uygulaması, kullanıcının mailden bir resim paylaşmasına izin vermek için yeni posta oluşturan activityi, e-posta uygulamasında başlatabilir. Bir activity, sistem ve uygulama arasında aşağıdaki temel etkileşimleri kolaylaştırır: . | Sistemin activiteyi barındıran(hosting) süreci çalıştırmaya devam etmesini sağlamak için kullanıcının şu anda neyle ilgilendiğini (ekranda ne olduğunu) takip etmek. | Kullanıcının uygulama icinde farkli activityler arasında geçişler yapip geri dönebileceği şeyler (onStop a alinan activitler gibi) içerdiğini bilmek ve bu nedenle bu süreçleri takip altinda tutmaya daha fazla önem vermek. | Kullanici uygulama içinde gezinirken activitlerin oldurulmesi tekrar restore edilmesi gibi süreçlerden gecer, sistemin bu durumlarla basa cikmasina yardimci olmak | Uygulamaların birbirleri arasında kullanıcı akışları olmasi ve sistemin bu akışları koordine etmesi için bir rota sağlamak. (Buradaki en klasik örnek paylaşımdır.). | . Bir activity class i olusturmak icin Activity classini miras almanız gereklidir. Activity hakkinda daha fazla bilgi almak icin, Activities kılavuzu’na bakabilirsiniz. Services . Service, bir uygulamayı her türlü nedenden dolayı arka planda çalışır durumda tutmak için genel amaçlı bir entry pointtir. Uzun süren işlemleri gerçekleştirmek veya remote işlemler için arka planda çalışan bir componentdir. Bir kullanıcı arabirimi(UI) sağlamaz. Örneğin service, kullanıcı farklı bir uygulamadayken arka planda müzik çalabilir veya kullanıcının bir activity ile etkileşimini engellemeden ağ üzerinden veri çekebilir. Activity gibi başka bir componentde, service’i başlatabilir ve çalışmasına izin verebilir, ya da service ile etkileşime geçmek için ona bağlanabilir.. Sisteme bir uygulamanın nasıl yönetileceğini söyleyen iki tür service vardır: started services ve bound services. Started services, sisteme işleri tamamlanana kadar onları çalışır durumda tutmasını söyler. Bu, arka planda bazı verileri senkronize etmek veya kullanıcı uygulamadan ayrıldıktan sonra bile müzik çalmak olabilir. Arka planda verileri senkronize etmek veya müzik çalmak, sistemin bunları işleme şeklini değiştiren iki farklı started service türünü de temsil eder: . | Müzik çalma, kullanıcının doğrudan farkında olduğu bir şeydir, bu nedenle uygulama, bunu kullanıcıya bildirmek için bir bildirimle ön planda olmak istediğini söyleyerek sisteme bildirir; bu durumda sistem, bu servicein sürecini çalışır durumda tutmak için gerçekten çok uğraşması gerektiğini bilir, çünkü bu serivein ortadan kalkması durumunda kullanıcı mutsuz olacaktır. | Normal bir arka plan servicei, kullanıcının çalıştığının doğrudan farkında olduğu bir şey değildir, bu nedenle sistem sürecini yönetmede daha fazla özgürlüğe sahiptir. Kullanıcıyı daha yakından ilgilendiren şeyler için RAM’e ihtiyaç duyarsa, öldürülmesine (ve bir süre sonra serviei yeniden başlatmasına) izin verebilir. | . Bound sevices, başka bir uygulama (veya sistem) servicei kullanmak istediğini söylediği durumlarda çalışır. Bu temelde başka bir process için API sağlayan servicedir. Böylece sistem, bu processler arasında bir bağımlılık olduğunu bilir, dolayısıyla A process’i B process’ndeki bir service’e bağlı ise, B process’ini (ve service’ini) A için çalışır durumda tutması gerektiğini bilir. Ayrıca, eğer A process’i kullanıcıyla ilgili bir şeyse, o zaman B process’ini kullanıcının da bildigi bir şey olarak ele almayı da bilir. Esneklikleri nedeniyle (iyi ya da kötü), serviceler her türlü üst düzey sistem konsepti için gerçekten yararlı bir yapı taşı haline gelir. Live wallpapers, notification listeners, screen savers, input methods, accessibility services, ve diğer birçok core sistem özellikleri uygulamaların uyguladığı ve sistemin çalışması gerektiğinde bağlandığı serviceler olarak oluşturulmuştur. Bir service, Service sınıfından miras olarak olusturulur. Service sınıfı hakkında daha fazla bilgi için Services kılavuzuna bakın. Not: Uygulamanız Android 5.0 (API düzeyi 21) veya sonraki bir sürümünü hedefliyor ise, eylemleri planlamak için JobScheduler sınıfını kullanın. JobScheduler, güç tüketimini azaltmak için işleri en uygun şekilde planlayarak ve Doze API ile çalışarak pil tasarrufu avantajına sahiptir. Bu sınıfı kullanma hakkında daha fazla bilgi için JobScheduler referans belgelerine bakın. Broadcast receivers . Broadcast receivers, sistemin eventlari app’e normal bir kullanıcı akışından farkli olarak iletilmesini sağlayan ve app’in sistem genelindeki yayın(broadcast) duyurularına yanıt vermesini sağlayan bir componentdir. Broadcast receiverlar ile sistem şu anda çalışmayan uygulamalara bile yayınlar sunabilir. Örneğin, bir uygulama, kullanıcıya yaklaşan bir etkinlik hakkında bilgi vermek için bir bildirim göndermek üzere bir alarm planlayabilir, ve bu alarmı uygulamanın BroadcastReceiver’ına ileterek, alarm kapanana kadar uygulamanın çalışır durumda kalmasına gerek kalmaz. Birçok yayın sistem tarafindan yapilir; örneğin, ekranın kapandığını, pilin azaldığını veya bir fotoğrafın çekildiğini belirten bir yayın. Uygulamalar yayın başlatabilir; örneğin, diğer uygulamalara bazı verilerin cihaza indirildiğini ve kullanımları için hazır olduğunu bildirmek için. Broadcast receiverlar bir kullanıcı arabirimi görüntülemesede, bir yayın eventi meydana geldiğinde kullanıcıyı uyarmak için bir durum çubuğu bildirimi oluşturabilirler. Daha yaygın olarak, bir broadcast receiver yalnızca diğer componentlere açılan bir geçittir ve çok az miktarda iş yapması amaçlanmıştır. Örneğin, JobScheduler ile evente dayalı olarak bazı işleri gerçekleştirmek için bir JobService planlayabilir. Bir broadcast receiver, BroadcastReceiver‘ın bir alt sınıfı olarak uygulanir ve her yayın bir Intent nesnesi olarak teslim edilir. Daha fazla bilgi için BroadcastReceiver sınıfına bakın. Content providers . Bir content provider, dosya sisteminde, bir SQLite veritabanında, web’de veya uygulamanızın erişebileceği diğer herhangi bir kalıcı depolama konumunda paylaşılan depolayabileceğiniz bir app veri grubunu yönetir. Content provider izin veriyorsa, diğer uygulamalar, content provider aracılığıyla verileri sorgulayabilir veya değiştirebilir. Örneğin, Android sistemi, kullanıcının iletişim bilgilerini yöneten bir content provider sağlar. Bu nedenle, uygun izinlere sahip herhangi bir uygulama, belirli bir kişi hakkında bilgi okumak ve yazmak için ContactsContract.Data gibi bir content provideri sorgulayabilir. Bir content provideri herhangi bir veri tabanındaki abstract yapi olarak düşünmek cezbedicidir, çünkü bu yaygın durum için çok sayıda API ve destek halihazırda mevcuttur. Ancak, sistem tasarımı perspektifinden farklı bir temel amacı vardır. Sistem için bir content provider, bir URI şeması tarafından tanımlanan adlandırılmış veri öğelerini yayınlamak için bir uygulamaya giriş noktasıdır. Böylece bir uygulama, içerdiği verileri bir URI namespace’e nasıl map etmek istediğine karar verebilir ve bu URI’leri, verilere erişmek için bunları kullanabilecek diğer varlıklara(entity) dağıtabilir. Bunun sistemin bir uygulamayı yönetirken yapmasına izin verdiği birkaç özel şey vardır: . | Bir URI atamak uygulamanın çalışır durumda kalmasını gerektirmez, bu nedenle URI’lar sahip oldukları uygulamalar çıktıktan sonra da kalabilir. Sistemin, yalnızca ilgili URI’den uygulamanın verilerini alması gerektiğinde uygulamanın hala çalıştığından emin olması gerekir. | Bu URI’ler ayrıca önemli bir fine-grained güvenlik modeli sağlar. Örneğin, bir uygulama sahip olduğu bir resmin URI’sini panoya yerleştirebilir, ancak content providerı kilitli bırakarak diğer uygulamaların buna serbestçe erişememesini sağlayabilir. İkinci bir uygulama panodaki bu URI’ye erişmeye çalıştığında, sistem bu uygulamanın geçici bir URI izin verme yoluyla verilere erişmesine izin verebilir, böylece yalnızca bu URI’nin arkasındaki verilere erişmesine izin verilir, ancak ikinci uygulamada başka hiçbir şeye izin verilmez. | . İçerik sağlayıcılar(Content providers), uygulamanıza özel olan ve paylaşılmayan verileri okumak ve yazmak için de kullanışlıdır. Bir content provider, ContentProvider‘ın bir alt sınıfı olarak uygulanır ve diğer uygulamaların işlem gerçekleştirmesini sağlayan standart bir API kümesi uygulamalıdır. Daha fazla bilgi için Content Providers kılavuzuna bakın. Android sistem tasarımının benzersiz bir yönü, herhangi bir uygulamanın başka bir uygulamanın componentini başlatabilmesidir. Örneğin, kendi uygulamanizda kullanıcının cihazın kamerasıyla bir fotoğraf çekmesini istiyorsanız, telefonda bulunan kamera uygulamasini başlatabilirsiniz. Kamera uygulamasındaki kodu eklemeniz veya hatta bağlamanız gerekmez. Bunun yerine, fotoğraf çeken kamera uygulamasındaki activityi başlatabilirsiniz. Tamamlandığında, fotoğraf uygulamanıza yollanir, böylece onu kullanabilirsiniz. Kullanıcıya, kamera aslında uygulamanızın bir parçası gibi görünür. Sistem bir componenti başlattığında, halihazırda çalışmıyorsa o uygulama Özelinde processi başlatır ve component için gereken sınıfları başlatır. Örneğin, uygulamanız fotoğraf çeken kamera uygulamasında activity başlatırsa, bu activity sizin uygulamanızın processinde değil, kamera uygulamasına ait süreçte çalışır. Bu nedenle, diğer çoğu sistemdeki uygulamaların aksine, Android uygulamalarının tek bir entry point yoktur (main() işlevi yoktur). Sistem, diğer uygulamalara erişimi kısıtlayan dosya izinleriyle her uygulamayı ayrı bir processde çalıştırdığından(application fundamentals basligi altinda anlatmıştık), uygulamanız başka bir uygulamadan bir componenti doğrudan etkinleştiremez. Ancak, Android sistemi kendisi yapabilir. Bir componenti başka bir uygulamada etkinleştirmek için sisteme belirli componenti başlatma intent’inizi belirten bir mesaj iletin. Sistem daha sonra componenti sizin için baslatacaktir. Activate components . Dört component türünden üçü—activityler, services ve broadcast receivers—intent adı verilen asenkron bir mesajla etkinleştirilir. Intentler, çalışma zamanında(runtime) birbirinden bagimsiz componentleri birbirine bağlar. Intentleri kendi uygulamanıza veya başka bir uygulamaya ait olabilen, diğer componentlerden bir action talep eden haberciler olarak düşünebilirsiniz. Bir intent, belirli bir componenti (explicit intent) veya belirli bir component türünü (implicit intent) etkinleştirmek için bir mesaj tanımlayan bir Intent nesnesiyle oluşturulur. Activityler ve serviceler için, intent; gerçekleştirilecek eylemi tanımlar(örneğin, bir şeyi görüntülemek veya göndermek için) ve başlatılmakta olan component bilmesi gerekebilecek diğer şeylerin yanı sıra üzerinde işlem yapılacak verilerin URI’sini belirtebilir. Örneğin intent, bir activitynin bir resmi göstermesi veya bir web sayfasını açması için talep iletebilir. Bazı durumlarda, bir sonuç almak için bir activity başlatabilirsiniz, bu durumda activity aynı zamanda sonucu bir Intent olarak döndürür. Örneğin, kullanıcının personal contact seçmesine ve size geri göndermesine izin vermek için bir intent yayınlayabilirsiniz. Dönen intent, seçilen kişiye işaret eden bir URI içerir. Broadcast receiverlar için intent, basitçe yayınlanmakta olan duyuruyu tanımlar. Örnek olarak; intent, aygıtın pilinin zayıf olduğunu belirten cok bilinen bir eylem olan “battery is low” stringidir. Activitylerin, servicelerin ve broadcast receiverlarin aksine, content providerlar intentler ile etkinleştirilmez. Bunun yerine, bir ContentResolver‘dan gelen bir istek tarafından hedeflendiğinde etkinleştirilirler. Content Resolver, content provider ile olan tüm doğrudan işlemleri gerçekleştirir, böylece provider ile işlem gerçekleştiren componentin buna ihtiyacı olmaz ve bunun yerine ContentResolver nesnesindeki methodlari çağırır. Bu, content provider ile bilgi talep eden component arasında bir soyutlama katmanı bırakır(güvenlik için). Her component türünü etkinleştirmek için ayrı methodlar vardır: . | startActivity() veya startActivityForResult() methodlarina Intent paslayarak, | Android 5.0 (API düzeyi 21) ve sonraki sürümlerde, eylemleri(action) planlamak için JobScheduler sınıfını kullanabilirsiniz. Daha önceki Android sürümleri için, bir Intent öğesini startService() methoduna ileterek bir service başlatabilir (veya devam eden bir servise yeni talimatlar verebilirsiniz). BindService()‘e bir Intent ileterek service bağlanabilirsiniz. | sendBroadcast(), sendOrderedBroadcast(), veya sendStickyBroadcast() gibi yöntemlere bir Intent paslayarak bir broadcast başlatabilirsiniz. | Bir ContentResolver üzerinde query() methodunu çağırarak bir content providera sorgu gerçekleştirebilirsiniz. | . Intentleri kullanma hakkında daha fazla bilgi için Intents and Intent Filters belgesine bakın. ",
    "url": "/docs/app-basics/app-fundamentals/#app-components",
    
    "relUrl": "/docs/app-basics/app-fundamentals/#app-components"
  },"55": {
    "doc": "App fundamentals",
    "title": "The manifest file",
    "content": "Android sistemi bir uygulama componentini başlatmadan önce, sistem, uygulamanın manifest dosyası AndroidManifest.xml’yi okuyarak bileşenin var olduğunu bilmelidir. Uygulamanız, uygulama proje dizininin rootunda olması gereken tüm componentleri bu dosya icinde bildirmelidir. Manifest dosyasi, uygulamanın bileşenlerini bildirmenin yanı sıra aşağıdakiler gibi birkaç şey daha yapar: . | İnternet erişimi veya kullanıcının kişilerine okuma erişimi gibi uygulamanın gerektirdiği tüm kullanıcı izinlerini tanımlar. | Uygulamanın kullandığı API’lere bağlı olarak, uygulamanın gerektirdiği minimum API Düzeyini bildirir. | Kamera, bluetooth hizmetleri veya çoklu dokunmatik ekran gibi uygulama tarafından kullanılan veya gerekli olan donanım ve yazılım özelliklerini bildirir. | Uygulamanın Google Haritalar librarysi gibi (Android framework API’leri dışında) bağlanması gereken API librarylerini bildirir. | . Declare components . Manifestin birincil görevi, sistemi uygulamanın componentleri hakkında bilgilendirmektir. Örneğin, bir manifest dosyası aşağıdaki gibi bir activity bildirebilir: . &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest ... &gt; &lt;application android:icon=\"@drawable/app_icon.png\" ... &gt; &lt;activity android:name=\"com.example.project.ExampleActivity\" android:label=\"@string/example_label\" ... &gt; &lt;/activity&gt; ... &lt;/application&gt; &lt;/manifest&gt; . [](https://developer.android.com/guide/topics/manifest/application-element) öğesinde, android:icon attribute, uygulamayı tanımlayan bir icon için kaynaklara işaret eder. [](https://developer.android.com/guide/topics/manifest/activity-element) öğesinde, android:name attiribute, [Activity](https://developer.android.com/reference/android/app/Activity) alt sınıfının tam nitelikli sınıf adını belirtir ve android:label attribute, activity için kullanıcı tarafından görülebilen label olarak kullanılacak bir string belirtir. Aşağıdaki öğeleri kullanarak tüm uygulama bileşenlerini bildirmelisiniz: . &lt;activity&gt; activityler icin. &lt;service&gt; serviceler icin. &lt;receiver&gt; broadcast receiver icin . &lt;provider&gt; content provider icin . Kodlariniza dahil ettiğiniz ancak manifestte beyan etmediğiniz activityler, seviceler ve content providerlar sistem tarafından görülmez ve sonuç olarak hiçbir zaman çalıştırılamaz. Ancak, broadcast receiverlari manifestte bildirilebilir veya bunun yerine kodda dinamik olarak BroadcastReceiver nesneleri olarak oluşturulabilir ve registerReceiver() çağrılarak sisteme kaydedilebilirsiniz. Uygulamanız için manifest dosyasının nasıl yapılandırılacağı hakkında daha fazla bilgi için AndroidManifest.xml dosyası belgelerine bakın. Declare component capabilities . Yukarıda tartışıldığı gibi, Activating Components bölümünde, activityleri, serviceleri ve broadcast receiverlari başlatmak için bir Intent kullanabilirsiniz. Intentde hedef bileşeni explicit adlandırarak (component sınıfı adını kullanarak) bir intent kullanabilirsiniz. Ayrıca, gerçekleştirilecek eylemin türünü ve isteğe bağlı olarak eylemi gerçekleştirmek istediğiniz verileri açıklayan implicit bir intentde kullanabilirsiniz. Implicit intent, sistemin cihazda eylemi gerçekleştirebilecek ve başlatabilecek bir component bulmasını sağlar. Intent tarafından açıklanan eylemi gerçekleştirebilecek birden fazla component varsa, kullanıcı hangisini kullanacağını seçer. Dikkat: Bir Service başlatmak için bir intent kullanırsanız, explicit bir intent kullanarak uygulamanızın güvenli olduğundan emin olun. Bir service başlatmak için implicit bir intent kullanmak bir güvenlik tehlikesidir, çünkü intent’e hangi hizmetin yanıt vereceğinden emin olamazsınız ve kullanıcı hangi service’in başladığını göremez. Android 5.0’dan (API düzeyi 21) başlayarak, bindService() öğesini implicit bir intent ile çağırırsanız sistem bir exception firlatir. Serviceleriniz için intent filterlar beyan etmeyin. Sistem, alınan intenti cihazdaki diğer uygulamaların manifest dosyasında sağlanan intent filterlar ile karşılaştırarak bir intente yanıt verebilecek componentleri tanımlar. Uygulamanızın manifest dosyasinda bir activity bildirdiğinizde, isteğe bağlı olarak, diğer uygulamalardan gelen intentlere yanıt verebilmesi için activitynin yeteneklerini bildiren intent filterleri ekleyebilirsiniz. Componentin manifest elementinin alt öğesi olarak bir elementi ekleyerek componentiniz için bir intent filter bildirebilirsiniz. Örneğin, yeni bir e-posta oluşturma activitysi olan bir e-posta uygulaması oluşturursanız, aşağıdaki örnekte gösterildiği gibi “gönderme(send)” intentlerine yanıt vermek için (yeni bir e-posta göndermek için) bir intent filter bildirebilirsiniz: . &lt;manifest ... &gt; ... &lt;application ... &gt; &lt;activity android:name=\"com.example.project.ComposeEmailActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\" /&gt; &lt;data android:type=\"*/*\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; . Başka bir uygulama, ACTION_SEND action ile bir intent oluşturur ve bunu startActivity() methoduna iletirse, sistem, kullanıcının bir e-posta taslağı oluşturabilmesi ve gönderebilmesi için activitynizi başlatabilir. Intent filterleri oluşturma hakkında daha fazla bilgi için Intents ve Intent Filters belgesine bakın. Declare app requirements . Android tarafından desteklenen çeşitli cihazlar vardır ve bunların hepsi aynı özellikleri ve yetenekleri sağlamaz. Uygulamanızın, uygulamanızın ihtiyaç duyduğu özelliklere sahip olmayan cihazlara yüklenmesini önlemek için, manifest dosyanızda cihaz ve yazılım gereksinimlerini bildirerek uygulamanızın desteklediği cihaz türleri için açık bir şekilde bir profil tanımlamanız önemlidir. Bu bildirimlerin çoğu yalnızca bilgi amaçlıdır ve sistem bunları okumaz, ancak Google Play gibi harici hizmetler, kullanıcıların cihazlarından uygulama aradıklarında filtreleme sağlamak için bunları okur. Örneğin, uygulamanız bir kamera gerektiriyorsa ve Android 8.0’da (API Düzeyi 26) sunulan API’leri kullanıyorsa, bu gereksinimleri beyan etmeniz gerekir. minSdkVersion ve targetSdkVersion değerleri, uygulama modülünüzün build.gradle dosyasında ayarlanır: . android { ... defaultConfig { ... minSdkVersion 26 targetSdkVersion 29 } } . Not: MinSdkVersion ve targetSdkVersion’ı doğrudan manifest dosyasında ayarlamayın, çünkü derleme işlemi sırasında Gradle bunların üzerine yazılacaktır. Daha fazla bilgi için bkz. API düzeyi gereksinimlerini belirtme. Kamera özelliğini doğrudan uygulamanızın bildirim dosyasında bildirin: . &lt;manifest ... &gt; &lt;uses-feature android:name=\"android.hardware.camera.any\" android:required=\"true\" /&gt; ... &lt;/manifest&gt; . Bu örneklerde gösterilen bildirimler ile kamerası olmayan veya Android sürümü 8.0’dan düşük olan cihazlar, uygulamanızı Google Play’den yükleyemez. Ancak, uygulamanızın kamerayı kullandığını, ancak bunu gerektirmediğini beyan edebilirsiniz. Bu durumda, uygulamanız required attribute false olarak ayarlamalı ve çalışma zamanında cihazın bir kamerası olup olmadığını kontrol etmeli ve uygun şekilde tüm kamera özelliklerini devre dışı bırakmalıdır. Uygulamanızın farklı cihazlarla uyumluluğunu nasıl yönetebileceğiniz hakkında daha fazla bilgi Device Compatibility (Cihaz Uyumluluğu) dokumaninda sağlanır. ",
    "url": "/docs/app-basics/app-fundamentals/#the-manifest-file",
    
    "relUrl": "/docs/app-basics/app-fundamentals/#the-manifest-file"
  },"56": {
    "doc": "App fundamentals",
    "title": "App resources",
    "content": "Bir Android uygulaması koddan daha fazlasını içerir; görüntüler, ses dosyaları ve uygulamanın görsel sunumuyla ilgili her şey gibi kaynak koddan ayrı kaynaklar gerektirir. Örneğin, XML dosyalarıyla animasyonları, menüleri, stilleri, renkleri ve etkinlik kullanıcı arabirimlerinin düzenini tanımlayabilirsiniz. Uygulama kaynaklarını kullanmak, kodu değiştirmeden uygulamanızın çeşitli özelliklerini güncellemeyi kolaylaştırır. Alternatif kaynak grupları sağlamak, uygulamanızı farklı diller ve ekran boyutları gibi çeşitli cihaz yapılandırmaları için optimize etmenize olanak tanır. Android projenize dahil ettiğiniz her kaynak için, SDK oluşturma toollari, uygulama kodunuzdan veya XML’de tanımlanan diğer kaynaklardan, kaynağa başvurmak için kullanabileceğiniz unique bir integer ID tanımlar. Örneğin, uygulamanız logo.png (res/drawable/ dizinine kaydedilmiş) adlı bir resim dosyası içeriyorsa, SDK araçları R.drawable.logo adlı bir resources ID oluşturur. Bu ID, resme referans vermek ve onu kullanıcı arayüzünüze eklemek için kullanabileceğiniz uygulamaya özel bir integer ile eşlenir. Kaynak kodunuzdan ayrı kaynaklar sağlamanın en önemli yönlerinden biri, farklı cihaz yapılandırmaları için alternatif kaynaklar sağlama yeteneğidir. Örneğin, UI stringlerini XML’de tanımlayarak, stringleri diğer dillere çevirebilir ve bu stringleri ayrı dosyalara kaydedebilirsiniz. Ardından Android, kaynak dizinin adına (Fransızca dize değerleri için res/values-fr/ gibi) ve kullanıcının dil ayarına eklediğiniz bir dil niteleyicisine(qualifier) dayalı olarak kullanıcı arabiriminize uygun dil stringlerini bastirabilirsiniz. Android, alternatif kaynaklarınız için birçok farklı niteleyiciyi(qualifier) destekler. Niteleyici(qualifier), bu kaynakların kullanılacağı aygıt yapılandırmasını tanımlamak için kaynak dizinlerinizin adına eklediğiniz kısa bir dizedir. Örneğin, cihazın ekran yönüne ve boyutuna bağlı olarak activityleirniz için farklı layoutlar oluşturmalısınız. Aygıt ekranı dikey yönde (uzun) olduğunda, buttonlarin dikey olmasını isteyebilirsiniz, ancak ekran yatay yönde (geniş) olduğunda buttonlar yatay olarak hizalanabilir. Oryantasyona bağlı olarak layoutu değiştirmek için iki farklı layout tanımlayabilir ve her bir layoutun dizin adına uygun niteleyiciyi(qualifier) uygulayabilirsiniz. Ardından sistem, mevcut cihaz yönüne bağlı olarak uygun layoutu otomatik olarak uygular. For more about the different kinds of resources you can include in your application and how to create alternative resources for different device configurations, read Providing Resources. To learn more about best practices and designing robust, production-quality apps, see Guide to App Architecture. Additional resources . ",
    "url": "/docs/app-basics/app-fundamentals/#app-resources",
    
    "relUrl": "/docs/app-basics/app-fundamentals/#app-resources"
  },"57": {
    "doc": "App fundamentals",
    "title": "App fundamentals",
    "content": " ",
    "url": "/docs/app-basics/app-fundamentals/",
    
    "relUrl": "/docs/app-basics/app-fundamentals/"
  },"58": {
    "doc": "App links",
    "title": "App links",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/app-links/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/app-links/"
  },"59": {
    "doc": "App navigation",
    "title": "App navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-navigation/"
  },"60": {
    "doc": "App resources",
    "title": "App resources",
    "content": " ",
    "url": "/docs/app-basics/app-resources/app-resources/",
    
    "relUrl": "/docs/app-basics/app-resources/app-resources/"
  },"61": {
    "doc": "App shortcuts",
    "title": "App shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/app-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/app-shortcuts/"
  },"62": {
    "doc": "App startup",
    "title": "App startup",
    "content": " ",
    "url": "/docs/app-architecture/app-startup/",
    
    "relUrl": "/docs/app-architecture/app-startup/"
  },"63": {
    "doc": "Architecture components",
    "title": "Architecture components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/architecture-components/",
    
    "relUrl": "/docs/app-architecture/architecture-components/architecture-components/"
  },"64": {
    "doc": "Architecture recommendations",
    "title": "Architecture recommendations",
    "content": "Recommendations for Android Architecture . Bu sayfada çeşitli Architecture best practiceleri ve önerileri sunulmaktadır. Uygulamanızın kalitesini, sağlamlığını ve ölçeklenebilirliğini artırmak için bunları benimseyin. Ayrıca uygulamanızın bakımını ve test edilmesini de kolaylaştırırlar. Not: Bu belgedeki önerileri katı gereklilikler olarak değil tavsiyeler olarak ele almalısınız. Gerektiğinde bunları uygulamanıza uyarlayın. Aşağıdaki best practiceler konuya göre gruplandırılmıştır. Her birinin, ekibin ne kadar güçlü bir şekilde önerdiğini yansıtan bir önceliği vardır. Öncelikler listesi aşağıdaki gibidir: . | Strongly recommended: Yaklaşımınızla temelden çelişmediği sürece bu pratiği uygulamalısınız. | Recommended: Bu pratiğin uygulamanızı geliştirmesi muhtemeldir. | Optional: Bu pratik, belirli durumlarda uygulamanızı geliştirebilir. | . Not: Bu önerileri anlamak için [Architecture kılavuzu](guide-to-app-architecture)na aşina olmanız gerekir. Layer Architecture . Önerdiğimiz katmanlı mimari, seperation of concern’i destekler. UI’yi veri modellerinden yönlendirir, single source of truth ilkesine uyar ve undirectional data flow ilkelerini takip eder. İşte katmanlı mimari için bazı best practiceler: . | Recommendation | Description | . | Açıkça tanımlanmış bir data katmanı kullanın. Strongly recommended: | Data katmanı, uygulama verilerini uygulamanın geri kalanına sunar ve uygulamanızın business logic’inin büyük çoğunluğunu içerir.&lt;/br&gt; * Sadece tek bir veri kaynağı içerse bile veri repositorylerini oluşturmalısınız. &lt;/br&gt;* Küçük uygulamalarda, data katmanı türlerini bir data paketine veya modülüne yerleştirmeyi seçebilirsiniz | . | Açıkça tanımlanmış bir UI katmanı kullanın. Strongly recommended: | UI katmanı, uygulama verilerini ekranda görüntüler ve kullanıcı etkileşiminin birincil noktası olarak hizmet eder.&lt;/br&gt;* Küçük uygulamalarda, data katmanı tiplerini bir UI paketine veya modülüne yerleştirmeyi seçebilirsiniz.Daha fazla UI katmanı best practiceleri burada. | . | Data katmanı, bir repository kullanarak uygulama verilerini açığa çıkarmalıdır. Strongly recommended: | UI katmanındaki componentler, activity’ler veya ViewModel’lar gibi componentler doğrudan bir veri kaynağı ile etkileşime girmemelidir. Veri kaynaklarına örnekler şunlardır: &lt;/br&gt;* Databases, DataStore, SharedPreferences, Firebase APIs.&lt;/br&gt; * GPS location providers. &lt;/br&gt; * Bluetooth data providers.&lt;/br&gt; * Network connectivity status provider. | . | Coroutines ve flowlari kullanin. Strongly recommended: | Katmanlar arasında iletişim kurmak için coroutine’leri ve flow’ları kullanın. More coroutines best practices here. | . | Domain layer kullanin. Recommended in big apps | Birden fazla ViewModel’de data katmanıyla etkileşime giren business logic’i yeniden kullanmanız gerekiyorsa veya belirli bir ViewModel’in business logic karmaşıklığını basitleştirmek istiyorsanız bir domain katmanı, use caseleri kullanın. | . UI Layer . UI katmanının rolü, uygulama verilerini ekranda görüntülemek ve kullanıcı etkileşiminin birincil noktası olarak hizmet etmektir. İşte UI katmanı için bazı best practiceler: . | Recommendation | Description | . | Unidirectional Data Flow (UDF’i takip edin.. Strongly recommended: | ViewModel’lerin observer pattern kullanarak UI state’ini gösterdiği ve metot çağrıları yoluyla UI’dan action’lar aldığı Unidirectional Data Flow (UDF) prensiplerini takip edin. | . | Faydaları uygulamanız için uygunsa AAC ViewModellerini kullanın. Strongly recommended: | Business logic’i handle etmek için AAC ViewModels’i kullanın ve UI state’ini UI’ye göstermek için uygulama verilerini getirin (Compose veya Android Views).&lt;/br&gt; See more ViewModel best practices here.&lt;/br&gt;See the benefits of ViewModels here. | . | Yaşam döngüsüne duyarlı UI state collection kullanın. Strongly recommended: | Uygun yaşam döngüsüne duyarlı coroutine builder kullanarak UI state’ini UI’dan collect edin: View sisteminde repeatOnLifecycle ve Jetpack Compose’da collectAsStateWithLifecycle.&lt;/br&gt;Read more about repeatOnLifecycle.&lt;/br&gt; Read more about about collectAsStateWithLifecycle. | . | ViewModel’den UI’ye event göndermeyin. Strongly recommended: | Event’i ViewModel’de doğrudan işleyin ve event’in işlenmesinin sonucuyla bir state güncellemesine neden olun. UI event’leri hakkında daha fazla bilgiyi burada bulabilirsiniz. | . | Single-activity application kullanin. Recommended | Uygulamanızın birden fazla ekranı varsa ekranlar arasında gezinmek ve uygulamanıza deep link vermek için Navigation Fragments veya Navigation Compose kullanın. | . | Jetpack Compose kullanin. Recommended | Telefonlar, tabletler, katlanabilir cihazlar ve Wear OS için yeni uygulamalar oluşturmak üzere Jetpack Compose’u kullanın. | . Aşağıdaki kod parçacığı, UI state’inin yaşam döngüsüne duyarlı bir şekilde nasıl collect edileceğini özetlemektedir: . //Views class MyFragment : Fragment() { private val viewModel: MyViewModel by viewModel() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launch { viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { // Process item } } } } } //Compose @Composable fun MyScreen( viewModel: MyViewModel = viewModel() ) { val uiState by viewModel.uiState.collectAsStateWithLifecycle() } . ViewModel . ViewModeller, UI state’ini sağlamaktan ve data katmanına erişimden sorumludur. ViewModel’ler için bazı best practiceler aşağıda verilmiştir: . | Recommendation | Description | . | ViewModeller Android yaşam döngüsünden bağımsız olmalıdır. Strongly recommended: | ViewModel’ler Yaşam Döngüsü ile ilgili herhangi bir tipe referans tutmamalıdır. Activity, Fragment, Context veya Resources’ı bağımlılık olarak geçirmeyin. Bir şeyin ViewModel’de bir Context’e ihtiyacı varsa, bunun doğru katmanda olup olmadığını mutlaka değerlendirmelisiniz. | . | Coroutine’leri ve flow’ları kullanın. Strongly recommended: | ViewModel, data veya domain katmanları ile etkileşime girer:&lt;/br&gt;Uygulama verilerini almak için Kotlin flow’ları,&lt;/br&gt; viewModelScope kullanarak actionlari gerçekleştirmek için suspend fonksiyonlari kullanin. | . | Ekran seviyesinde ViewModelleri kullanın.&lt;/br&gt; Strongly recommended: | ViewModel’ları yeniden kullanılabilir UI parçalarında kullanmayın. ViewModel’leri şuralarda kullanmalısınız;&lt;/br&gt;Screen-level composables,&lt;/br&gt;Activities/Fragments in Views,&lt;/br&gt;Destinations or graphs when using Jetpack Navigation. | . | Use plain state holder classes in reusable UI components.&lt;/br&gt; Strongly recommended: | Yeniden kullanılabilir UI component’lerinde karmaşıklığı ele almak için düz state holder sınıflarını kullanın. Bunu yaparak, state harici olarak çağrılabilir ve kontrol edilebilir. | . | AndroidViewModel kullanma. Recommended | ViewModel class kullanin, AndroidViewModel kullanmayin. ViewModelde Application class kullanmamalisiniz. Bunun yerine, bağımlılığı UI veya data katmanına taşıyın. | . | Bir UI state açığa çıkarın. Recommended | ViewModeller, uiState adlı single property aracılığıyla UI’ye veri göstermelidir. UI birden fazla, ilgisiz veri parçası gösteriyorsa, VM multiple UI state property gösterebilir.&lt;/br&gt;uiState’i bir StateFlow yapmalısınız.&lt;/br&gt;Veriler hiyerarşinin diğer katmanlarından bir veri akışı olarak geliyorsa, WhileSubscribed(5000) ilkesiyle (örnek) stateIn operatörünü kullanarak uiState oluşturmalısınız.&lt;/br&gt;Data katmanından gelen veri akışlarının olmadığı daha basit durumlar için, immutable bir StateFlow olarak açığa çıkan bir MutableStateFlow kullanmak kabul edilebilir (örnek).&lt;/br&gt;Data, error ve loading sinyalleri içerebilen bir data class olarak ${Screen}UiState’e sahip olmayı seçebilirsiniz. Bu sınıf, farklı statelerin özel olması halinde sealed class da olabilir.Application sınıfı ViewModel’de kullanılmamalıdır. Application sınıfı ViewModel’de kullanılmamalıdır. Bunun yerine, bağımlılığı kullanıcı arayüzüne veya veri katmanına taşıyın. | . Aşağıdaki kod parçacığı, UI state’inin bir ViewModel’den nasıl açığa çıkarılacağını özetlemektedir: . @HiltViewModel class BookmarksViewModel @Inject constructor( newsRepository: NewsRepository ) : ViewModel() { val feedState: StateFlow&lt;NewsFeedUiState&gt; = newsRepository .getNewsResourcesStream() .mapToFeedState(savedNewsResourcesState) .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = NewsFeedUiState.Loading ) // ... } . Lifecycle . Aşağıda Android yaşam döngüsü ile çalışmaya yönelik best practiceler yer almaktadır: . | Recommendation | Description | . | Activity’lerde veya Fragment’larda yaşam döngüsü metotlarını override etmeyin.&lt;/br&gt; Strongly recommended: | Activity’lerde veya Fragment’larda onResume gibi yaşam döngüsü metodlarını override etmeyin. Bunun yerine LifecycleObserver kullanın. Uygulamanın, yaşam döngüsü belirli bir Lifecycle.State değerine ulaştığında iş yapması gerekiyorsa repeatOnLifecycle API’sini kullanın. | . Aşağıdaki kod parçacığı, belirli bir Yaşam Döngüsü state’i verildiğinde işlemlerin nasıl gerçekleştirileceğini özetlemektedir: . //Views class MyFragment: Fragment() { override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycle.addObserver(object : DefaultLifecycleObserver { override fun onResume(owner: LifecycleOwner) { // ... } override fun onPause(owner: LifecycleOwner) { // ... } } } } //Compose @Composable fun MyApp() { val lifecycleOwner = LocalLifecycleOwner.current DisposableEffect(lifecycleOwner, ...) { val lifecycleObserver = object : DefaultLifecycleObserver { override fun onStop(owner: LifecycleOwner) { // ... } } lifecycleOwner.lifecycle.addObserver(lifecycleObserver) onDispose { lifecycleOwner.lifecycle.removeObserver(lifecycleObserver) } } } . Handle dependencies . Componentler arasındaki bağımlılıkları yönetirken gözlemlemeniz gereken birkaç best practice vardir: . | Recommendation | Description | . | Dependency injection kullanin.&lt;/br&gt; Strongly recommended: | Dependency injection best practiceleri kullanin, ozellikle mumkun oldugunca constructor injection kullanin. | . | Gerektiginde bir componentin scope’nu belirleyin.&lt;/br&gt; Strongly recommended: | Scope to a dependency container; tip paylaşılması gereken mutable veriler içerdiğinde veya tipin init edilmesi pahalı olduğunda ve uygulamada yaygın olarak kullanıldığında. | . | Hilt kullanin. Recommended | Basit uygulamalarda Hilt veya manual dependency injection kullanin. Uygulamaniz karmasiklastiginda Hilt kullanin. Ornegin asagidakilere sahipseniz: &lt;/br&gt;Multiple screens with ViewModels—integration&lt;/br&gt;WorkManager usage—integration&lt;/br&gt;Advance usage of Navigation, such as ViewModels scoped to the nav graph—integration. | . Testing . Aşağıda test için bazı best practiceler verilmiştir: . | Recommendation | Description | . | Neyi test edeceginizi bilin. Strongly recommended: | Unless the project is roughly as simple as a hello world app, you should test it, at minimum with:&lt;/br&gt;Unit test ViewModels, including Flows.&lt;/br&gt;Unit test data layer entities. That is, repositories and data sources.&lt;/br&gt;UI navigation tests that are useful as regression tests in CI. | . | Prefer fakes to mocks. Strongly recommended: | Read more in the Use test doubles in Android documentation. | . | Test StateFlows. Strongly recommended: | When testing StateFlow:&lt;/br&gt;Assert on the value property whenever possible&lt;/br&gt;You should create a collectJob if using WhileSubscribed | . Daha fazla bilgi için Android DAC’da neleri test etmeli kılavuzuna bakın. Models . Uygulamalarınızda model geliştirirken bu best practiceleri uymalısınız: . | Recommendation | Description | . | Karmaşık uygulamalarda her katman için bir model oluşturun. Recommended | Karmaşık uygulamalarda, mantıklı olduğunda farklı katmanlarda veya componentlerde yeni modeller oluşturun. Aşağıdaki örnekleri göz önünde bulundurun:&lt;/br&gt;Uzak bir veri kaynağı, ağ üzerinden aldığı modeli, yalnızca uygulamanın ihtiyaç duyduğu verileri içeren daha basit bir sınıfla eşleyebilir&lt;/br&gt;Repository’ler DAO modellerini sadece UI katmanının ihtiyaç duyduğu bilgilerle daha basit data classlara eşleyebilir.&lt;/br&gt;ViewModel, UiState sınıflarındaki data katmanı modellerini içerebilir. | . Naming Conventions . Kod tabanınızı adlandırırken, aşağıdaki best practice’lerden haberdar olmalısınız: . | Recommendation | Description | . | Methodlari isimlendirmek.&lt;/br&gt; Optional: | Metodlar bir fiil cümlesi olmalıdır. Örneğin, makePayment(). | . | Propertyleri isimlendirmek.&lt;/br&gt; Optional: | Propertyler bir isim cümlesi olmalıdır. Örneğin, inProgressTopicSelection. | . | Data akislarini isimlendirmek&lt;/br&gt; Optional: | Bir sınıf bir Flow stream, LiveData veya başka bir stream sunduğunda, adlandırma kuralı get{model}Stream() şeklindedir. Örneğin, getAuthorStream(): Flow. Fonksiyon bir model listesi döndürüyorsa, model adı çoğul olmalıdır:getAuthorsStream(): Flow&lt;List&gt; | . | Interface implementasyonlarini isimlendirmek.&lt;/br&gt; Optional: | Interfacelerin implementasyonları için isimler anlamlı olmalıdır. Daha iyi bir isim bulunamazsa önek olarak Default kullanın. Örneğin, bir NewsRepository interface’i için OfflineFirstNewsRepository veya InMemoryNewsRepository kullanabilirsiniz. Eğer iyi bir isim bulamazsanız, DefaultNewsRepository kullanın. Sahte implementasyonların önüne FakeAuthorsRepository’de olduğu gibi Fake eklenmelidir. | . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/architecture-recommendatios/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/architecture-recommendatios/"
  },"65": {
    "doc": "Best practices for multi-module projects",
    "title": "Best practices for multi-module projects",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/best-practices-for-multi-module-projects/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/best-practices-for-multi-module-projects/"
  },"66": {
    "doc": "Best practices for shortcuts",
    "title": "Best practices for shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/best-practices-for-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/best-practices-for-shortcuts/"
  },"67": {
    "doc": "Best practices",
    "title": "Best practices",
    "content": " ",
    "url": "/docs/best-practices",
    
    "relUrl": "/docs/best-practices"
  },"68": {
    "doc": "Bind layout views to architecture components",
    "title": "Bind layout views to architecture components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/bind-layout-views-to-archtecture-components/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/bind-layout-views-to-archtecture-components/"
  },"69": {
    "doc": "Binding adapters",
    "title": "Binding adapters",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/binding-adapters/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/binding-adapters/"
  },"70": {
    "doc": "Build Your First App",
    "title": "Build Your First App",
    "content": "Bu sayfa interaktif olduğu için direkt link üzerinden inceleyebilirsiniz. ",
    "url": "/docs/app-basics/build-your-first-app/",
    
    "relUrl": "/docs/app-basics/build-your-first-app/"
  },"71": {
    "doc": "Color state list",
    "title": "Color state list",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/color-state-list/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/color-state-list/"
  },"72": {
    "doc": "Common patterns",
    "title": "Common patterns",
    "content": " ",
    "url": "/docs/app-architecture/modularization/common-patterns/",
    
    "relUrl": "/docs/app-architecture/modularization/common-patterns/"
  },"73": {
    "doc": "Communicate with fragments",
    "title": "Communicate with fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/communicate-with-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/communicate-with-fragments/"
  },"74": {
    "doc": "Complex XML resources",
    "title": "Complex XML resources",
    "content": " ",
    "url": "/docs/app-basics/app-resources/complex-xml-resources/",
    
    "relUrl": "/docs/app-basics/app-resources/complex-xml-resources/"
  },"75": {
    "doc": "Conditional navigation",
    "title": "Conditional navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/conditional-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/conditional-navigation/"
  },"76": {
    "doc": "Core topics",
    "title": "Core topics",
    "content": " ",
    "url": "/docs/core-topics",
    
    "relUrl": "/docs/core-topics"
  },"77": {
    "doc": "Create a deep link for a destination",
    "title": "Create a deep link for a destination",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/create-a-deep-link-for-a-destination/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/create-a-deep-link-for-a-destination/"
  },"78": {
    "doc": "Create a fragment",
    "title": "Create a fragment",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/create-a-fragment/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/create-a-fragment/"
  },"79": {
    "doc": "Create app links for instant apps",
    "title": "Create app links for instant apps",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/create-app-links-for-instant-apps/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/create-app-links-for-instant-apps/"
  },"80": {
    "doc": "Create a destination",
    "title": "Create a destination",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/create-destination/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/create-destination/"
  },"81": {
    "doc": "Create shortcuts",
    "title": "Create shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/create-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/create-shortcuts/"
  },"82": {
    "doc": "Create swipe views with tabs using ViewPager",
    "title": "Create swipe views with tabs using ViewPager",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager/",
    
    "relUrl": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager/"
  },"83": {
    "doc": "Create swipe views with tabs using ViewPager2",
    "title": "Create swipe views with tabs using ViewPager2",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager2/",
    
    "relUrl": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager2/"
  },"84": {
    "doc": "Create ViewModels with dependencies",
    "title": "Create ViewModels with dependencies",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/create-viewmodels-with-dependencies/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/create-viewmodels-with-dependencies/"
  },"85": {
    "doc": "Custom back navigation",
    "title": "Custom back navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/custom-back-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/custom-back-navigation/"
  },"86": {
    "doc": "Dagger basics",
    "title": "Dagger basics",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/dagger-basics/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/dagger-basics/"
  },"87": {
    "doc": "Dagger",
    "title": "Dagger",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/dagger/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/dagger/"
  },"88": {
    "doc": "Data binding library",
    "title": "Data binding library",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/data-binding-library/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/data-binding-library/"
  },"89": {
    "doc": "Data layer libraries",
    "title": "Data layer libraries",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/data-layer-libraries/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/data-layer-libraries/"
  },"90": {
    "doc": "Data layer",
    "title": "Data layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/data-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/data-layer/"
  },"91": {
    "doc": "Datastore",
    "title": "Datastore",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/datastore/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/datastore/"
  },"92": {
    "doc": "Debug your fragments",
    "title": "Debug your fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/debug-your-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/debug-your-fragments/"
  },"93": {
    "doc": "Dependency Injection",
    "title": "Dependency Injection",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dependency-injection/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dependency-injection/"
  },"94": {
    "doc": "Dependency injection with Hilt",
    "title": "Dependency injection with Hilt",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dependency-injetion-with-hilt/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dependency-injetion-with-hilt/"
  },"95": {
    "doc": "Design for different form factors",
    "title": "Design for different form factors",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/design-for-different-form-factors/",
    
    "relUrl": "/docs/app-architecture/app-navigation/design-for-different-form-factors/"
  },"96": {
    "doc": "Design navigation graphs",
    "title": "Design navigation graphs",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/design-navigation-graphs/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/design-navigation-graphs/"
  },"97": {
    "doc": "Display paged lists",
    "title": "Display paged lists",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/display-paged-lists/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/display-paged-lists/"
  },"98": {
    "doc": "Displaying dialogs with DialogFragment",
    "title": "Displaying dialogs with DialogFragment",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/displaying-dialogs-with-dialogfragment/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/displaying-dialogs-with-dialogfragment/"
  },"99": {
    "doc": "Domain layer",
    "title": "Domain layer",
    "content": "Domain katmanı, UI katmanı ile data katmanı arasında yer alan isteğe bağlı bir katmandır. Domain katmanı, karmaşık business logic’in veya birden fazla ViewModel tarafından yeniden kullanılan basit business logic’in enkapsüle edilmesinden sorumludur. Bu katman isteğe bağlıdır çünkü tüm uygulamalar bu gereksinimlere sahip olmayacaktır. Yalnızca gerektiğinde kullanmalısınız - örneğin, karmaşıklığı handle etmek veya yeniden kullanılabilirliği kolaylaştırmak için. Domain katmanı aşağıdaki faydaları sağlar: . | Kod tekrarını önler. | Domain katmanı sınıflarını kullanan sınıflarda okunabilirliği artırır. | Uygulamanın test edilebilirliğini artırır. | Sorumlulukları bölmenize izin vererek büyük sınıfları önler. | . Bu sınıfları basit ve hafif tutmak için, her kullanım senaryosu yalnızca tek bir fonksiyonellik üzerinde sorumluluk sahibi olmalı ve mutable veri içermemelidir. Bunun yerine mutable verileri UI veya data katmanlarınızda ele almalısınız. Not: Bu sayfadaki öneriler ve best practiceler, ölçeklenmelerini sağlamak, kaliteyi ve sağlamlığı artırmak ve test edilmelerini kolaylaştırmak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Architecture: The Domain Layer - MAD Skills . Naming conventions in this guide . Bu kılavuzda, use case’ler sorumlu oldukları tek bir eylemden sonra adlandırılır. Kurallar aşağıdaki gibidir: . şimdiki zamanda fiil + isim/ne (isteğe bağlı) + UseCase. Örneğin: FormatDateUseCase, LogOutUserUseCase, GetLatestNewsWithAuthorsUseCase veya MakeLoginRequestUseCase. Dependencies . Tipik bir uygulama mimarisinde, use case sınıfları UI katmanındaki ViewModel’ler ile data katmanındaki repository’ler arasında yer alır. Bu, use case sınıflarının genellikle repository sınıflarına bağlı olduğu ve UI katmanı ile repository’lerin yaptığı gibi iletişim kurduğu anlamına gelir - ya callback’ler (Java için) ya da coroutine’ler (Kotlin için) kullanarak. Bu konuda daha fazla bilgi edinmek için data layer sayfasına bakın. Örneğin, uygulamanızda bir haber repository’sinden ve bir yazar repository’sinden veri alan ve bunları birleştiren bir use case sınıfınız olabilir: . class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository ) { /* ... */ } . Use case’ler yeniden kullanılabilir lojik içerdiğinden, diğer use case’ler tarafından da kullanılabilirler. Domain katmanında birden fazla use case seviyesi olması normaldir. Örneğin, aşağıdaki örnekte tanımlanan use case, UI katmanındaki birden fazla sınıfın ekranda uygun mesajı görüntülemek için saat dilimlerine güvenmesi durumunda FormatDateUseCase use case’ini kullanabilir: . class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository, private val formatDateUseCase: FormatDateUseCase ) { /* ... */ } . Example dependency graph for a use case that depends on other use cases . Call use cases in Kotlin . Kotlin’de, invoke() fonksiyonunu operatör modifier ile tanımlayarak use case sınıf instance’larını fonksiyon olarak çağrılabilir hale getirebilirsiniz. Aşağıdaki örneğe bakın: . class FormatDateUseCase(userRepository: UserRepository) { private val formatter = SimpleDateFormat( userRepository.getPreferredDateFormat(), userRepository.getPreferredLocale() ) operator fun invoke(date: Date): String { return formatter.format(date) } } . Bu örnekte, FormatDateUseCase’deki invoke() metodu, sınıfın instance’larını fonksiyonlarmış gibi çağırmanıza olanak tanır. invoke() metodu belirli bir imza ile sınırlandırılmamıştır; herhangi bir sayıda parametre alabilir ve herhangi bir tip döndürebilir. Ayrıca invoke() metodunu sınıfınızda farklı imzalarla overload edebilirsiniz. Yukarıdaki örnekteki use case’i aşağıdaki gibi çağırırsınız: . class MyViewModel(formatDateUseCase: FormatDateUseCase) : ViewModel() { init { val today = Calendar.getInstance() val todaysDate = formatDateUseCase(today) /* ... */ } } . invoke() operatörü hakkında daha fazla bilgi edinmek için Kotlin dokümanlarına bakın. Lifecycle . Use Case’lerin kendi yaşam döngüleri yoktur. Bunun yerine, onları kullanan sınıfa göre scopelandırılırlar. Bu, use case’leri UI katmanındaki sınıflardan, hizmetlerden veya Application sınıfının kendisinden çağırabileceğiniz anlamına gelir. Use case’ler mutable veriler içermemesi gerektiğinden, bir use case sınıfını bağımlılık olarak her ilettiğinizde bu sınıfın yeni bir instance’ını oluşturmanız gerekir. Threading . Domain katmanındaki Use Case’ler main-safe olmalıdır; başka bir deyişle, main thread’den çağrılmaları güvenli olmalıdır. Use case sınıfları uzun süren bloklama işlemleri gerçekleştiriyorsa, bu lojiği uygun iş parçacığına taşımaktan sorumludurlar. Ancak bunu yapmadan önce, bu engelleme işlemlerinin hiyerarşinin diğer katmanlarına yerleştirilmesinin daha iyi olup olmayacağını kontrol edin. Tipik olarak, karmaşık hesaplamalar yeniden kullanılabilirliği veya önbelleğe almayı teşvik etmek için data katmanında gerçekleşir. Örneğin, büyük bir liste üzerindeki yoğun kaynak gerektiren bir işlem, sonucun uygulamanın birden fazla ekranında yeniden kullanılabilmesi için önbelleğe alınması gerekiyorsa, domain katmanından ziyade data katmanına daha iyi yerleştirilir. Aşağıdaki örnekte, çalışmasını bir background thread üzerinde gerçekleştiren bir use case gösterilmektedir: . class MyUseCase( private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default ) { suspend operator fun invoke(...) = withContext(defaultDispatcher) { // Long-running blocking operations happen on a background thread. } } . Common Tasks . Bu bölümde, yaygın domain katmanı görevlerinin nasıl gerçekleştirileceği açıklanmaktadır. Reusable simple business logic UI katmanında bulunan tekrarlanabilir business logic’i bir use case sınıfında encapsulate etmelisiniz. Bu, logic’in kullanıldığı her yerde herhangi bir değişikliği gerçekleştirmeyi kolaylaştırır. Ayrıca lojiği izole bir şekilde test etmenize de olanak tanır. Daha önce açıklanan FormatDateUseCase örneğini düşünün. Tarih biçimlendirmeyle ilgili iş gereksinimleriniz gelecekte değişirse, kodu yalnızca tek bir merkezi yerde değiştirmeniz gerekir. Not: Bazı durumlarda, use case'lerde bulunabilecek lojik, bunun yerine Util sınıflarındaki statik metotların bir parçası olabilir. Ancak, Util sınıflarını bulmak genellikle zor olduğundan ve işlevlerini keşfetmek zor olduğundan, ikincisi önerilmez. Ayrıca, use case'ler temel sınıflarda thread ve error handling gibi ortak işlevleri paylaşabilir ve bu da ölçek olarak daha büyük ekiplere fayda sağlayabilir. Combine repositories . Bir haber uygulamasında, sırasıyla haber ve yazar veri işlemlerini gerçekleştiren NewsRepository ve AuthorsRepository sınıflarına sahip olabilirsiniz. NewsRepository’nin sunduğu Article sınıfı yalnızca yazarın adını içerir, ancak ekranda yazar hakkında daha fazla bilgi görüntülemek istersiniz. Yazar bilgileri AuthorsRepository’den elde edilebilir. Logic birden fazla repository içerdiğinden ve karmaşık hale gelebileceğinden, logic’i ViewModel’den soyutlamak ve daha okunabilir hale getirmek için bir GetLatestNewsWithAuthorsUseCase sınıfı oluşturursunuz. Bu aynı zamanda logic’in tek başına test edilmesini ve uygulamanın farklı bölümlerinde yeniden kullanılabilir olmasını kolaylaştırır. /** * This use case fetches the latest news and the associated author. */ class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository, private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default ) { suspend operator fun invoke(): List&lt;ArticleWithAuthor&gt; = withContext(defaultDispatcher) { val news = newsRepository.fetchLatestNews() val result: MutableList&lt;ArticleWithAuthor&gt; = mutableListOf() // This is not parallelized, the use case is linearly slow. for (article in news) { // The repository exposes suspend functions val author = authorsRepository.getAuthor(article.authorId) result.add(ArticleWithAuthor(article, author)) } result } } . Logic, haber listesindeki tüm öğeleri mapler; bu nedenle data katmanı main-safe olsa da, bu iş main thread’i bloke etmemelidir çünkü kaç öğeyi process edeceğini bilemezsiniz. Bu nedenle use case, varsayılan dispatcher’ı kullanarak işi bir background thread’e taşır. Not: Room kütüphanesi, bir veritabanındaki farklı entityler arasındaki ilişkileri sorgulamanızı sağlar. Veritabanı source of truth ise, tüm bu işi sizin için yapan bir query oluşturabilirsiniz. Bu durumda, bir use case yerine NewsWithAuthorsRepository gibi bir repository sınıfı oluşturmak daha iyidir. Other consumers . UI katmanının yanı sıra, domain katmanı servisler ve Application sınıfı gibi diğer sınıflar tarafından da yeniden kullanılabilir. Ayrıca, TV veya Wear gibi diğer platformlar mobil uygulama ile kod tabanını paylaşıyorsa, UI katmanları da domain katmanının yukarıda bahsedilen tüm avantajlarını elde etmek için use case’leri yeniden kullanabilir. Data layer access restriction . Domain katmanını implemente ederken göz önünde bulundurmanız gereken bir diğer husus da UI katmanından data katmanına doğrudan erişime izin vermeniz ya da her şeyi domain katmanı üzerinden yapmaya zorlamanız gerekip gerekmediğidir. Bu kısıtlamayı yapmanın bir avantajı, örneğin data katmanına her erişim isteğinde analitik loglama yapıyorsanız, UI’nizin domain katmanı logic’ini bypass etmesini engellemesidir. Bununla birlikte, potansiyel olarak önemli dezavantajı, sizi data katmanına basit fonksiyon çağrıları olsa bile use case’ler eklemeye zorlamasıdır, bu da çok az fayda için karmaşıklık yaratabilir. İyi bir yaklaşım, use case’leri yalnızca gerektiğinde eklemektir. UI katmanınızın verilere neredeyse yalnızca use case’ler aracılığıyla eriştiğini fark ederseniz, verilere yalnızca bu şekilde erişmek mantıklı olabilir. Nihayetinde data katmanına erişimi kısıtlama kararı, kod tabanınıza ve katı kuralları mı yoksa daha esnek bir yaklaşımı mı tercih ettiğinize bağlıdır. Testing Domain katmanını test ederken genel test kılavuzu geçerlidir. Diğer UI testleri için geliştiriciler genellikle sahte repository’ler kullanır ve domain katmanını test ederken de sahte repository’ler kullanmak iyi bir yöntemdir. Sample . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/domain-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/domain-layer/"
  },"100": {
    "doc": "Drawable",
    "title": "Drawable",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/drawable/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/drawable/"
  },"101": {
    "doc": "Enabling links to app content",
    "title": "Enabling links to app content",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/enabling-links-to-app-content/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/enabling-links-to-app-content/"
  },"102": {
    "doc": "Font",
    "title": "Font",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/font/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/font/"
  },"103": {
    "doc": "Fragment lifecycle",
    "title": "Fragment lifecycle",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragment-lifecycle/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragment-lifecycle/"
  },"104": {
    "doc": "Fragment manager",
    "title": "Fragment manager",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragment-manager/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragment-manager/"
  },"105": {
    "doc": "Fragment transactions",
    "title": "Fragment transactions",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragment-transactions/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragment-transactions/"
  },"106": {
    "doc": "Fragments",
    "title": "Fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragments/"
  },"107": {
    "doc": "Generated binding classes",
    "title": "Generated binding classes",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/generated-binding-classes/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/generated-binding-classes/"
  },"108": {
    "doc": "Get started",
    "title": "Get started",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/get-started/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/get-started/"
  },"109": {
    "doc": "Getting started",
    "title": "Getting started",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/getting-started/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/getting-started/"
  },"110": {
    "doc": "Getting started",
    "title": "Getting started",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/getting-started/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/getting-started/"
  },"111": {
    "doc": "Global actions",
    "title": "Global actions",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/global-actions/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/global-actions/"
  },"112": {
    "doc": "Google Play",
    "title": "Google Play",
    "content": " ",
    "url": "/docs/core-topics/google-play/google-play/",
    
    "relUrl": "/docs/core-topics/google-play/google-play/"
  },"113": {
    "doc": "Guide to app architecture",
    "title": "Guide to app architecture",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/guide-to-app-architecture/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/guide-to-app-architecture/"
  },"114": {
    "doc": "Handle configuration changes",
    "title": "Handle configuration changes",
    "content": " ",
    "url": "/docs/app-basics/app-resources/handle-configuration-changes/",
    
    "relUrl": "/docs/app-basics/app-resources/handle-configuration-changes/"
  },"115": {
    "doc": "Handle configuration changes",
    "title": "Handle configuration changes",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/handle-configuration-changes/",
    
    "relUrl": "/docs/app-architecture/app-navigation/handle-configuration-changes/"
  },"116": {
    "doc": "Lifecycle-aware components",
    "title": "Lifecycle-aware components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/handle-lifecycles/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/handle-lifecycles/"
  },"117": {
    "doc": "Hilt and Dagger annotations cheat sheet",
    "title": "Hilt and Dagger annotations cheat sheet",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/hilt-and-dagger-annotations-cheat-sheet/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/hilt-and-dagger-annotations-cheat-sheet/"
  },"118": {
    "doc": "Hilt in multi-module apps",
    "title": "Hilt in multi-module apps",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/hilt-in-multi-module-apps/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/hilt-in-multi-module-apps/"
  },"119": {
    "doc": "Hilt testing guide",
    "title": "Hilt testing guide",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/hilt-testing-guide/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/hilt-testing-guide/"
  },"120": {
    "doc": "How to guides",
    "title": "How to guides",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/how-to-guides/how-to-guides/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/how-to-guides/how-to-guides/"
  },"121": {
    "doc": "Ana Sayfa",
    "title": "Android Dokümantasyonu Türkçe Çeviri Projesi",
    "content": "Bu proje, Android dokümantasyonunun Türkçe çevirisini oluşturmak amacıyla başlatılmıştır. Android platformunun genişleyen ve gelişen yapısı nedeniyle, geliştiricilerin öğrenmek ve anlamak istedikleri konuları daha rahat anlayabilecekleri bir dilde sunmak amacıyla böyle bir proje hayata geçirilmiştir. Bu GitHub sayfası, proje ekibi tarafından çevirisi yapılmış olan Android dokümantasyonunun Türkçe sürümüne erişmenizi sağlamak için oluşturulmuştur. Ayrıca projeye katılmak ve çeviri sürecine katkıda bulunmak isteyen geliştiricilerin de buradan projeye dahil olabileceği bir ortam sunulmaktadır. Projenin ilerleyişi ve son durumu hakkında güncel bilgilere bu sayfa üzerinden erişebilirsiniz. Ayrıca projenin GitHub deposuna da erişim sağlayarak, kodlar üzerinde değişiklik yapabilir ve pull requestler ile projeye katkıda bulunabilirsiniz. Bu projede yer alarak, Android geliştirme topluluğuna katkıda bulunmuş olacak ve Türkçe dilinde daha geniş bir Android dokümantasyonu kütüphanesi oluşmasına destek vermiş olacaksınız. ",
    "url": "/#android-dok%C3%BCmantasyonu-t%C3%BCrk%C3%A7e-%C3%A7eviri-projesi",
    
    "relUrl": "/#android-dokümantasyonu-türkçe-çeviri-projesi"
  },"122": {
    "doc": "Ana Sayfa",
    "title": "Proje Ekibi",
    "content": "Mustafa UNLU . ",
    "url": "/#proje-ekibi",
    
    "relUrl": "/#proje-ekibi"
  },"123": {
    "doc": "Ana Sayfa",
    "title": "Ana Sayfa",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"124": {
    "doc": "Interact programmatically",
    "title": "Interact programmatically",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/interact-programmatically/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/interact-programmatically/"
  },"125": {
    "doc": "Introduction to activities",
    "title": "Introduction to activities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/introcution-to-activities/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/introcution-to-activities/"
  },"126": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "Uygulama mimarisi tasarımı(app architecture design), uygulamalarınızın sağlam, test edilebilir ve sürdürülebilir olmasını sağlamak için önemli bir husustur. Android, uygulamanızı best practicelere göre oluşturmanıza yardımcı olacak bir dizi library ve component sağlar. Building a scalable, modularized, testable app from scratch . | Guide to app architecture ile sağlam bir uygulamayı bir araya getirmenin temellerini öğrenin. | Uygulama navigasyonunda ince ayar yaparak kullanıcı deneyimini iyileştirin. | Dependency injection kılavuzlarıyla boilerplate kodlari azaltın ve kodunuzun bakımını kolaylaştırın. | . ",
    "url": "/docs/app-architecture/introduction/",
    
    "relUrl": "/docs/app-architecture/introduction/"
  },"127": {
    "doc": "Kotlin DSL",
    "title": "Kotlin DSL",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/kotlin-dsl/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/kotlin-dsl/"
  },"128": {
    "doc": "Language and locale resolution",
    "title": "Language and locale resolution",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/language-and-locale-resolution/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/language-and-locale-resolution/"
  },"129": {
    "doc": "Layout",
    "title": "Layout",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/layout/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/layout/"
  },"130": {
    "doc": "Layouts and binding expressions",
    "title": "Layouts and binding expressions",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/layouts-and-binding-expressions/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/layouts-and-binding-expressions/"
  },"131": {
    "doc": "Learning pathway",
    "title": "Learning Pathway",
    "content": "Learning Pathway icin tiklayiniz. ",
    "url": "/docs/app-architecture/guide-to-app-architecture/learning-pathway/#learning-pathway",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/learning-pathway/#learning-pathway"
  },"132": {
    "doc": "Learning pathway",
    "title": "Learning pathway",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/learning-pathway/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/learning-pathway/"
  },"133": {
    "doc": "Lifecycle-aware components",
    "title": "Lifecycle-aware components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/lifecycle-aware-components/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/lifecycle-aware-components/"
  },"134": {
    "doc": "LiveData",
    "title": "LiveData",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/livedata/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/livedata/"
  },"135": {
    "doc": "About paging",
    "title": "About paging",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/load-and-display-paged-data/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/load-and-display-paged-data/"
  },"136": {
    "doc": "Load page data",
    "title": "Load page data",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/load-page-data/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/load-page-data/"
  },"137": {
    "doc": "Loaders",
    "title": "Loaders",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/loaders/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/loaders/"
  },"138": {
    "doc": "Localization",
    "title": "Localization",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/localization/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/localization/"
  },"139": {
    "doc": "Localize your app",
    "title": "Localize your app",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/localize-your-app/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/localize-your-app/"
  },"140": {
    "doc": "Manage and present loading states",
    "title": "Manage and present loading states",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/manage-and-present-loading-states/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/manage-and-present-loading-states/"
  },"141": {
    "doc": "Manage shortcuts",
    "title": "Manage shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/manage-shortcuts/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/manage-shortcuts/"
  },"142": {
    "doc": "Manual dependency injection",
    "title": "Manual dependency injection",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/manual-dependency-injection/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/manual-dependency-injection/"
  },"143": {
    "doc": "Layout",
    "title": "Layout",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/menu/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/menu/"
  },"144": {
    "doc": "Migrate from Kotlin Synthetics to View Binding",
    "title": "Migrate from Kotlin Synthetics to View Binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/migrate-from-kotlin-synthetics-to-view-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/migrate-from-kotlin-synthetics-to-view-binding/"
  },"145": {
    "doc": "Migrate to Paging 3",
    "title": "Migrate to Paging 3",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/migrate-to-paging-3/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/migrate-to-paging-3/"
  },"146": {
    "doc": "Migrate to the Navigation component",
    "title": "Migrate to the Navigation component",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/migrate-to-the-nanvigation-component/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/migrate-to-the-nanvigation-component/"
  },"147": {
    "doc": "Migrating from Firebase JobDispatcher",
    "title": "Migrating from Firebase JobDispatcher",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-firebase-jobdispatcher/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-firebase-jobdispatcher/"
  },"148": {
    "doc": "Migrating from GCMNetworkManager",
    "title": "Migrating from GCMNetworkManager",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-gcmnetworkmanager/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-gcmnetworkmanager/"
  },"149": {
    "doc": "Modularization",
    "title": "Modularization",
    "content": " ",
    "url": "/docs/app-architecture/modularization/modularization/",
    
    "relUrl": "/docs/app-architecture/modularization/modularization/"
  },"150": {
    "doc": "More types",
    "title": "More types",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/more-types/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/more-types/"
  },"151": {
    "doc": "Navigate to a destination",
    "title": "Navigate to a destination",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/navigate-to-a-destination/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/navigate-to-a-destination/"
  },"152": {
    "doc": "Navigate with feature modules",
    "title": "Navigate with feature modules",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/navigate-with-feature-modules/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/navigate-with-feature-modules/"
  },"153": {
    "doc": "Navigation component",
    "title": "Navigation component",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/navigation-component/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/navigation-component/"
  },"154": {
    "doc": "Navigation",
    "title": "Navigation",
    "content": " ",
    "url": "/docs/app-architecture/modularization/navigation/",
    
    "relUrl": "/docs/app-architecture/modularization/navigation/"
  },"155": {
    "doc": "Nested graphs",
    "title": "Nested graphs",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/nested-graphs/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/nested-graphs/"
  },"156": {
    "doc": "Offline first",
    "title": "Offline first",
    "content": "Çevrimdışı öncelikli(offline-first) bir uygulama, temel işlevselliğinin tamamını veya kritik bir alt kümesini internet erişimi olmadan gerçekleştirebilen bir uygulamadır. Yani, iş mantığının bir kısmını veya tamamını çevrimdışı olarak gerçekleştirebilir. Çevrimdışı öncelikli bir uygulama oluşturmaya yönelik hususlar, uygulama verilerine ve business logic’e erişim sunan data katmanında başlar. Uygulamanın bu verileri zaman zaman cihaz dışındaki kaynaklardan yenilemesi gerekebilir. Bunu yaparken, güncel kalmak için ağ kaynaklarını kullanması gerekebilir. Ağ kullanılabilirliği her zaman garanti edilmez. Cihazlarda genellikle ağ bağlantısının zayıf veya yavaş olduğu dönemler olabilir. Kullanıcılar aşağıdakilerle karşılaşabilir: . | Sınırlı internet bant genişliği | Asansör veya tünelde olduğu gibi geçici bağlantı kesintileri. | Ara sıra veri erişimi. Örneğin, yalnızca WiFi kullanan tabletler. | . Nedeni ne olursa olsun, bir uygulamanın bu koşullarda yeterli şekilde çalışması genellikle mümkündür. Uygulamanızın çevrimdışı olarak doğru şekilde çalıştığından emin olmak için aşağıdakileri yapabilmelidir: . | Güvenilir bir ağ bağlantısı olmadan kullanılabilirliğini sürdürme. | İlk ağ çağrısının tamamlanmasını veya başarısız olmasını beklemek yerine kullanıcılara yerel verileri hemen sunun. | Pil ve veri durumunun bilincinde olacak şekilde veri alın. Örneğin, yalnızca şarj olurken veya WiFi’da olduğu gibi en uygun koşullarda veri getirme talebinde bulunarak. Yukarıdaki kriterleri karşılayabilen bir uygulama genellikle çevrimdışı öncelikli uygulama(offline-first app) olarak adlandırılır. | . Create offline-first apps . Design an offline-first app . Çevrimdışı öncelikli bir uygulama tasarlarken data katmanından ve uygulama verileri üzerinde gerçekleştirebileceğiniz iki ana işlemden başlamalısınız: . | Reads: Kullanıcıya bilgi göstermek gibi uygulamanın diğer bölümleri tarafından kullanılmak üzere veri çekme. | Writes: User input’u daha sonra kullanmak üzere kalıcı hale getirme. | . Veri katmanındaki repository‘ler, uygulama verilerini sağlamak için veri kaynaklarını birleştirmekten sorumludur. Çevrimdışı öncelikli bir uygulamada, en kritik görevlerini gerçekleştirmek için ağ erişimine ihtiyaç duymayan en az bir veri kaynağı olmalıdır. Bu kritik görevlerden biri de veri okumaktır. Not: En azından, çevrimdışı öncelikli bir uygulama ağ erişimi olmadan okuma yapabilmelidir. Model data in an offline-first app . Çevrimdışı öncelikli bir uygulama, ağ kaynaklarını kullanan her repository için en az 2 veri kaynağına sahiptir: . | Local veri kaynağı | Network veri kaynağı | . Not: Çevrimdışı öncelikli bir uygulamada ağ erişimi olan bir repository her zaman lokal bir veri kaynağına sahip olmalıdır. The local data source . Lokal veri kaynağı, uygulama için standart haline gelmiş source of truth‘tır. Uygulamanın daha yüksek katmanlarının okuduğu tüm verilerin özel kaynağı olmalıdır. Bu, bağlantı durumları arasında veri tutarlılığı sağlar. Lokal veri kaynağı genellikle diske kalıcı olarak aktarılan bir depolama alanı tarafından desteklenir. Verileri diske kalıcı hale getirmenin bazı yaygın yolları şunlardır: . | Room gibi ilişkisel veritabanları gibi yapılandırılmış veri kaynakları. | Yapılandırılmamış veri kaynakları. Örneğin, Datastore ile protocol buffers. | Basit dosyalar | . The network data source . Network veri kaynağı uygulamanın gerçek state’idir. Lokal veri kaynağı en iyi ihtimalle network veri kaynağı ile senkronize edilir. Bunun gerisinde de kalabilir, bu durumda uygulamanın tekrar çevrimiçi olduğunda güncellenmesi gerekir. Tersine, network veri kaynağı, bağlantı geri geldiğinde uygulama onu güncelleyene kadar lokal veri kaynağının gerisinde kalabilir. Uygulamanın domain ve UI katmanları asla network katmanı ile doğrudan bağlantı kurmamalıdır. Onunla iletişim kurmak ve lokal veri kaynağını güncellemek için onu kullanmak hosting repository’nin sorumluluğundadır. Exposing resources . Lokal ve network veri kaynakları, uygulamanızın bunları nasıl okuyabileceği ve yazabileceği konusunda temel farklılıklar gösterebilir. Lokal bir veri kaynağını sorgulamak, SQL sorguları kullanmak gibi hızlı ve esnek olabilir. Buna karşılık, network veri kaynakları yavaş ve kısıtlı olabilir, örneğin RESTful kaynaklarına id ile artımlı olarak erişirken olduğu gibi. Sonuç olarak, her veri kaynağı genellikle sağladığı verilerin kendi temsiline ihtiyaç duyar. Bu nedenle lokal veri kaynağı ve network veri kaynağı kendi modellerine sahip olabilir. Aşağıdaki dizin yapısı bu kavramı görselleştirmektedir. AuthorEntity, uygulamanın lokal veritabanından okunan bir yazarın temsilidir ve NetworkAuthor, network üzerinden serileştirilen bir yazarın temsilidir: . data/ ├─ local/ │ ├─ entities/ │ │ ├─ AuthorEntity │ ├─ dao/ │ ├─ NiADatabase ├─ network/ │ ├─ NiANetwork │ ├─ models/ │ │ ├─ NetworkAuthor ├─ model/ │ ├─ Author ├─ repository/ . AuthorEntity ve NetworkAuthor’un ayrıntıları aşağıdaki gibidir: . /** * Network representation of [Author] */ @Serializable data class NetworkAuthor( val id: String, val name: String, val imageUrl: String, val twitter: String, val mediumPage: String, val bio: String, ) /** * Defines an author for either an [EpisodeEntity] or [NewsResourceEntity]. * It has a many-to-many relationship with both entities */ @Entity(tableName = \"authors\") data class AuthorEntity( @PrimaryKey val id: String, val name: String, @ColumnInfo(name = \"image_url\") val imageUrl: String, @ColumnInfo(defaultValue = \"\") val twitter: String, @ColumnInfo(name = \"medium_page\", defaultValue = \"\") val mediumPage: String, @ColumnInfo(defaultValue = \"\") val bio: String, ) . Hem AuthorEntity hem de NetworkAuthor’u veri katmanının içinde tutmak ve harici katmanların kullanması için üçüncü bir türü ortaya çıkarmak iyi bir pratiktir. Bu, harici katmanları, uygulamanın davranışını temelden değiştirmeyen lokal ve network veri kaynaklarındaki küçük değişikliklerden korur. Bu, aşağıdaki snippet’te gösterilmiştir: . /** * External data layer representation of a \"Now in Android\" Author */ data class Author( val id: String, val name: String, val imageUrl: String, val twitter: String, val mediumPage: String, val bio: String, ) . Network modeli daha sonra bunu lokal modele dönüştürmek için bir extension metodu tanımlayabilir ve lokal model de benzer şekilde aşağıda gösterildiği gibi bunu harici temsile dönüştürmek için bir metoda sahiptir: . /** * Converts the network model to the local model for persisting * by the local data source */ fun NetworkAuthor.asEntity() = AuthorEntity( id = id, name = name, imageUrl = imageUrl, twitter = twitter, mediumPage = mediumPage, bio = bio, ) /** * Converts the local model to the external model for use * by layers external to the data layer */ fun AuthorEntity.asExternalModel() = Author( id = id, name = name, imageUrl = imageUrl, twitter = twitter, mediumPage = mediumPage, bio = bio, ) . Not: Yukarıdaki gibi mapper’lar genellikle farklı modüllerde tanımlanan modeller arasında eşleme yapar. Sonuç olarak, tightly coupled modüllerden kaçınmak için bu mapperlari kullanıldıkları modüllerde tanımlamak genellikle faydalıdır. Daha fazla ayrıntı için modularization kılavuzuna bakın. Reads . Okumalar, çevrimdışı öncelikli bir uygulamada uygulama verileri üzerindeki temel işlemdir. Bu nedenle, uygulamanızın verileri okuyabildiğinden ve yeni veriler mevcut olur olmaz uygulamanın bunları görüntüleyebildiğinden emin olmalısınız. Bunu yapabilen bir uygulama reaktif bir uygulamadır çünkü okuma API’lerini observable tiplerle sunarlar. Aşağıdaki kod parçasında, OfflineFirstTopicRepository tüm okuma API’leri için Flow döndürür. Bu, network veri kaynağından güncellemeler aldığında okuyucularını güncellemesini sağlar. Başka bir deyişle, OfflineFirstTopicRepository’nin lokal veri kaynağı invalid edildiğinde değişiklikleri iletmesine olanak tanır. Bu nedenle, OfflineFirstTopicRepository’nin her okuyucusu, uygulamaya network bağlantısı yeniden sağlandığında tetiklenebilecek veri değişikliklerini ele almaya hazır olmalıdır. Ayrıca, OfflineFirstTopicRepository verileri doğrudan lokal veri kaynağından okur. Veri değişikliklerini okuyucularına ancak önce lokal veri kaynağını güncelleyerek bildirebilir. class OfflineFirstTopicsRepository( private val topicDao: TopicDao, private val network: NiaNetworkDataSource, ) : TopicsRepository { override fun getTopicsStream(): Flow&lt;List&lt;Topic&gt;&gt; = topicDao.getTopicEntitiesStream() .map { it.map(TopicEntity::asExternalModel) } } . Not: Çevrimdışı öncelikli bir uygulamada repository’lerden okuma işlemleri doğrudan lokal veri kaynağından okunmalıdır. Herhangi bir güncelleme önce lokal veri kaynağına yazılmalıdır ve lokal veri kaynağı observable olduğu için tüketicilerini güncelleyecektir. Error handling strategies . Çevrimdışı öncelikli uygulamalarda hataları ele almanın, oluşabilecekleri veri kaynaklarına bağlı olarak benzersiz yolları vardır. Aşağıdaki alt bölümlerde bu stratejiler özetlenmektedir. | Local data source Lokal veri kaynağından okuma sırasında oluşan hatalar nadir olmalıdır. Okuyucuları hatalardan korumak için, okuyucunun veri topladığı Flow’larda catch operatörünü kullanın. | . Bir ViewModel’de catch operatörünün kullanımı aşağıdaki gibidir: . class AuthorViewModel( authorsRepository: AuthorsRepository, ... ) : ViewModel() { private val authorId: String = ... // Observe author information private val authorStream: Flow&lt;Author&gt; = authorsRepository.getAuthorStream( id = authorId ) .catch { emit(Author.empty()) } } . Not: catch operatörü yalnızca exception’ın uygulamayı çökertmesini engeller, backing Flow yine de sonlanır. Exception’dan sonra flow’tan collecting’e devam etmek için retry metodunu kullanın. | Network data source Bir network veri kaynağından veri okunurken hata oluşursa, uygulamanın veri getirmeyi yeniden denemek için bir heuristic yöntem kullanması gerekecektir. Yaygın heuristic yöntemler şunlardır: . | Exponential backoff . Exponential backoff‘ta uygulama, başarılı olana veya diğer koşullar durması gerektiğini belirleyene kadar artan zaman aralıklarıyla network veri kaynağından okumayı denemeye devam eder. Uygulamanın backing off yapmaya devam edip etmeyeceğini değerlendirmek için kriterler şunlardır: . | Network veri kaynağının belirttiği hata türü. Örneğin, bağlantı eksikliğini gösteren bir hata döndüren network çağrılarını yeniden denemelisiniz. Tersine, uygun kimlik bilgileri mevcut olana kadar yetkilendirilmemiş HTTP isteklerini yeniden denememelisiniz. | İzin verilen maksimum yeniden deneme sayısı. | . | Network connectivity monitoring Bu yaklaşımda, uygulama network veri kaynağına bağlanabileceğinden emin olana kadar okuma istekleri kuyruğa alınır. Bağlantı kurulduktan sonra okuma isteği kuyruktan çıkarılır, veri okunur ve lokal veri kaynağı güncellenir. Android’de bu kuyruk bir Room veritabanı ile tutulabilir ve WorkManager kullanılarak kalıcı iş olarak tüketilebilir. | . | . Writes . Çevrimdışı öncelikli bir uygulamada veri okumak için önerilen yol observable tipleri kullanmak olsa da, yazma API’leri için eşdeğer olan suspend fonksiyonları gibi asenkron API’lerdir. Bu, UI thread’inin engellenmesini önler ve çevrimdışı öncelikli uygulamalardaki yazma işlemleri bir network sınırını geçerken başarısız olabileceğinden hata ele almaya yardımcı olur. interface UserDataRepository { /** * Updates the bookmarked status for a news resource */ suspend fun updateNewsResourceBookmark(newsResourceId: String, bookmarked: Boolean) } . Yukarıdaki kod parçasında, yukarıdaki metot askıya aldığı için tercih edilen asenkron API Coroutines‘tir. Write strategies . Çevrimdışı öncelikli uygulamalarda veri yazarken göz önünde bulundurulması gereken üç strateji vardır. Hangisini seçeceğiniz, yazılmakta olan veri türüne ve uygulamanın gereksinimlerine bağlıdır: . | Online-only writes . Verileri network sınırı boyunca yazmayı deneyin. Başarılı olursa, lokal veri kaynağını günceller, aksi takdirde bir exception atar ve uygun şekilde yanıt vermeyi çağırana bırakır. Bu strateji genellikle neredeyse gerçek zamanlı olarak çevrimiçi gerçekleşmesi gereken yazma işlemleri için kullanılır. Örneğin, bir banka transferi. Yazma işlemleri başarısız olabileceğinden, genellikle kullanıcıya yazmanın başarısız olduğunu bildirmek veya kullanıcının ilk etapta veri yazmaya çalışmasını önlemek gerekir. Bu senaryolarda kullanabileceğiniz bazı stratejiler şunları içerebilir: . | Bir uygulama veri yazmak için internet erişimi gerektiriyorsa, kullanıcıya veri yazmasına izin veren bir UI sunmamayı veya en azından bunu devre dışı bırakmayı tercih edebilir. | Kullanıcının çevrimdışı olduğunu bildirmek için kullanıcının reddedemeyeceği bir açılır mesaj veya geçici bir mesaj kullanabilirsiniz. | . | Queued writes . Yazmak istediğiniz bir nesne olduğunda, bunu bir kuyruğa ekleyin. Uygulama tekrar çevrimiçi olduğunda exponential back off ile kuyruğu tüketmeye devam edin. Android’de çevrimdışı bir kuyruğu tüketmek, genellikle WorkManager’a devredilen kalıcı bir iştir. Bu yaklaşım aşağıdaki durumlarda iyi bir seçimdir: . | Verilerin ağa yazılması zorunlu değildir. | İşlem zamana duyarlı değildir. | İşlemin başarısız olması durumunda kullanıcının bilgilendirilmesi gerekli değildir. | . Bu yaklaşımın kullanım alanları arasında analytics eventlar ve loglama yer alır. | Lazy writes . Önce lokal veri kaynağına yazın, ardından en uygun zamanda network’e bildirmek için yazma işlemini kuyruğa alın. Uygulama tekrar çevrimiçi olduğunda network ve lokal veri kaynakları arasında çakışmalar olabileceğinden bu önemsiz bir işlem değildir. Çakışma çözümü ile ilgili bir sonraki bölümde daha fazla ayrıntı verilmektedir. Bu yaklaşım, veriler uygulama için kritik olduğunda doğru seçimdir. Örneğin, çevrimdışı öncelikli bir yapılacaklar listesi uygulamasında, veri kaybı riskini önlemek için kullanıcının çevrimdışı olarak eklediği tüm görevlerin lokal olarak saklanması çok önemlidir. Not: Çevrimdışı öncelikli uygulamalarda veri yazmak, olası çakışmalar nedeniyle genellikle veri okumaktan daha fazla dikkat gerektirir. Çevrimdışı öncelikli uygulamaların çevrimdışı öncelikli olarak kabul edilmesi için çevrimdışıyken veri yazabilmesi gerekmez. | . Synchronization and conflict resolution . Çevrimdışı öncelikli bir uygulama bağlantısını geri yüklediğinde, lokal veri kaynağındaki verileri network veri kaynağındaki verilerle bağdaştırması gerekir. Bu işleme senkronizasyon denir. Bir uygulamanın network veri kaynağıyla senkronize olmasının iki ana yolu vardır: 1-Pull-based synchronization, 2-Push-based synchronization . | Pull-based synchronization | . Pull-based senkronizasyonda uygulama, talep üzerine en son uygulama verilerini okumak için network’e ulaşır. Bu yaklaşım için yaygın bir heuristic yontem, uygulamanın verileri yalnızca kullanıcıya sunmadan hemen önce aldığı navigation-based’dir. Bu yaklaşım, uygulamanın network bağlantısının olmadığı kısa veya ara dönemler beklediği durumlarda en iyi sonucu verir. Bunun nedeni, veri yenilemenin fırsatçı olması ve uzun süreli bağlantısızlık durumlarında kullanıcının eskimiş ya da boş bir önbellekle uygulama hedeflerini ziyaret etmeye çalışması olasılığının artmasıdır. Belirli bir ekran için sonsuz kaydırma listesindeki öğeleri getirmek üzere sayfa token’larının kullanıldığı bir uygulama düşünün. Uygulama lazy bir şekilde networke ulaşabilir, verileri lokal veri kaynağında kalıcı hale getirebilir ve daha sonra bilgileri kullanıcıya geri sunmak için lokal veri kaynağından okuyabilir. Network bağlantısının olmadığı durumlarda, repository sadece lokal veri kaynağından veri talep edebilir. Bu, Jetpack Paging Library tarafından RemoteMediator API‘si ile kullanılan modeldir. class FeedRepository(...) { fun feedPagingSource(): PagingSource&lt;FeedItem&gt; { ... } } class FeedViewModel( private val repository: FeedRepository ) : ViewModel() { private val pager = Pager( config = PagingConfig( pageSize = NETWORK_PAGE_SIZE, enablePlaceholders = false ), remoteMediator = FeedRemoteMediator(...), pagingSourceFactory = feedRepository::feedPagingSource ) val feedPagingData = pager.flow } . Pull Based senkronizasyonun avantaj ve dezavantajları aşağıdaki tabloda özetlenmiştir: . | Avantaj | Dezavantaj | . | Uygulaması nispeten kolay. | Yoğun veri kullanımına yatkındır. Bunun nedeni, bir navigasyon hedefine tekrarlanan ziyaretlerin, değişmeyen bilgilerin gereksiz yere yeniden alınmasını tetiklemesidir. Bunu uygun önbellekleme ile azaltabilirsiniz. Bu, cachedIn operatörü ile UI katmanında veya bir HTTP önbelleği ile network katmanında yapılabilir. | . | İhtiyaç duyulmayan veriler asla getirilmeyecektir | Çekilen modelin kendi kendine yeterli olması gerektiğinden ilişkisel verilerle iyi ölçeklenmez. Senkronize edilen model, kendisini doldurmak için getirilecek diğer modellere bağlıysa, daha önce bahsedilen yoğun veri kullanımı sorunu daha da önemli hale gelecektir. Ayrıca, üst modelin repository’leri ile iç içe geçmiş modelin repository’leri arasında bağımlılıklara neden olabilir. | . | Push-based synchronization | . Push based senkronizasyonda, lokal veri kaynağı network veri kaynağının bir replika setini elinden geldiğince taklit etmeye çalışır. Bir baseline belirlemek için ilk başlangıçta proaktif olarak uygun miktarda veri çeker, daha sonra bu veriler eskidiğinde kendisini uyarması için sunucudan gelen bildirimlere güvenir. Eskimiş bildiriminin alınmasının ardından uygulama, yalnızca eskimiş olarak işaretlenen verileri güncellemek için network’e ulaşır. Bu iş, network veri kaynağına ulaşan ve lokal veri kaynağına getirilen verileri kalıcı hale getiren Repository’ye devredilir. Repository verilerini gözlemlenebilir tiplerle sunduğundan, okuyucular herhangi bir değişiklikten haberdar edilecektir. class UserDataRepository(...) { suspend fun synchronize() { val userData = networkDataSource.fetchUserData() localDataSource.saveUserData(userData) } } . Bu yaklaşımda, uygulama network veri kaynağına çok daha az bağımlıdır ve uzun süreler boyunca onsuz çalışabilir. Çevrimdışıyken hem okuma hem de yazma erişimi sunar çünkü lokal olarak network veri kaynağından en son bilgilere sahip olduğu varsayılır. Push based senkronizasyonun avantajları ve dezavantajları aşağıdaki tabloda özetlenmiştir: . | Avantaj | Dezavantaj | . | Uygulama süresiz olarak çevrimdışı kalabilir. | Çakışma çözümü için verilerin versiyonlanması önemsizdir. | . | Minimum veri kullanımı. Uygulama yalnızca değişen verileri alır. | Senkronizasyon sırasında yazma endişelerini dikkate almanız gerekir. | . | İlişkisel veriler için iyi çalışır. Her repository yalnızca desteklediği model için veri getirmekten sorumludur. | Network veri kaynağının senkronizasyonu desteklemesi gerekir. | . | Hybrid synchronization | . Bazı uygulamalar, verilere bağlı olarak pull veya push based olan hibrit bir yaklaşım kullanır. Örneğin, bir sosyal medya uygulaması, akış güncellemelerinin yüksek sıklığı nedeniyle kullanıcının takip akışını talep üzerine almak için pull based senkronizasyon kullanabilir. Aynı uygulama, kullanıcı adı, profil resmi vb. dahil olmak üzere oturum açan kullanıcı hakkındaki veriler için push based senkronizasyonu kullanmayı tercih edebilir. Sonuç olarak, çevrimdışı öncelikli senkronizasyon seçimi ürün gereksinimlerine ve mevcut teknik altyapıya bağlıdır. Not: Uygulamanızın senkronizasyon yöntemi, uygulamanızın ihtiyaçlarına ve lokal ve network veri kaynaklarını destekleyen altyapının kısıtlamalarına bağlıdır. Conflict resolution . Uygulama çevrimdışıyken lokal olarak network veri kaynağıyla uyumsuz veri yazıyorsa, senkronizasyon gerçekleşmeden önce çözmeniz gereken bir çakışma meydana gelmiştir. Çakışma çözümü genellikle versiyonlama gerektirir. Uygulamanın, değişikliklerin ne zaman gerçekleştiğini takip etmek için bazı kayıt tutma işlemleri yapması gerekecektir. Bu, meta verileri network veri kaynağına aktarmasını sağlar. Network veri kaynağı daha sonra source of truth sağlama sorumluluğuna sahiptir. Uygulamanın ihtiyaçlarına bağlı olarak çakışma çözümü için dikkate alınması gereken çok çeşitli stratejiler vardır. Mobil uygulamalar için yaygın bir yaklaşım “son yazan kazanır(last write wins) “dır. | Last write wins | . Bu yaklaşımda, cihazlar network’e yazdıkları verilere zaman damgası metadatası eklerler. Network veri kaynağı bunları aldığında, mevcut state’inden daha yeni olanları kabul ederken mevcut state’inden daha eski olan verileri reddeder. Yukarıdaki şekilde, her iki cihaz da çevrimdışıdır ve başlangıçta network veri kaynağı ile senkronizedir. Çevrimdışıyken, her ikisi de lokal olarak veri yazar ve verilerini yazdıkları zamanı takip ederler. Her ikisi de tekrar çevrimiçi olduğunda ve network veri kaynağı ile senkronize edildiğinde, network, B cihazının verilerini daha sonra yazdığı için bu cihazın verilerini kalıcı hale getirerek çakışmayı çözer. WorkManager in offline-first apps . Yukarıda ele alınan okuma ve yazma stratejilerinin her ikisinde de iki ortak araç vardı: . | Queues . | Reads: Network bağlantısı mevcut olana kadar okumaları ertelemek için kullanılır. | Writes: Network bağlantısı mevcut olana kadar yazmaları ertelemek ve yeniden denemeler için yazmaları yeniden istemek için kullanılır. | . | Network connectivity monitors . | Reads: Uygulama bağlandığında okuma kuyruğunu boşaltmak ve senkronizasyon için bir sinyal olarak kullanılır | Writes: Uygulama bağlandığında yazma kuyruğunu boşaltmak ve senkronizasyon için bir sinyal olarak kullanılır | . | . Her iki durum da WorkManager’ın üstün olduğu persistent work örnekleridir. Örneğin Now in Android örnek uygulamasında, WorkManager lokal veri kaynağını senkronize ederken hem okuma kuyruğu hem de ağ monitörü olarak kullanılır. Başlangıçta, uygulama aşağıdaki eylemleri gerçekleştirir: . | Lokal veri kaynağı ile network veri kaynağı arasında eşitlik olduğundan emin olmak için okuma senkronizasyon işini kuyruga alın. | Okuma senkronizasyon kuyruğunu boşaltın ve uygulama çevrimiçi olduğunda senkronize etmeye başlayın. | Network veri kaynağından exponential backoff kullanarak bir okuma gerçekleştirin. | Okuma sonuçlarını, oluşabilecek çakışmaları çözerek yerel veri kaynağına aktarın. | Lokal veri kaynağındaki verileri uygulamanın diğer katmanlarının kullanması için sunun. | Yukarıda anlatılanlar aşağıdaki şemada gösterilmiştir: | . WorkManager ile senkronizasyon işinin kuyruğa alınması, KEEP ExistingWorkPolicy ile benzersiz iş olarak belirtilerek takip edilir: . class SyncInitializer : Initializer&lt;Sync&gt; { override fun create(context: Context): Sync { WorkManager.getInstance(context).apply { // Queue sync on app startup and ensure only one // sync worker runs at any time enqueueUniqueWork( SyncWorkName, ExistingWorkPolicy.KEEP, SyncWorker.startUpSyncWork() ) } return Sync } } . Not: “Now in Android “deki okuma kuyruğu sadece enqueueUniqueWork API’si ile temsil edilebilecek kadar basittir. Kuyruğun boşaltılma sırası hakkında daha sıkı garantiler için, Room veya Datastore gibi bir veri kalıcılığı API’si ile daha sağlam bir kuyruk uygulamasının gerçekleştirilmesi gerekecektir. Daha sonra bu kuyruğu sırayla boşaltmak için bir Worker ayarlanabilir. Burada SyncWorker.startupSyncWork() aşağıdaki gibi tanımlanır: . /** Create a WorkRequest to call the SyncWorker using a DelegatingWorker. This allows for dependency injection into the SyncWorker in a different module than the app module without having to create a custom WorkManager configuration. */ fun startUpSyncWork() = OneTimeWorkRequestBuilder&lt;DelegatingWorker&gt;() // Run sync as expedited work if the app is able to. // If not, it runs as regular work.setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST) .setConstraints(SyncConstraints) // Delegate to the SyncWorker.setInputData(SyncWorker::class.delegatedData()) .build() val SyncConstraints get() = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() . Özellikle, SyncConstraints tarafından tanımlanan Kısıtlamalar(Constraints) NetworkType‘ın NetworkType.CONNECTED olmasını gerektirir. Yani, çalışmadan önce network kullanılabilir olana kadar bekler. Network kullanılabilir olduğunda, Worker uygun Repository instance’larına temsilci atayarak SyncWorkName tarafından belirtilen benzersiz iş kuyruğunu boşaltır. Senkronizasyon başarısız olursa doWork() metodu Result.retry() ile döner. WorkManager, exponential backoff ile senkronizasyonu otomatik olarak yeniden deneyecektir. Aksi takdirde, senkronizasyonu tamamlayarak Result.success() döndürür. class SyncWorker(...) : CoroutineWorker(appContext, workerParams), Synchronizer { override suspend fun doWork(): Result = withContext(ioDispatcher) { // First sync the repositories in parallel val syncedSuccessfully = awaitAll( async { topicRepository.sync() }, async { authorsRepository.sync() }, async { newsRepository.sync() }, ).all { it } if (syncedSuccessfully) Result.success() else Result.retry() } } . Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/offline-first/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/offline-first/"
  },"157": {
    "doc": "Page from network and database",
    "title": "Page from network and database",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/page-from-network-and-database/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/page-from-network-and-database/"
  },"158": {
    "doc": "Paging 2",
    "title": "Paging 2",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/paging-2/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/paging-2/"
  },"159": {
    "doc": "Paging library",
    "title": "Paging library",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-library/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-library/"
  },"160": {
    "doc": "Parcelables and bundles",
    "title": "Parcelables and bundles",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/parcelables-and-bundles/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/parcelables-and-bundles/"
  },"161": {
    "doc": "Pass data between destinations",
    "title": "Pass data between destinations",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/pass-data-between-destinations/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/pass-data-between-destinations/"
  },"162": {
    "doc": "Per-app language preferences",
    "title": "Per-app language preferences",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/perapp-language-preferences/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/perapp-language-preferences/"
  },"163": {
    "doc": "Play Feature Delivery",
    "title": "Play Feature Delivery",
    "content": " ",
    "url": "/docs/core-topics/google-play/play-feature-delivery/play-feature-delivery/",
    
    "relUrl": "/docs/core-topics/google-play/play-feature-delivery/play-feature-delivery/"
  },"164": {
    "doc": "Predictive back gesture",
    "title": "Predictive back gesture",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/predictive-back-gesture/",
    
    "relUrl": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/predictive-back-gesture/"
  },"165": {
    "doc": "Principles of navigation",
    "title": "Principles of navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/principles-of-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/principles-of-navigation/"
  },"166": {
    "doc": "Processes and app lifecycle",
    "title": "Processes and app lifecycle",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/processes-and-app-lifecycle/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/processes-and-app-lifecycle/"
  },"167": {
    "doc": "Recents screen",
    "title": "Recents screen",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/recents-screen/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/recents-screen/"
  },"168": {
    "doc": "Recipes",
    "title": "Recipes",
    "content": " ",
    "url": "/docs/app-architecture/modularization/recipes/",
    
    "relUrl": "/docs/app-architecture/modularization/recipes/"
  },"169": {
    "doc": "Resource types",
    "title": "Resource types",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/resource-types/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/resource-types/"
  },"170": {
    "doc": "Restrictions on starting activities from the background",
    "title": "Restrictions on starting activities from the background",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/restrictions-on-starting-activities-from-the-background/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/restrictions-on-starting-activities-from-the-background/"
  },"171": {
    "doc": "Save UI states",
    "title": "Save UI states",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/save-ui-states/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/save-ui-states/"
  },"172": {
    "doc": "Saved state module for ViewModel",
    "title": "Saved state module for ViewModel",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/saved-state-module-for-viewmodel/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/saved-state-module-for-viewmodel/"
  },"173": {
    "doc": "Saving state with fragments",
    "title": "Saving state with fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/saving-state-with-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/saving-state-with-fragments/"
  },"174": {
    "doc": "State holders and UI state",
    "title": "State holders and UI state",
    "content": "UI layer kılavuzu, UI katmanı için UI State oluşturma ve yönetme aracı olarak tek yönlü veri akışını (UDF) tartışır. Ayrıca, UDF yönetimini state holder adı verilen özel bir sınıfa devretmenin faydalarını da vurgular. Bir state holderi ViewModel veya düz bir sınıf aracılığıyla uygulayabilirsiniz. Bu dokümantasyon, state holderleri ve UI katmanında oynadıkları role daha yakından bakıyor. Bu belgenin sonunda, UI katmanında application state’inin nasıl yönetileceğini anlamalısınız; bu, UI state production pipelinedir. Aşağıdakileri anlayabilmeli ve bilmelisiniz: . | UI katmanında bulunan UI state türlerini anlayın. | UI katmanındaki bu UI stateleri üzerinde çalışan logic türlerini anlayın. | ViewModel veya basit bir sınıf gibi bir state holderin uygun implementasyonunu nasıl seçeceğinizi öğrenin. | . State holders and state production in the UI Layer . Elements of the UI state production pipeline . UI state ve onu üreten logic, UI katmanını tanımlar. UI state . UI state, UI’yi tanımlayan propertydir. İki tür UI state vardır: . | Screen UI State, ekranda görüntülemeniz gereken şeydir. Örneğin, bir NewsUiState sınıfı, UI oluşturmak için gereken haber makalelerini ve diğer bilgileri içerebilir. Bu state, uygulama verilerini içerdiğinden genellikle hiyerarşinin diğer katmanlarıyla bağlantılıdır. | UI element state, UI elementlerinin nasıl oluşturulduğunu etkileyen, onlara özgü propertyleri ifade eder. Bir UI elementi gösterilebilir veya gizlenebilir ve belirli bir yazı tipine, yazı tipi boyutuna veya yazı tipi rengine sahip olabilir. Androide, View, doğası gereği stateful olduğu için bu state’i kendisi yönetir ve state’i değiştirmek veya sorgulamak için methodlar sunar. Bunun bir örneği, text için TextView sınıfının get ve set methodlaridir. Jetpack Compose’da state composable olanın dışındadır ve hatta onu composable olanın hemen yakınından çağıran composable fonksiyona veya bir state holderine hoist edebilirsiniz. Bunun bir örneği, composable Scaffold için ScaffoldState’tir. | . Logic . Uygulama verileri ve kullanıcı eventleri, UI state’inin zaman içinde değişmesine neden olduğundan, UI state statik bir property değildir. Logic, UI state’inin hangi bölümlerinin değiştiği, neden değiştiği ve ne zaman değişmesi gerektiği dahil olmak üzere değişikliğin özelliklerini belirler. Logic, business logic veya UI logic olabilir: . | Business logic, uygulama verileri için ürün gereksinimlerinin implemente edilmesidir. Örneğin, kullanıcı butona dokunduğunda bir haber okuyucu uygulamasında bir makaleye yer işareti koyma. Bir yer imini bir dosyaya veya veritabanına kaydetme logic’i genellikle domain veya data katmanlarına yerleştirilir. State holder genellikle bu logic’i, ortaya çıkardıkları metodları çağırarak bu katmanlara devreder. | UI logic, UI state’inin ekranda nasıl görüntüleneceği ile ilgilidir. Örneğin, kullanıcı bir kategori seçtiğinde doğru arama çubuğu hint elde etmek, bir listede belirli bir öğeye kaydırma yapmak veya kullanıcı bir butona tıkladığında belirli bir ekrana navigate etme logic’i. | . Android lifecycle and the types of UI state and logic . UI katmanının iki bölümü vardır: UI lifecycle’a biri bağımlı, diğeri bağımsız. Bu ayrım, her fragmentin kullanabileceği veri kaynaklarını belirler ve bu nedenle farklı türde UI state ve logic gerektirir. | UI yaşam döngüsünden bağımsız(UI lifecycle independent): UI katmanının bu kısmı, uygulamanın veri üreten katmanlarıyla (data veya domain katmanları) ilgilenir ve business logic tarafından tanımlanır. UI’deki lifecycle, configuration changes ve activity oluşturma, UI state production pipeline in etkin olup olmadığını etkileyebilir, ancak üretilen verilerin geçerliliğini etkilemez. | UI yaşam döngüsüne bağlı(UI lifecycle dependent): UI katmanının bu kısmı, UI logici ile ilgilenir ve lifecycle veya configuration changeden doğrudan etkilenir. Bu değişiklikler, içinde okunan veri kaynaklarının geçerliliğini doğrudan etkiler ve sonuç olarak state ancak lifecycle aktif olduğunda değişebilir. Buna örnek olarak runtime izinleri ve localized stringler gibi yapılandırmaya bağlı kaynakların alınması dahildir. | . Yukarıdakiler aşağıdaki tablo ile özetlenebilir: . | Ui Lifecycle independent | Ui Lifecycle dependent | . | Business logic | UI logic | . | Screen UI state |   | . The UI state production pipeline . UI state production pipeline, UI state oluşturmak için atilan adımları ifade eder. Bu adımlar, daha önce tanımlanan logic türlerinin uygulanmasını içerir ve tamamen UI gereksinimlerine bağlıdır. Bazı UI’ler, pipeline’in hem UI Lifecycle independent hem de UI Lifecycle dependent bölümlerinden yararlanabilir veya hiçbirinden yararlanamaz. Yani, UI katman pipeline’in aşağıdaki permütasyonları geçerlidir: . | UI’in kendisi tarafından üretilen ve yönetilen UI state. Örneğin, basit, yeniden kullanılabilir bir temel sayaç: | . @Composable fun Counter() { // The UI state is managed by the UI itself var count by remember { mutableStateOf(0) } Row { Button(onClick = { ++count }) { Text(text = \"Increment\") } Button(onClick = { --count }) { Text(text = \"Decrement\") } } } . | UI logic → UI. Örneğin, kullanıcının bir listenin en üstüne atlamasına olanak tanıyan bir butonu göstermek veya gizlemek. | . @Composable fun ContactsList(contacts: List&lt;Contact&gt;) { val listState = rememberLazyListState() val isAtTopOfList by remember { derivedStateOf { listState.firstVisibleItemIndex &lt; 3 } } // Create the LazyColumn with the lazyListState ... // Show or hide the button (UI logic) based on the list scroll position AnimatedVisibility(visible = !isAtTopOfList) { ScrollToTopButton() } } . | Business logic → UI. Geçerli kullanıcının fotoğrafını ekranda gösteren bir UI elementi. | . @Composable fun UserProfileScreen(viewModel: UserProfileViewModel = hiltViewModel()) { // Read screen UI state from the business logic state holder val uiState by viewModel.uiState.collectAsStateWithLifecycle() // Call on the UserAvatar Composable to display the photo UserAvatar(picture = uiState.profilePicture) } . | Business logic → UI logic → UI.Belirli bir UI state için ekranda doğru bilgileri görüntülemek üzere kayan bir UI element. | . @Composable fun ContactsList(viewModel: ContactsViewModel = hiltViewModel()) { // Read screen UI state from the business logic state holder val uiState by viewModel.uiState.collectAsStateWithLifecycle() val contacts = uiState.contacts val deepLinkedContact = uiState.deepLinkedContact val listState = rememberLazyListState() // Create the LazyColumn with the lazyListState ... // Perform UI logic that depends on information from business logic if (deepLinkedContact != null &amp;&amp; contacts.isNotEmpty()) { LaunchedEffect(listState, deepLinkedContact, contacts) { val deepLinkedContactIndex = contacts.indexOf(deepLinkedContact) if (deepLinkedContactIndex &gt;= 0) { // Scroll to deep linked item listState.animateScrollToItem(deepLinkedContactIndex) } } } } . UI state production pipeline her iki tür mantığın da uygulandığı durumda, business logic her zaman UI logicten önce uygulanmalıdır. UI logicinden sonra busines logici uygulamaya çalışmak, business logicin UI logice bağlı olduğu anlamına gelir. Aşağıdaki bölümler, farklı logic türlerine ve state holderlerine derinlemesine bir bakışla bunun neden bir sorun olduğunu ele almaktadır. State holders and their responsibilities . State holderin sorumluluğu, uygulamanın okuyabilmesi için state’i saklamaktır. Logice ihtiyaç duyulan durumlarda aracılık yaparak gerekli logici barındıran veri kaynaklarına erişim sağlar. Bu şekilde, state holder logici uygun veri kaynağına devreder. Bu, aşağıdaki faydaları sağlar: . | Basit UI’lar: UIsadece state’ini bağlar. | Sürdürülebilirlik: State holderda tanımlanan logic, UI’in kendisi değiştirilmeden yinelenebilir. | Test Edilebilirlik: UI ve state production logici bağımsız olarak test edilebilir. | Okunabilirlik: Kodu okuyanlar, UI presentation kodu ile UI state production kodu arasındaki farkları açıkça görebilir. | . Boyutu veya kapsamı ne olursa olsun, her UI elementinin karşılık gelen state holderi ile 1:1 ilişkisi vardır. Ayrıca, bir state holderin, bir UI state değişikliği ile sonuçlanabilecek herhangi bir kullanıcı eylemini kabul edebilmesi ve işleyebilmesi ve ardından gelen state değişikliğini üretebilmesi gerekir. Not: State holderler kesinlikle gerekli değildir. Basit UI’kar, logiclerini presentation kodlarıyla inline olarak barındırabilir. Types of state holders . UI state’i ve logic’i tiplerini benzer şekilde, UI katmanında, UI yaşam döngüsüyle olan ilişkilerine göre tanımlanan iki tür state holder vardır: . | The business logic state holder. | The UI logic state holder. | . Aşağıdaki bölümlerde, business logic state holderinden başlayarak state holderlerin türlerine daha yakından bakılmaktadır. Not: Bir UI logic state holderi, data veya domain katmanlarından gelen bilgilere bağlıysa, bu bilgileri ona bir business logic state holderinden iletmelisiniz. Bunun nedeni, business logic state holderinin, UI yaşam döngüsünden bağımsız olduğu için UI logici state holderinden daha uzun ömürlü olmasıdır. Business logic and its state holder . Business logic state holderlari, kullanıcı eventlerini handle eder ve verileri data veya domain katmanlarından ekran UI state’ine dönüştürür. Android yaşam döngüsü ve uygulama configuration changes göz önünde bulundurulduğunda optimum kullanıcı deneyimi sağlamak için business logic kullanan state holderlerini aşağıdaki özelliklere sahip olması gerekir: . | Property | Detail | . | Produces UI State(UI State uretmek) | Business logic state holderlar, UI için UI state’i oluşturmaktan sorumludur. Bu UI state’i, genellikle kullanıcı eventlerinin handle edilmesiyle ve domain ve data katmanlarından verilerin okunmasının sonucudur. | . | Retained through activity recreation(activitynin yeniden olusturulmasina karsi korumak) | Business logic state holderlar, Activity’nin yeniden oluşturulması karsisinda state ve state processing pipelinelerini koruyarak sorunsuz bir kullanıcı deneyimi sağlamaya yardımcı olur. State holderin korunmadigi ve yeniden yaratıldığı durumlarda (genellikle işlem ölümünden sonra), state holderin tutarlı bir kullanıcı deneyimi sağlamak için son state’i kolayca yeniden oluşturabilmesi gerekir. | . | Possess long lived state(uzun omurlu state tutmak) | Business logic state holderlari genellikle navigasyon destinationlari için state’i yönetmek amacila kullanılır. Sonuç olarak, genellikle navigasyon graphden kaldırılana kadar statelerini navigasyon değişikliklerinde korurlar. | . | Is unique to its UI and is not reusable(Kullanıcı arayüzüne özgüdür ve yeniden kullanılamaz) | Business logic state holderleri tipik olarak belirli bir uygulama fonksiyonaltesi icin üretilir, örneğin bir TaskEditViewModel veya bir TaskListViewModel için state üretir ve bu nedenle yalnızca o uygulama fonksiyonalitesi için geçerlidir. Aynı state holder, farklı form faktörlerinde bu uygulama fonksiyonalitelerini destekleyebilir. Örneğin, uygulamanın mobil, TV ve tablet sürümleri aynı business logic state holderini yeniden kullanabilir. | . Not: Business logic state holderlar; ViewModel instancelari yukarıda belirtilen özelliklerin birçoğunu, özellikle de Activity yeniden oluşturma sırasında hayatta kaldigi icin, tipik olarak bir ViewModel instance ile implement edilirler. Örneğin, “Now in Android” uygulamasında yazar navigation hedefini göz önünde bulundurun: . Business logic state holder olarak hareket eden AuthorViewModel, bu durumda UI state’ini üretir: . @HiltViewModel class AuthorViewModel @Inject constructor( savedStateHandle: SavedStateHandle, private val authorsRepository: AuthorsRepository, newsRepository: NewsRepository ) : ViewModel() { val uiState: StateFlow&lt;AuthorScreenUiState&gt; = … // Business logic fun followAuthor(followed: Boolean) { … } } . AuthorViewModel’in daha önce belirtilen business logic state holder özelliklere sahip olduğuna dikkat edin: . | Property | Detail | . | Produces AuthorScreenUiState | The AuthorViewModel reads data from the AuthorsRepository and NewsRepository and uses that data to produce AuthorScreenUiState. It also applies business logic when the user wants to follow or unfollow an Author by delegating to the AuthorsRepository. | . | Has access to the data layer | An instance of AuthorsRepository and NewsRepository are passed to it in its constructor, allowing it to implement the business logic of following an Author. | . | Survives Activity recreation | Because it is implemented with a ViewModel, it will be retained across quick Activity recreation. In the case of process death, the SavedStateHandle object can be read from to provide the minimum amount of information required to restore the UI state from the data layer. | . | Possesses long lived state | The ViewModel is scoped to the navigation graph, therefore unless the author destination is removed from the nav graph, the UI state in the uiState StateFlow remains in memory. The use of the StateFlow also adds the benefit of making the application of the business logic that produces the state lazy because state is only produced if there is a collector of the UI state. | . | Is unique to its UI | The AuthorViewModel is only applicable to the author navigation destination and cannot be reused anywhere else. If there is any business logic that is reused across navigation destinations, that business logic must be encapsulated in a data- or domain-layer-scoped component. | . Not: ViewModel’i yalnızca destination düzeyinde UI ile kullanmalısınız. Bunları, UI’in arama çubukları veya chip grupları gibi yeniden kullanılabilir parçalarında kullanmamalısınız. Bu durumlarda düz sınıflar daha uygundur. Uyarı: ViewModel instancelarini diğer composable fonksiyonlara argüman olarak vermeyin. Bunu yapmak, composable fonksiyonu ViewModel türüyle birleştirerek daha az yeniden kullanılabilir ve test edilmesini ve önizlemesini zorlaştırır. Ayrıca, ViewModel instancesini yöneten net bir tek doğruluk kaynağı (SSOT) olmayacaktır. ViewModel’i devre dışı bırakmak, birden çok composable öğenin ViewModel fonksiyonlarini çağırmasına ve state’i değiştirmesine izin vererek hataların debugini zorlaştırır. Bunun yerine, UDF best practicelerini izleyin ve yalnızca gerekli state’i iletin. Aynı şekilde, yayılan eventleri ViewModel’in composable SSOT’sine ulaşana kadar iletin. Eventi handle eden ve karşılık gelen ViewModel methodlarini çağıran SSOT budur. The ViewModel as a business logic state holder . ViewModels’in Android geliştirmedeki faydaları, onları business logice erişim sağlamak ve uygulama verilerini ekranda presentation için hazırlamak için uygun hale getirir. Bu faydalar aşağıdakileri içerir: . | ViewModels tarafından tetiklenen işlemler configuration changelerden kurtulur . | Navigasyon ile Entegrasyon saglar; . | Navigasyon, ekran backstackde iken ViewModels’i önbelleğe(cacheler) alır. Bu, destinationunuza döndüğünüzde önceden yüklenmiş verilerinizin anında kullanılabilir olması açısından önemlidir. Bu, composable ekranın yaşam döngüsünü observe eden bir state holder ile yapılması daha zor bir şeydir. | ViewModel, hedef backstackden çıkarıldığında da temizlenir ve state’inizin otomatik olarak temizlenmesini sağlar. Bu, yeni bir ekrana gitme, bir configuration change nedeniyle veya başka nedenler gibi birçok nedenden dolayı meydana gelebilecek composable imhayı dinlemekten farklıdır. | . | Hilt gibi diğer Jetpack library ile entegrasyon saglar. | . Not: ViewModel avantajları kullanım durumunuz için geçerli değilse veya işleri farklı bir şekilde yapıyorsanız, ViewModel’in sorumluluklarını düz state holder sınıflara taşıyabilirsiniz. UI logic and its state holder . UI logic, UI’nin kendisinin sağladığı veriler üzerinde çalışan logictir. Bu, UI elementlerinin state’inde veya permissions API’si veya Resources gibi UI data kaynaklarında olabilir. UI logicini kullanan state holderlar tipik olarak aşağıdaki özelliklere sahiptir: . | UI state’ini üretir ve UI elementlerinin state’ini yönetir. | Activity’i yeniden olusturma durumunda hayatta kalmaz; UI logicinde barındırılan state holderlar, genellikle UI’nin kendisinden gelen veri kaynaklarına bağımlıdır ve bu bilgileri yapılandırma değişiklikleri boyunca tutmaya çalışmak, genellikle bir bellek sızıntısına neden olur. State holderlar, yapılandırma değişikliklerinde devam etmek için verilere ihtiyaç duyarsa, hayatta kalan Aktivite yeniden olusturulmasina daha uygun başka bir componente yetki vermeleri gerekir. Örneğin, Jetpack Compose’da, remembered fonksiyonlarla oluşturulan Composable UI element stateleri, Activity yeniden olusturulmasi boyunca state’i korumak için genellikle rememberSaveable’a yetki verir. Bu tür fonksiyonlarin örnekleri arasında, rememberScaffoldState() ve rememberLazyListState() bulunur. | UI scopeindaki veri kaynaklarına referansları vardır: UI logic state holder, UI ile aynı yaşam döngüsüne sahip olduğundan, yaşam döngüsü API’leri ve Resources gibi veri kaynaklarına güvenle başvurulabilir ve okunabilir. | Birden çok UI’de yeniden kullanılabilir: Aynı UI logic state holderinin farklı instancelari, uygulamanın farklı bölümlerinde yeniden kullanılabilir. Örneğin, bir chip grubu için kullanıcı input eventlerini yönetmek için bir state holder, filter chipleri için bir arama sayfasında ve ayrıca bir e-posta alıcıları için “to” fieldi için kullanılabilir. | . UI logic state holder, tipik olarak düz bir sınıfla uygulanır. Bunun nedeni, UI logic state holderinin oluşturulmasından UI’nin kendisinin sorumlu olması ve UI logic state holderinin, UI’nin kendisi ile aynı yaşam döngüsüne sahip olmasıdır. Örneğin Jetpack Compose’da state holder, Composition’un bir parçasıdır ve Composition’un yaşam döngüsünü takip eder. Not: Düz sınıf state holderleri, UI logici, UI’den taşınacak kadar karmaşık olduğunda kullanılır. Aksi takdirde, UI logici, UI’de inline olarak uygulanabilir. Now in Android örneğindeki aşağıdaki örnekte gösterilebilir: Now in Android örneği, cihazın ekran boyutuna bağlı olarak navigtion için bir bottom appbar veya bir navigation raili gösterir. Daha küçük ekranlar alttaki appbari ve daha büyük ekranlar navigation rail kullanır. NiaApp composable fonksiyonunda kullanılan uygun navigation UI elementine karar verme logici, business logice bağlı olmadığından, NiaAppState adlı düz bir sınıf state holder tarafından yönetilebilir: . @Stable class NiaAppState( val navController: NavHostController, val windowSizeClass: WindowSizeClass ) { // UI logic val shouldShowBottomBar: Boolean get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact || windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact // UI logic val shouldShowNavRail: Boolean get() = !shouldShowBottomBar // UI State val currentDestination: NavDestination? @Composable get() = navController .currentBackStackEntryAsState().value?.destination // UI logic fun navigate(destination: NiaNavigationDestination, route: String? = null) { /* ... */ } /* ... */ } . Yukarıdaki örnekte, NiaAppState ile ilgili aşağıdaki ayrıntılar dikkat çekicidir: . | Activity yeniden olustugunda hayatta kalamaz: NiaAppState, Compose adlandırma kurallarına uygun bir Composable fonksiyonu ile rememberNiaAppState oluşturularak Compositionda hatırlanır. Activity yeniden oluşturulduktan sonra, önceki instancelar kaybolur ve yeniden oluşturulan Activity’nin yeni yapılandırmasına uygun olarak tüm bağımlılıkları iletilmiş yeni bir instance oluşturulur. Bu bağımlılıklar yeni olabilir veya önceki yapılandırmadan geri yüklenebilir. Örneğin, rememberNavController(), niaAppState constructorunda kullanılır ve Activity yeniden olusturulmasi boyunca state’i korumak için rememberSaveable’a yetki verir. | UI kapsamlı veri kaynaklarına referansları vardır: NavigationController, Resources ve diğer benzer yaşam döngüsü kapsamındaki tiplere yapılan refereanslar, aynı yaşam döngüsü kapsamını paylaştıklarından NiaAppState’te güvenle tutulabilir. | . Not: Düz state holder sınıfları, arama çubukları veya chip grupları gibi yeniden kullanılabilir kullanıcı arabirimi parçaları için önerilir. Bu durumda ViewModels’i kullanmamalısınız çünkü bunlar en iyi navigation destination için state’i yönetmek ve business logice erişim için kullanılır. Choose between a ViewModel and plain class for a state holder . Yukarıdaki bölümlerden, bir ViewModel ve bir düz sınıf state holder arasında seçim yapmak, UI state’ine uygulanan logice ve logicin üzerinde çalıştığı veri kaynaklarına iner. Not: Çoğu uygulama, aksi takdirde düz sınıf state holderine yerleştirilebilecek olan UI logicini UI’in kendisinde inline olarak gerçekleştirmeyi seçer. Bu, basit durumlar için iyidir, ancak diğer durumlar için, logici düz bir sınıf state holderine çekerek okunabilirliği artırabilirsiniz . Özetle, aşağıdaki diyagram, UI State’i production pipelinedaki state holderlerinin pozisyonunu gösterir: Sonuç olarak, tüketildiği yere en yakın state holderlerini kullanarak UI state’i üretmelisiniz. Daha az resmi olarak, uygun ownershipligi surdururken state’i mümkün olduğunca düşük tutmalısınız. Business logice erişmeniz gerekiyorsa ve UI state’inin, Activity yeniden olusturulmasi genelinde bile bir ekrana gidilebildiği sürece devam etmesi gerekiyorsa, bir ViewModel, business logic state holder implement etmeniz için harika bir seçimdir. Daha kısa ömürlü UI state ve UI logic için, yaşam döngüsü yalnızca UI’ye bağlı olan düz bir sınıf yeterli olmalıdır. State holders are compoundable . Bağımlılıklar eşit veya daha kısa bir ömre sahip olduğu sürece state holderlar diğer state holderlara bağımlı olabilir. Bunun örnekleri şunlardır: . | bir UI logic state holder başka bir UI logic state holder’a bağlı olabilir. | bir screen level state holder, bir UI logic state holder’a bağlı olabilir. | . Aşağıdaki kod parçacığı, Compose’un DrawerState‘inin başka bir dahili state holder olan SwipeableState‘e nasıl bağlı olduğunu ve bir uygulamanın UI logic state holder’ının DrawerState’e nasıl bağlı olabileceğini göstermektedir: . @Stable class DrawerState(/* ... */) { internal val swipeableState = SwipeableState(/* ... */) // ... } @Stable class MyAppState( private val drawerState: DrawerState, private val navController: NavHostController ) { /* ... */ } @Composable fun rememberMyAppState( drawerState: DrawerState = rememberDrawerState(DrawerValue.Closed), navController: NavHostController = rememberNavController() ): MyAppState = remember(drawerState, navController) { MyAppState(drawerState, navController) } . Dikkat: Screen level state holderların bir ekranın veya ekranın bir kısmının business logic karmaşıklığını yönettiği göz önüne alındığında, bir screen level state holderın başka bir screen level state holdera bağlı olması mantıklı olmayacaktır. Bu senaryodaysanız, ekranlarınızı ve state holder'larınızı yeniden gözden geçirin ve ihtiyacınız olanın bu olduğundan emin olun. Bir state holder’dan daha uzun ömürlü bir bağımlılık örneği, bir screen level state holder’a bağlı olan bir UI logic state holder olabilir. Bu, daha kısa ömürlü state holder’ın yeniden kullanılabilirliğini azaltır ve gerçekte ihtiyaç duyduğundan daha fazla logic ve state’e erişmesini sağlar. Daha kısa ömürlü state holder’ın daha yüksek scope’lu bir state holder’dan belirli bilgilere ihtiyacı varsa, state holder instance’ını geçmek yerine yalnızca ihtiyaç duyduğu bilgileri parametre olarak geçirin. Örneğin, aşağıdaki kod parçasında, UI logic state holder sınıfı, ViewModel instance’ının tamamını bir bağımlılık olarak geçirmek yerine ViewModel’den parametre olarak sadece ihtiyaç duyduğu bilgileri alır. class MyScreenViewModel(/* ... */) { val uiState: StateFlow&lt;MyScreenUiState&gt; = /* ... */ fun doSomething() { /* ... */ } fun doAnotherThing() { /* ... */ } // ... } @Stable class MyScreenState( // DO NOT pass a ViewModel instance to a plain state holder class // private val viewModel: MyScreenViewModel, // Instead, pass only what it needs as a dependency private val someState: StateFlow&lt;SomeState&gt;, private val doSomething: () -&gt; Unit, // Other UI-scoped types private val scaffoldState: ScaffoldState ) { /* ... */ } @Composable fun rememberMyScreenState( someState: StateFlow&lt;SomeState&gt;, doSomething: () -&gt; Unit, scaffoldState: ScaffoldState = rememberScaffoldState() ): MyScreenState = remember(someState, doSomething, scaffoldState) { MyScreenState(someState, doSomething, scaffoldState) } @Composable fun MyScreen( modifier: Modifier = Modifier, viewModel: MyScreenViewModel = viewModel(), state: MyScreenState = rememberMyScreenState( someState = viewModel.uiState.map { it.toSomeState() }, doSomething = viewModel::doSomething ), // ... ) { /* ... */ } . Aşağıdaki diyagram, UI ile önceki kod parçacığının farklı state holder’ları arasındaki bağımlılıkları temsil etmektedir: . Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-holders-and-ui-state/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-holders-and-ui-state/"
  },"175": {
    "doc": "State production",
    "title": "State production",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production/"
  },"176": {
    "doc": "State production",
    "title": "UI State Production",
    "content": "Modern UI ler nadiren statiktir. Kullanıcı, UI ile etkileşime girdiğinde veya uygulamanın yeni verileri göstermesi gerektiğinde UI’in state’i değişir. Bu belge, UI state’inin üretimi(production) ve yönetimi için yönergeler belirler. Sonunda şunları yapmalısınız: . | UI state’i oluşturmak(produce) için hangi API’leri kullanmanız gerektiğini bilin. Bu, tek yönlü veri akışı(UDF) ilkelerini izleyerek state holderlerinizde bulunan state değişikliği kaynaklarının doğasına bağlıdır. | Sistem kaynaklarının bilincinde olmak için UI state’inin üretimini nasıl kapsamanız(scope) gerektiğini öğrenin. | UI tarafından tüketim için UI stateini nasıl ortaya çıkarmanız gerektiğini bilin. | . Temel olarak state üretimi(state production), bu değişikliklerin UI state’ine artımlı olarak uygulanmasıdır. State her zaman vardır ve eventler sonucunda değişir. Eventler ve state arasındaki farklar aşağıdaki tabloda özetlenmiştir: . | Event | State | . | Transient, unpredictable, and exist for a finite period.(Geçici, öngörülemeyen ve sonlu bir süre için var olan.) | Always exists.(herzaman vardir) | . | The inputs of state production.(State üretiminin girdileridir.) | The output of state production.(State uretiminin ciktisidir.) | . | The product of the UI or other sources.(UI’in veya diğer kaynaklarin urunudur.) | Is consumed by the UI.(UI tarafindan tuketilir) | . Yukarıdakileri özetleyen harika bir anımsatıcı şudur: state is; events happen. Aşağıdaki şema, eventler bir zaman çizelgesinde meydana geldikçe statedeki değişiklikleri görselleştirmeye yardımcı olur. Her event uygun state holder tarafından işlenir ve bir state değişikliğiyle sonuçlanır: . Eventler şunlardan gelebilir: . | Kullanıcılar: Uygulamanın UI ile etkileşime girdikçe. | Diğer state değişikliği kaynakları: UI’den, domainden veya snackbar zaman aşımı eventleri gibi data katmanlarından uygulama verileri sunan API’ler, sırasıyla use case siniflari veya repositoryler. | . The UI state production pipeline . Android uygulamalarındaki state production, aşağıdakilerden oluşan bir processing pipeline olarak düşünülebilir: . | Inputs;State’in kaynakları değişir. Olabilirler: . | UI katmanında local: Bunlar, bir görev yönetimi uygulamasında “yapılacak iş” için bir başlık giren bir kullanıcı gibi kullanıcı eventleri veya UI state’indeki değişiklikleri yönlendiren UI logicine erişim sağlayan API’ler olabilir. Örneğin, Jetpack Compose’da DrawerState‘te open methodunu çağırmak. | UI katmanının dışında: Bunlar, UI state’inde değişikliklere neden olan domain veya data katmanlarından gelen kaynaklardır. Örneğin, bir NewsRepository’den yüklenmesi biten haberler veya diğer eventler. | Yukarıdakilerin hepsinin bir karışımı. | . | State holders;Business logici ve/veya UI logicini state değişikliği kaynaklarına uygulayan ve UI state oluşturmak(produce) için kullanıcı eventlerini işleyen türler. | Output;Uygulamanın, kullanıcılara ihtiyaç duydukları bilgileri sağlamak için işleyebileceği UI State. | . State production APIs . Pipeline’in hangi aşamasında olduğunuza bağlı olarak state productionda kullanılan iki ana API vardır: . | Pipeline stage | API | . | Input | You should use asynchronous APIs to perform work off the UI thread to keep the UI jank free. For example, Coroutines or Flows in Kotlin, and RxJava or callbacks in the Java Programming Language. | . | Output | You should use observable data holder APIs to invalidate and rerender the UI when state changes. For example, StateFlow, Compose State, or LiveData. Observable data holders guarantee the UI always has a UI state to display on the screen. | . Bu ikisi arasından, input için asenkron API seçiminin, output için gözlemlenebilir API seçiminden çok, state production pipelinein doğası üzerinde daha büyük bir etkisi vardır. Bunun nedeni, inputlarin pipeline’a uygulanabilecek processing türünü dikte etmesidir. State production pipeline assembly . Sonraki bölümler, çeşitli inputlar için en uygun state productin tekniklerini ve eşleşen output API’lerini kapsar. Her state production pipelie, inputlarin ve outputlarin bir kombinasyonudur ve şöyle olmalıdır: . | Yaşam döngüsünün farkında(Lifecycle aware): UI’in visible veya active olmadığı durumlarda, açıkça gerekli olmadıkça state production pipeline herhangi bir kaynak tüketmemelidir. | Kullanımı kolay(Easy to consume): UI, üretilen UI state’ini kolayca oluşturabilmelidir(produce etmelidir). State production pipelinenin outputuna yönelik hususlar, View sistemi veya Jetpack Compose gibi farklı View API’lerinde değişiklik gösterecektir. | . Not: İzleyen bölümlerde, tartışılan tüm API’ler deyimsel Kotlin ve Jetpack Compose kodunu kullanır. Ancak kılavuz, Java Programlama Dili veya Kotlin’deki diğer API’lerdeki eşdeğer analogları için geçerlidir. Input in state production pipelines . Bir state production pipelinedeki inputlar, state değişikliği kaynaklarını şu yollarla sağlayabilir: . | One-shot operations that may be synchronous or asynchronous, for example calls to suspend functions. | Stream APIs, for example Flows. | All of the above. | . Aşağıdaki bölümlerde, yukarıdaki inputlarin her biri için bir state production pipline’i nasıl kurabileceğiniz ele alınmaktadır. One-shot APIs as sources of state change . MutableStateFlow API’yi gözlemlenebilir, değiştirilebilir bir state containeri olarak kullanın. Jetpack Compose uygulamalarında, özellikle Compose text API‘leri ile çalışırken mutableStateOf‘u da düşünebilirsiniz. Her iki API de barındırdıkları değerlerde güvenli atomik güncellemelere izin veren methodlar sunar, güncellemeler senkron veya asenkro olsun ya da olmasın. Örneğin, basit bir zar atma uygulamasında state güncellemelerini düşünün. Kullanıcının attığı her zar, senkronize Random.nextInt() methodunu çağırır ve sonuç, UI state’ine yazılır. // StateFlow data class DiceUiState( val firstDieValue: Int? = null, val secondDieValue: Int? = null, val numberOfRolls: Int = 0, ) class DiceRollViewModel : ViewModel() { private val _uiState = MutableStateFlow(DiceUiState()) val uiState: StateFlow&lt;DiceUiState&gt; = _uiState.asStateFlow() // Called from the UI fun rollDice() { _uiState.update { currentState -&gt; currentState.copy( firstDieValue = Random.nextInt(from = 1, until = 7), secondDieValue = Random.nextInt(from = 1, until = 7), numberOfRolls = currentState.numberOfRolls + 1, ) } } } //compose @Stable interface DiceUiState { val firstDieValue: Int? val secondDieValue: Int? val numberOfRolls: Int? } private class MutableDiceUiState: DiceUiState { override var firstDieValue: Int? by mutableStateOf(null) override var secondDieValue: Int? by mutableStateOf(null) override var numberOfRolls: Int by mutableStateOf(0) } class DiceRollViewModel : ViewModel() { private val _uiState = MutableDiceUiState() val uiState: DiceUiState = _uiState // Called from the UI fun rollDice() { _uiState.firstDieValue = Random.nextInt(from = 1, until = 7) _uiState.secondDieValue = Random.nextInt(from = 1, until = 7) _uiState.numberOfRolls = _uiState.numberOfRolls + 1 } } . Mutating the UI state from asynchronous calls . Asenkron bir sonuç gerektiren state değişiklikleri için uygun CoroutineScope’ta bir Coroutine başlatın. Bu, CoroutineScope iptal edildiğinde uygulamanın işi silmesine izin verir. State holder daha sonra suspend method çağrısının sonucunu UI state’ini ortaya çıkarmak için kullanılan gözlemlenebilir API’ye yazar. Örneğin, [Architecture örneği](https://github.com/android/architecture-samplesndeki AddEditTaskViewModel’i göz önünde bulundurun. Askıya alınan(suspend edilen) saveTask() methodu bir taski asenkron olarak kaydettiğinde, MutableStateFlow’daki update methodu state değişikliğini UI state’ine yayar. // StateFlow data class AddEditTaskUiState( val title: String = \"\", val description: String = \"\", val isTaskCompleted: Boolean = false, val isLoading: Boolean = false, val userMessage: String? = null, val isTaskSaved: Boolean = false ) class AddEditTaskViewModel(...) : ViewModel() { private val _uiState = MutableStateFlow(AddEditTaskUiState()) val uiState: StateFlow&lt;AddEditTaskUiState&gt; = _uiState.asStateFlow() private fun createNewTask() { viewModelScope.launch { val newTask = Task(uiState.value.title, uiState.value.description) try { tasksRepository.saveTask(newTask) // Write data into the UI state. _uiState.update { it.copy(isTaskSaved = true) } } catch(cancellationException: CancellationException) { throw cancellationException } catch(exception: Exception) { _uiState.update { it.copy(userMessage = getErrorMessage(exception)) } } } } } //Compose State @Stable interface AddEditTaskUiState { val title: String val description: String val isTaskCompleted: Boolean val isLoading: Boolean val userMessage: String? val isTaskSaved: Boolean } private class MutableAddEditTaskUiState : AddEditTaskUiState() { override var title: String by mutableStateOf(\"\") override var description: String by mutableStateOf(\"\") override var isTaskCompleted: Boolean by mutableStateOf(false) override var isLoading: Boolean by mutableStateOf(false) override var userMessage: String? by mutableStateOf&lt;String?&gt;(null) override var isTaskSaved: Boolean by mutableStateOf(false) } class AddEditTaskViewModel(...) : ViewModel() { private val _uiState = MutableAddEditTaskUiState() val uiState: AddEditTaskUiState = _uiState private fun createNewTask() { viewModelScope.launch { val newTask = Task(uiState.value.title, uiState.value.description) try { tasksRepository.saveTask(newTask) // Write data into the UI state. _uiState.isTaskSaved = true } catch(cancellationException: CancellationException) { throw cancellationException } catch(exception: Exception) { _uiState.userMessage = getErrorMessage(exception)) } } } } . Not: Bir [AAC ViewModel](/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/about-viewmodel.md)'in viewModelScope'unda başlatılan coroutineler, istisnai olarak veya başka türlü tamamlanmaya çalışır. Bu, Coroutines açıkça iptal edilmedikçe veya ViewModel temizlenmedikçe, UI görünür olsun ya da olmasın gerçekleşir. Kısa ömürlü olma eğiliminde olduklarından, çoğu istek için bu genellikle uygundur. 5 saniye veya daha uzun süren istekleri çalıştırmak için viewModelScope kullanmamalısınız. Bunun yerine bunları WorkManager ile ertelenmiş veya uzun süreli işler olarak kuyruğa almalısınız. Mutating the UI state from background threads . UI state’inin productionu için main dispacther Coroutines’in başlatılması tercih edilir. Yani, aşağıdaki kod parçacıklarındaki withContext bloğunun dışında. Ancak, UI state’ini farklı bir backgroud context’inde güncellemeniz gerekirse, bunu aşağıdaki API’leri kullanarak yapabilirsiniz: . | Use the withContext method to run Coroutines in a different concurrent context. | When using MutableStateFlow, use the update method as usual. | When using Compose State, use the Snapshot.withMutableSnapshot to guarantee atomic updates to State in the concurrent context. | . Örneğin, aşağıdaki DiceRollViewModel parçacığında, SlowRandom.nextInt()’in CPU’ya bağlı bir Coroutine’den çağrılması gereken hesaplama açısından yoğun bir askıya alma işlevi olduğunu varsayalım. // StateFlow class DiceRollViewModel( private val defaultDispatcher: CoroutineScope = Dispatchers.Default ) : ViewModel() { private val _uiState = MutableStateFlow(DiceUiState()) val uiState: StateFlow&lt;DiceUiState&gt; = _uiState.asStateFlow() // Called from the UI fun rollDice() { viewModelScope.launch() { // Other Coroutines that may be called from the current context … withContext(defaultDispatcher) { _uiState.update { currentState -&gt; currentState.copy( firstDieValue = SlowRandom.nextInt(from = 1, until = 7), secondDieValue = SlowRandom.nextInt(from = 1, until = 7), numberOfRolls = currentState.numberOfRolls + 1, ) } } } } } // Compose State class DiceRollViewModel( private val defaultDispatcher: CoroutineScope = Dispatchers.Default ) : ViewModel() { private val _uiState = MutableDiceUiState() val uiState: DiceUiState = _uiState // Called from the UI fun rollDice() { viewModelScope.launch() { // Other Coroutines that may be called from the current context … withContext(defaultDispatcher) { Snapshot.withMutableSnapshot { _uiState.firstDieValue = SlowRandom.nextInt(from = 1, until = 7) _uiState.secondDieValue = SlowRandom.nextInt(from = 1, until = 7) _uiState.numberOfRolls = _uiState.numberOfRolls + 1 } } } } } . Not: Başlatılan tüm coroutinelerin farklı bir contexden çağrılması gerekiyorsa, doğrudan viewModelScope.launch(defaultDispatcher){ } öğesini arayabilirsiniz. Uyarı: Snapshot.withMutableSnapshot{ } kullanılmadan UI olmayan bir threadden Compose state’inin güncellenmesi, üretilen state’de tutarsızlıklara neden olabilir. Stream APIs as sources of state change . Streamlerde zaman içinde birden çok değer üreten state değişikliği kaynakları için, tüm kaynakların outputlarini uyumlu bir bütün halinde birleştirmek, state üretimine(production) doğrudan bir yaklaşımdır.Kotlin Flows kullanırken bunu combine fonksiyonu ile başarabilirsiniz. Bunun bir örneği, InterestsViewModel’deki “Now in Android” örneğinde görülebilir: . class InterestsViewModel( authorsRepository: AuthorsRepository, topicsRepository: TopicsRepository ) : ViewModel() { val uiState = combine( authorsRepository.getAuthorsStream(), topicsRepository.getTopicsStream(), ) { availableAuthors, availableTopics -&gt; InterestsUiState.Interests( authors = availableAuthors, topics = availableTopics ) } .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = InterestsUiState.Loading ) } . Not: Combined Flow’u, UI state için gözlemlenebilir API olarak bir [StateFlow](https://developer.android.com/kotlin/flow/stateflow-and-sharedflow)'a dönüştürmek için [stateIn](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html) operatörünü kullanabilirsiniz. StateFlows oluşturmak için stateIn operatörünün kullanılması, yalnızca UI görünürken aktif olması gerekebileceğinden, UI’ye state production pipeline’in activitysi üzerinde daha ayrıntılı kontrol sağlar. | Flow’un yaşam döngüsüne duyarlı bir şekilde collect edilmesi sırasında pipeline’in yalnızca UI görünür olduğunda etkin olması gerekiyorsa SharingStarted.WhileSubscription() öğesini kullanın. | Kullanıcı UI’e dönebildiği sürece, yani UI backstackde veya ekran dışında başka bir sekmede olduğu sürece pipeline’in aktif olması gerekiyorsa SharingStarted.Lazily kullanın. | . Stream tabanlı state kaynaklarının collectinin geçerli olmadığı durumlarda, Kotlin Flows gibi stream API’leri, streamlerin UI state’ine işlenmesine yardımcı olmak için [merging](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/merge.html?query=fun%20%3CT%3E%20merge(vararg%20flows:%20Flow%3CT%3E), [flattening](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html?query=inline%20fun%20%3CT,%20R%3E%20Flow%3CT%3E.flatMapLatest(crossinline%20transform:%20suspend%20(T) vb. gibi zengin bir transformation seti sunar. Anahtar Nokta: Çoğu durumda combine, stream API’lerinden state productiona yönelik tavsiye edilen bir yaklaşımdır. One-shot and stream APIs as sources of state change . State production pipeline’in, state değişikliği kaynakları olarak hem tek seferlik(one-shot) çağrılara hem de streamlere bağlı olduğu durumda, tanımlayıcı kısıtlama akışlardır(streams are defining constraint). Bu nedenle, tek seferlik çağrıları stream API’lerine dönüştürün veya outputlarini streamlere aktarın ve yukarıdaki stream bölümünde açıklandığı gibi işlemeye devam edin. Flowlarla, bu genellikle state değişikliklerini yaymak için bir veya daha fazla private backing MutableStateFlow instancei oluşturmak anlamına gelir. Compose state’inden snapshot flowlari da oluşturabilirsiniz. Aşağıdaki mimari örnekler repositorysinden TaskDetailViewModel’i göz önünde bulundurun: . //StateFlow class TaskDetailViewModel @Inject constructor( private val tasksRepository: TasksRepository, savedStateHandle: SavedStateHandle ) : ViewModel() { private val _isTaskDeleted = MutableStateFlow(false) private val _task = tasksRepository.getTaskStream(taskId) val uiState: StateFlow&lt;TaskDetailUiState&gt; = combine( _isTaskDeleted, _task ) { isTaskDeleted, task -&gt; TaskDetailUiState( task = taskAsync.data, isTaskDeleted = isTaskDeleted ) } // Convert the result to the appropriate observable API for the UI .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = TaskDetailUiState() ) fun deleteTask() = viewModelScope.launch { tasksRepository.deleteTask(taskId) _isTaskDeleted.update { true } } } //Compose State class TaskDetailViewModel @Inject constructor( private val tasksRepository: TasksRepository, savedStateHandle: SavedStateHandle ) : ViewModel() { private var _isTaskDeleted by mutableStateOf(false) private val _task = tasksRepository.getTaskStream(taskId) val uiState: StateFlow&lt;TaskDetailUiState&gt; = combine( snapshotFlow { _isTaskDeleted }, _task ) { isTaskDeleted, task -&gt; TaskDetailUiState( task = taskAsync.data, isTaskDeleted = isTaskDeleted ) } // Convert the result to the appropriate observable API for the UI .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = TaskDetailUiState() ) fun deleteTask() = viewModelScope.launch { tasksRepository.deleteTask(taskId) _isTaskDeleted = true } } . Not: Compose State, snapshotFlow { } API kullanılarak bir flowa dönüştürülür. Başka bir örnek için “Now In Android” örneğindeki ForYouViewModel‘e bakın. Output types in state production pipelines . UI State için output API’sinin seçimi ve sunumunun doğası, büyük ölçüde uygulamanızın UI’ini oluşturmak için kullandığı API’ye bağlıdır. Android uygulamalarında Views veya Jetpack Compose kullanmayı seçebilirsiniz. Buradaki hususlar şunları içerir: . | State’i yaşam döngüsüne duyarlı bir şekilde okuma. | State’in, state holderinden bir veya daha fazla field’inden gösterilmesi gerekip gerekmediği. | . Aşağıdaki tablo, herhangi bir input ve consumer için state production pipeline için hangi API’lerin kullanılacağını özetlemektedir: . | Input | Consumer | Output | . | One-shot APIs | Views | StateFlow or LiveData | . | One-shot APIs | Compose | StateFlow or Compose State | . | Stream APIs | Views | StateFlow or LiveData | . | Stream APIs | Compose | StateFlow | . | One-shot and stream APIs | Views | StateFlow or LiveData | . | One-shot and stream APIs | Compose | StateFlow | . State production pipeline initialization . State production pipeline’larının başlatılması, pipeline’ın çalışması için ilk koşulların ayarlanmasını içerir. Bu, örneğin bir haber makalesinin detail view’i için bir ID gibi pipeline’ın başlatılması için kritik olan ilk girdi değerlerinin sağlanmasını veya asenkron bir yüklemenin başlatılmasını içerebilir. Sistem kaynaklarını korumak için state production pipeline’ı mümkün olduğunca lazily başlatmalısınız. Pratikte bu genellikle çıktının bir tüketicisi olana kadar beklemek anlamına gelir. Flow API’leri, stateIn metodundaki started argümanı ile buna izin verir. Bunun uygulanamaz olduğu durumlarda, aşağıdaki kod parçasında gösterildiği gibi state production pipeline’ı explicit olarak başlatmak için idempotent bir initialize() fonksiyonu tanımlayın: . class MyViewModel : ViewModel() { private var initializeCalled = false // This function is idempotent provided it is only called from the UI thread. @MainThread fun initialize() { if(initializeCalled) return initializeCalled = true viewModelScope.launch { // seed the state production pipeline } } } . Uyarı: Bir ViewModel'in init bloğunda veya constructor'ında asenkron işlemler başlatmaktan kaçının. Asenkron işlemler bir nesne oluşturmanın yan etkisi olmamalıdır çünkü asenkron kod, nesne tam olarak başlatılmadan önce nesneden okuyabilir veya nesneye yazabilir. Bu aynı zamanda leaking the object (nesnenin sızdırılması) olarak da adlandırılır ve ince ve teşhis edilmesi zor hatalara yol açabilir. Bu özellikle Compose State ile çalışırken önemlidir. ViewModel Compose State fieldlarini tuttuğunda, ViewModel'in init bloğunda Compose State fieldlarını güncelleyen bir Coroutine başlatmayın, aksi takdirde bir IllegalStateException oluşabilir. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production/#ui-state-production",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production/#ui-state-production"
  },"177": {
    "doc": "String",
    "title": "String",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/string/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/string/"
  },"178": {
    "doc": "Style",
    "title": "Style",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/style/",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/style/"
  },"179": {
    "doc": "Support multiple back stacks",
    "title": "Support multiple back stacks",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/support-multiple-back-stacks/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/support-multiple-back-stacks/"
  },"180": {
    "doc": "Tasks and the back stack",
    "title": "Tasks and the back stack",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/tasks-and-the-back-stack/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/tasks-and-the-back-stack/"
  },"181": {
    "doc": "Test navigation",
    "title": "Test navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/test-navigation/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/test-navigation/"
  },"182": {
    "doc": "Test your app with pseudolocales",
    "title": "Test your app with pseudolocales",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/test-your-app-with-pseudolocales/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/test-your-app-with-pseudolocales/"
  },"183": {
    "doc": "Test your app's activities",
    "title": "Test your app's activities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/test-your-apps-activities/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/test-your-apps-activities/"
  },"184": {
    "doc": "Test your fragments",
    "title": "Test your fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/test-your-fragments/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/test-your-fragments/"
  },"185": {
    "doc": "Test your paging implementation",
    "title": "Test your paging implementation",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/test-your-paging-implementation/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/test-your-paging-implementation/"
  },"186": {
    "doc": "The activity lifecycle",
    "title": "The activity lifecycle",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/the-activity-lifecycle/",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/the-activity-lifecycle/"
  },"187": {
    "doc": "Transform data streams",
    "title": "Transform data streams",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/transform-data-streams/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/transform-data-streams/"
  },"188": {
    "doc": "Two-way data binding",
    "title": "Two-way data binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/two-way-data-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/two-way-data-binding/"
  },"189": {
    "doc": "Type-safe navigation with Compose",
    "title": "Type-safe navigation with Compose",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/type-safe-navigation-with-compose/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/type-safe-navigation-with-compose/"
  },"190": {
    "doc": "Ui events",
    "title": "UI events",
    "content": "UI eventleri, UI layerda UI veya ViewModel tarafından işlenmesi gereken actionlardir. En yaygın event türü, kullanıcı eventleridir. Kullanıcı, uygulamayla etkileşim kurarak, örneğin ekrana dokunarak veya hareketler(gesture) oluşturarak kullanıcı eventleri oluşturur. UI daha sonra onClick() listenerlar gibi callbackleri kullanarak bu olayları tüketir( consume eder). Anahtar terimler: . | Kullanıcı Arabirimi(UI): Kullanıcı arabirimini yöneten View tabanlı kod veya Compose kodu. | UI eventleri(Kullanici arabirimi olaylari): UI layerda handle edilmesi gereken gereken actionlar. | Kullanıcı eventlari(User events): Kullanıcının uygulama ile etkileşim kurarken oluşturduğu eventler. | . ViewModel normalde belirli bir kullanıcı eventinin business logicini handle etmekten sorumludur; örneğin, kullanıcının bazı verileri yenilemek için bir butona tıklaması. Genellikle ViewModel, UI’in çağırabileceği methodlari göstererek bunu halleder. Kullanıcı eventlari, UI’in doğrudan handle edebilecegi UI behavior logicine de sahip olabilir; örneğin, farklı bir ekrana gitme veya bir Snackbar gösterme. Farklı mobil platformlarda veya form factorlerinde aynı uygulama için business logic aynı kalırken, UI behaviour logic’i bu durumlar arasında farklılık gösterebilen bir implementasyon detayıdır. UI layer sayfası, bu logic türlerini aşağıdaki gibi tanımlar: . | İş mantığı(business logic), state değişiklikleriyle ne yapılacağını ifade eder; örneğin, ödeme yapmak veya kullanıcı tercihlerini saklamak. Domain ve data layerlar genellikle bu logic’i handle eder. Bu kılavuz boyunca, Architecture Components ViewModel sınıfı, business logic’i handle eden sınıflar için düşünülmüş bir çözüm olarak kullanılır. | UI davranış mantığı veya UI mantığı(UI behavior logic veya UI logic), state değişikliklerinin nasıl görüntüleneceğini ifade eder; örneğin, navigation logic’i veya kullanıcıya mesajların nasıl gösterileceği. UI bu logic’i handle eder. | . Not: Bu sayfada sunulan öneriler ve best practiceler, geniş bir uygulama yelpazesine uygulanarak ölçeklenebilir, kaliteyi ve sağlamlığı artırabilir ve test edilmesini kolaylaştırabilir. Ancak, bunları kılavuz olarak ele almalı ve gereksinimlerinize göre uyarlamalısınız. Architecture: Handling UI events-MAD Skills . UI event decision tree . Aşağıdaki diyagram, belirli bir event kullanım senaryosunu(use case) ele almak için en iyi yaklaşımı bulmaya yönelik bir karar ağacını(decision tree) göstermektedir. Bu kılavuzun geri kalanında bu yaklaşımlar ayrıntılı olarak açıklanmaktadır. Handle user events . Bu eventler, bir UI elementinin state’inin (örneğin, expandable bir itemin state’i) değiştirilmesiyle ilgiliyse, UI, kullanıcı eventlerini doğrudan handle edebilir. Event, ekrandaki verilerin yenilenmesi gibi business logicin yürütülmesini gerektiriyorsa ViewModel tarafından işlenmelidir. Aşağıdaki örnek, UI elementini genişletmek (UI logic) ve ekrandaki verileri yenilemek (business logic) için farklı butonlarin nasıl kullanıldığını gösterir: . // Views class LatestNewsActivity : AppCompatActivity() { private lateinit var binding: ActivityLatestNewsBinding private val viewModel: LatestNewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ // The expand details event is processed by the UI that // modifies a View's internal state. binding.expandButton.setOnClickListener { binding.expandedSection.visibility = View.VISIBLE } // The refresh event is processed by the ViewModel that is in charge // of the business logic. binding.refreshButton.setOnClickListener { viewModel.refreshNews() } } } //compose @Composable fun LatestNewsScreen(viewModel: LatestNewsViewModel = viewModel()) { // State of whether more details should be shown var expanded by remember { mutableStateOf(false) } Column { Text(\"Some text\") if (expanded) { Text(\"More details\") } Button( // The expand details event is processed by the UI that // modifies this composable's internal state. onClick = { expanded = !expanded } ) { val expandText = if (expanded) \"Collapse\" else \"Expand\" Text(\"$expandText details\") } // The refresh event is processed by the ViewModel that is in charge // of the UI's business logic. Button(onClick = { viewModel.refreshNews() }) { Text(\"Refresh data\") } } } . User Events in RecyclerViews . Action, bir RecyclerView iteminde veya custom bir Viewde olduğu gibi, UI ağacının daha aşağısında üretilirse, ViewModel yine de kullanıcı eventlerini handle eden olmalıdır. Örneğin, NewsActivity’den gelen tüm haber itemlerinin bir bookmark butonu içerdiğini varsayalım. ViewModel’in bookmark eklenmiş haber iteminin IDsini bilmesi gerekir. Kullanıcı bir haber öğesine bookmark koyduğunda, RecyclerView adapteri, ViewModel’e bağımlılık gerektirecek şekilde ViewModel’den açığa çıkan addBookmark(newsId) methodunu çağırmaz. Bunun yerine ViewModel, eventi handle etmek için implementasyonu içeren NewsItemUiState adlı bir state nesnesini gösterir: . data class NewsItemUiState( val title: String, val body: String, val bookmarked: Boolean = false, val publicationDate: String, val onBookmark: () -&gt; Unit ) class LatestNewsViewModel( private val formatDateUseCase: FormatDateUseCase, private val repository: NewsRepository ) { val newsListUiItems = repository.latestNews.map { news -&gt; NewsItemUiState( title = news.title, body = news.body, bookmarked = news.bookmarked, publicationDate = formatDateUseCase(news.publicationDate), // Business logic is passed as a lambda function that the // UI calls on click events. onBookmark = { repository.addBookmark(news.id) } ) } } . Bu şekilde, RecyclerView adapteri yalnızca ihtiyaç duyduğu verilerle çalışır: NewsItemUiState nesnelerinin listesi. Adapterin ViewModel’in tamamına erişimi yoktur, bu da ViewModel tarafından açığa çıkarılan fonksiyonaliteyi kötüye kullanma olasılığını azaltır. Yalnızca activity sınıfının ViewModel ile çalışmasına izin verdiğinizde, sorumlulukları ayırmış olursunuz. Bu, viewler veya RecyclerView adapterlari gibi UI’e özgü nesnelerin ViewModel ile doğrudan etkileşime girmemesini sağlar. Uyarı: ViewModel’i RecyclerView adapterina passlamak kötü bir uygulamadır çünkü adapteri ViewModel sınıfıyla sıkı bir şekilde birleştirir. Not: Diğer bir yaygın pattern, RecyclerView adapterinin kullanıcı eylemleri( actionlari) için bir callback interfaceine sahip olmasıdır. Bu durumda, activty veya fragment bindingi handle edebilir ve doğrudan callback interfaceinden ViewModel methodlarini çağırabilir. Naming conventions for user event functions . Bu kılavuzda, kullanıcı eventlerini handle eden ViewModel fonksiyonlari, gerçekleştirdikleri eyleme göre bir fiille adlandırılır; örneğin: addBookmark(id) veya logIn(username, password). Handle ViewModel Events . ViewModel’den kaynaklanan UI actionlari(ViewModel eventleri), her zaman bir UI state güncellemesiyle sonuçlanmalıdır. Bu, Tek Yönlü Veri Akışı(UDF) ilkelerine uygundur. Configuration changesden sonra eventleri yeniden üretilebilir hale getirir ve UI actionlarinin kaybolmayacağını garanti eder. İsteğe bağlı olarak, saved state modülünü kullanırsanız, eventleri process ölümünden sonra tekrarlanabilir hale getirebilirsiniz. UI actionlarini UI state’ine maplemek her zaman basit bir işlem değildir, ancak daha basit bir logice yol açar. Örneğin, düşünce süreciniz, UI’in belirli bir ekrana nasıl yönlendirileceğini belirlemekle bitmemelidir. Daha fazla düşünmeniz ve bu kullanıcı akışını UI state’inizde nasıl temsil edeceğinizi düşünmeniz gerekir. Başka bir deyişle: UI’in yapması gereken işlemleri düşünmeyin; bu actionlarinin UI state’ini nasıl etkilediğini düşünün. Anahtar Nokta: ViewModel eventleri her zaman bir UI state güncellemesiyle sonuçlanmalıdır. Örneğin, kullanıcı oturum açma ekranında oturum açtığında ana ekrana gitme durumunu düşünün. Bunu UI state’inde aşağıdaki gibi modelleyebilirsiniz: . data class LoginUiState( val isLoading: Boolean = false, val errorMessage: String? = null, val isUserLoggedIn: Boolean = false ) . Bu UI, isUserLoggedIn state’indeki değişikliklere tepki verir ve gerektiğinde doğru hedefe gider: . //views class LoginViewModel : ViewModel() { private val _uiState = MutableStateFlow(LoginUiState()) val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow() /* ... */ } class LoginActivity : AppCompatActivity() { private val viewModel: LoginViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { uiState -&gt; if (uiState.isUserLoggedIn) { // Navigate to the Home screen. } ... } } } } } //compose class LoginViewModel : ViewModel() { var uiState by mutableStateOf(LoginUiState()) private set /* ... */ } @Composable fun LoginScreen( viewModel: LoginViewModel = viewModel(), onUserLogIn: () -&gt; Unit ) { val currentOnUserLogIn by rememberUpdatedState(onUserLogIn) // Whenever the uiState changes, check if the user is logged in. LaunchedEffect(viewModel.uiState) { if (viewModel.uiState.isUserLoggedIn) { currentOnUserLogIn() } } // Rest of the UI for the login screen. } . Not: Bu bölümdeki kod örnekleri coroutinelerin ve bunların yaşam döngüsüne duyarlı bileşenlerle nasıl kullanılacağı nın anlaşılmasını gerektirir. Consuming events can trigger state updates . UI’de belirli ViewModel eventlerinin kullanılması, diğer UI state güncellemelerine neden olabilir. Örneğin, kullanıcıya bir şey olduğunu bildirmek için ekranda geçici mesajlar gösterilirken, mesaj ekranda gösterildiğinde UI’in ViewModel’e başka bir state güncellemesini tetiklemesi için bildirimde bulunması gerekir. Kullanıcı mesajı tükettiğinde (bırakarak veya bir zaman aşımından sonra) meydana gelen event, “user input” olarak ele alınabilir ve bu nedenle, ViewModel bunun farkında olmalıdır. Bu durumda, UI state aşağıdaki gibi modellenebilir: . // Models the UI state for the Latest news screen. data class LatestNewsUiState( val news: List&lt;News&gt; = emptyList(), val isLoading: Boolean = false, val userMessage: String? = null ) . ViewModel, business logic kullanıcıya yeni bir geçici mesaj gösterilmesini gerektirdiğinde UI state’ini aşağıdaki gibi günceller: . //Views class LatestNewsViewModel(/* ... */) : ViewModel() { private val _uiState = MutableStateFlow(LatestNewsUiState(isLoading = true)) val uiState: StateFlow&lt;LatestNewsUiState&gt; = _uiState fun refreshNews() { viewModelScope.launch { // If there isn't internet connection, show a new message on the screen. if (!internetConnection()) { _uiState.update { currentUiState -&gt; currentUiState.copy(userMessage = \"No Internet connection\") } return@launch } // Do something else. } } fun userMessageShown() { _uiState.update { currentUiState -&gt; currentUiState.copy(userMessage = null) } } } //compose class LatestNewsViewModel(/* ... */) : ViewModel() { var uiState by mutableStateOf(LatestNewsUiState()) private set fun refreshNews() { viewModelScope.launch { // If there isn't internet connection, show a new message on the screen. if (!internetConnection()) { uiState = uiState.copy(userMessage = \"No Internet connection\") return@launch } // Do something else. } } fun userMessageShown() { uiState = uiState.copy(userMessage = null) } } . ViewModel’in, UI’in mesajı ekranda nasıl gösterdiğini bilmesi gerekmez; sadece gösterilmesi gereken bir kullanıcı mesajı olduğunu bilir. Geçici mesaj gösterildikten sonra, UI’in bunu ViewModel’e bildirmesi gerekir ve başka bir UI state güncellemesinin userMessage propertysini temizlemesine neden olur: . //views class LatestNewsActivity : AppCompatActivity() { private val viewModel: LatestNewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { uiState -&gt; uiState.userMessage?.let { // TODO: Show Snackbar with userMessage. // Once the message is displayed and // dismissed, notify the ViewModel. viewModel.userMessageShown() } ... } } } } } //compose @Composable fun LatestNewsScreen( snackbarHostState: SnackbarHostState, viewModel: LatestNewsViewModel = viewModel(), ) { // Rest of the UI content. // If there are user messages to show on the screen, // show it and notify the ViewModel. viewModel.uiState.userMessage?.let { userMessage -&gt; LaunchedEffect(userMessage) { snackbarHostState.showSnackbar(userMessage) // Once the message is displayed and dismissed, notify the ViewModel. viewModel.userMessageShown() } } } . Mesaj geçici olsa da, UI state, zamanın her noktasında ekranda görüntülenenlerin aslına sadık bir temsilidir. Kullanıcı mesajı görüntülenir veya görüntülenmez. Not: Ekranda gösterilecek kullanıcı mesajlarının listesini içeren daha gelişmiş bir kullanım örneği için Jetsnack Compose örneğine bakın. Navigation Events . Consuming events can trigger state updates bölümü, kullanıcı mesajlarını ekranda görüntülemek için UI state’ini nasıl kullandığınızı ayrıntılarıyla açıklar. Navigasyon eventleri, bir Android uygulamasında da yaygın olarak görülen bir event türüdür. Event, kullanıcı bir butona dokunduğu için UI’de tetiklenirse, UI, navigation controller çağırarak veya eventi çağırana uygun şekilde composable olarak göstererek bununla ilgilenir. //views class LoginActivity : AppCompatActivity() { private lateinit var binding: ActivityLoginBinding private val viewModel: LoginViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ binding.helpButton.setOnClickListener { navController.navigate(...) // Open help screen } } } //compose @Composable fun LoginScreen( onHelp: () -&gt; Unit, // Caller navigates to the right screen viewModel: LoginViewModel = viewModel() ) { // Rest of the UI Button(onClick = onHelp) { Text(\"Get help\") } } . Data input, navigateden önce bazı business logic doğrulaması gerektiriyorsa, ViewModel’in bu durumu UI’a göstermesi gerekir. Kullanıcı arayüzü bu state değişikliğine tepki verir ve buna göre navigate eder. Handle ViewModel events section bölümü bu kullanım durumunu kapsar. İşte benzer bir kod: . //views class LoginActivity : AppCompatActivity() { private val viewModel: LoginViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { uiState -&gt; if (uiState.isUserLoggedIn) { // Navigate to the Home screen. } ... } } } } } //compose @Composable fun LoginScreen( onUserLogIn: () -&gt; Unit, // Caller navigates to the right screen viewModel: LoginViewModel = viewModel() ) { Button( onClick = { // ViewModel validation is triggered viewModel.login() } ) { Text(\"Log in\") } // Rest of the UI val lifecycle = LocalLifecycleOwner.current.lifecycle val currentOnUserLogIn by rememberUpdatedState(onUserLogIn) LaunchedEffect(viewModel, lifecycle) { // Whenever the uiState changes, check if the user is logged in and // call the `onUserLogin` event when `lifecycle` is at least STARTED snapshotFlow { viewModel.uiState } .filter { it.isUserLoggedIn } .flowWithLifecycle(lifecycle) .collect { currentOnUserLogIn() } } } . Yukarıdaki örnekte, current destination olan Login backstackde tutulmayacağından uygulama beklendiği gibi çalışır. Kullanıcılar geri basarlarsa geri dönemezler. Ancak bunun olabileceği durumlarda, çözüm ek logic gerektirecektir. Navigation events when the destination is kept in the back stack . Bir ViewModel, A ekranından B ekranına bir navigation event üreten bir state belirlediğinde ve A ekranı navigation backstack’nde tutulduğunda, otomatik olarak B’ye ilerlemeye devam etmemek için ek logice ihtiyacınız olabilir. Bunu implement etmek için, UI’in diğer ekrana gitmeyi düşünüp düşünmemesi gerektiğini gösteren ek bir state’e sahip olunması gerekir.Normalde, bu state UI’de tutulur çünkü Navigation logic, ViewModel ile değil, UI ile ilgilidir. Bunu göstermek için, aşağıdaki kullanım örneğini ele alalım. Diyelim ki uygulamanızın kayıt akışındasınız. Doğum tarihi doğrulama ekranında, kullanıcı bir tarih girdiğinde, kullanıcı “Continue” butonuna dokunduğunda tarih ViewModel tarafından doğrulanır. ViewModel, doğrulama logic’ini data katmanına devreder. Tarih geçerliyse, kullanıcı bir sonraki ekrana geçer. Ek bir özellik olarak, kullanıcılar bazı verileri değiştirmek istediklerinde farklı kayıt ekranları arasında gidip gelebilirler. Bu nedenle, kayıt akışındaki tüm destinationlar aynı backstackde tutulur. Bu gereksinimler göz önüne alındığında, bu ekranı aşağıdaki gibi uygulayabilirsiniz: . //views // Key that identifies the `validationInProgress` state in the Bundle private const val DOB_VALIDATION_KEY = \"dobValidationKey\" class DobValidationFragment : Fragment() { private var validationInProgress: Boolean = false private val viewModel: DobValidationViewModel by viewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) val binding = // ... validationInProgress = savedInstanceState?.getBoolean(DOB_VALIDATION_KEY) ?: false binding.continueButton.setOnClickListener { viewModel.validateDob() validationInProgress = true } viewLifecycleOwner.lifecycleScope.launch { launch { viewModel.uiState .flowWithLifecycle(viewLifecycleOwner.lifecycle) .collect { uiState -&gt; // Update other parts of the UI ... // If the input is valid and the user wants // to navigate, navigate to the next screen // and reset `validationInProgress` flag if (uiState.isDobValid &amp;&amp; validationInProgress) { validationInProgress = false navController.navigate(...) // Navigate to next screen } } } } return binding } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) outState.putBoolean(DOB_VALIDATION_KEY, validationInProgress) } } //compose class DobValidationViewModel(/* ... */) : ViewModel() { var uiState by mutableStateOf(DobValidationUiState()) private set } @Composable fun DobValidationScreen( onNavigateToNextScreen: () -&gt; Unit, // Caller navigates to the right screen viewModel: DobValidationViewModel = viewModel() ) { // TextField that updates the ViewModel when a date of birth is selected var validationInProgress by rememberSaveable { mutableStateOf(false) } Button( onClick = { viewModel.validateInput() validationInProgress = true } ) { Text(\"Continue\") } // Rest of the UI /* * The following code implements the requirement of advancing automatically * to the next screen when a valid date of birth has been introduced * and the user wanted to continue with the registration process. */ if (validationInProgress) { val lifecycle = LocalLifecycleOwner.current.lifecycle val currentNavigateToNextScreen by rememberUpdatedState(onNavigateToNextScreen) LaunchedEffect(viewModel, lifecycle) { // If the date of birth is valid and the validation is in progress, // navigate to the next screen when `lifecycle` is at least STARTED, // which is the default Lifecycle.State for the `flowWithLifecycle` operator. snapshotFlow { viewModel.uiState } .filter { it.isDobValid } .flowWithLifecycle(lifecycle) .collect { validationInProgress = false currentNavigateToNextScreen() } } } } . Doğum tarihi doğrulama, ViewModel’in sorumlu olduğu business logictir. ViewModel çoğu zaman bu logic’i data katmanına devreder. Kullanıcıyı bir sonraki ekrana yönlendirme mantığı, UI logictir çünkü bu gereksinimler, UI yapılandırmasına bağlı olarak değişebilir. Örneğin, aynı anda birden çok kayıt adımı gösteriyorsanız, bir tablette otomatik olarak başka bir ekrana ilerlemek istemeyebilirsiniz. Yukarıdaki koddaki validationInProgress değişkeni bu işlevi uygular ve UI’in doğum tarihi geçerli olduğunda ve kullanıcı aşağıdaki kayıt adımına devam etmek istediğinde otomatik olarak navigate edilip edilmeyeceğini belirler. Other Use Cases . UI event usecaseinizin UI state güncellemeleriyle çözülemeyeceğini düşünüyorsanız, uygulamanızda veri akışını yeniden gözden geçirmeniz gerekebilir. Aşağıdaki ilkeleri göz önünde bulundurun: . | Her sınıf sorumlu olduğu şeyi yapmalı, daha fazlasını değil. Kullanıcı arabirimi, navigation calls, click events ve izin istekleri alma gibi ekrana özgü davranış mantığından sorumludur. ViewModel, iş mantığını içerir ve sonuçları hiyerarşinin alt katmanlarından UI state’ine dönüştürür. | Eventin nereden kaynaklandığını düşünün. Bu kılavuzun başında sunulan decision tree’yi takip edin ve her sınıfın sorumlu olduğu konuyu halletmesini sağlayın. Örneğin, event kullanıcı arayüzünden geliyorsa ve bir navigate ile olayıyla sonuçlanıyorsa, o eventin kullanıcı arayüzünde handle edilmesi gerekir. Bazı logicler ViewModel’e devredilebilir, ancak eventin handle edilmesi tamamen ViewModel’e devredilemez. | Birden çok consumer varsa ve activitynin birden çok kez consume edilmesinden endişe ediyorsanız uygulama mimarinizi yeniden gözden geçirmeniz gerekebilir. Birden fazla concurrent consumure sahip olmak, tam olarak bir kez teslim edilen sözleşmenin garanti edilmesinin son derece zor hale gelmesine neden olur, bu nedenle karmaşıklık ve subtle behavior miktarı patlar. Bu sorunu yaşıyorsanız, bu endişeleri kullanıcı arabirimi ağacınızda yukarıya taşımayı düşünün; hiyerarşide daha üstte yer alan farklı bir entitye ihtiyacınız olabilir. | State’in ne zaman tüketilmesi gerektiğini bir düşünün. Belirli durumlarda, uygulama arka plandayken (örneğin, bir Toast gösterirken) state’i tüketmeye devam etmek istemeyebilirsiniz. Bu gibi durumlarda, kullanıcı arabirimi ön planda olduğunda state’i kullanmayı düşünün. | . Not: Bazı uygulamalarda, ViewModel eventlerinin Kotlin Channels veya diğer reactive streams kullanılarak kullanıcı arayüzüne maruz kaldığını görmüş olabilirsiniz. Producer (ViewModel) consumeri (UI—Compose veya Views) geride bıraktığında, bu çözümler bu eventlerin teslimini ve işlenmesini garanti etmez. Bu, geliştirici için gelecekte sorunlara neden olabilir ve aynı zamanda çoğu uygulama için kabul edilemez bir kullanıcı deneyimidir çünkü bu, uygulamayı tutarsız bir durumda bırakabilir, hatalara neden olabilir veya kullanıcı kritik bilgileri kaçırabilir. Bu durumlardan birindeyseniz, o tek seferlik ViewModel eventinin kullanıcı arayüzünüz için gerçekte ne anlama geldiğini tekrar düşünün. Bunları hemen handle edin ve UI state’ine indirin. UI state’i, UI’yi belirli bir zamanda daha iyi temsil eder, size daha fazla teslimat ve işleme garantisi verir, test edilmesi genellikle daha kolaydır ve uygulamanızın geri kalanıyla tutarlı bir şekilde entegre olur. Bazı kod örnekleriyle yukarıda bahsedilen API’leri neden kullanmamanız gerektiği hakkında daha fazla bilgi edinmek için ViewModel: One-off event antipatterns blog gönderisini okuyun. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events/#ui-events",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events/#ui-events"
  },"191": {
    "doc": "Ui events",
    "title": "Ui events",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events/"
  },"192": {
    "doc": "UI layer libraries",
    "title": "UI layer libraries",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/ui-layer-libraries/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/ui-layer-libraries/"
  },"193": {
    "doc": "Ui layer",
    "title": "Ui layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-layer/",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-layer/"
  },"194": {
    "doc": "Unicode and internationalization support",
    "title": "Unicode and internationalization support",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/unicode-and-internationalization-support/",
    
    "relUrl": "/docs/app-basics/app-resources/localization/unicode-and-internationalization-support/"
  },"195": {
    "doc": "Update UI components with NavigationUI",
    "title": "Update UI components with NavigationUI",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/update-ui-components-with-navigationui/",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/update-ui-components-with-navigationui/"
  },"196": {
    "doc": "Use Hilt with other Jetpack libraries",
    "title": "Use Hilt with other Jetpack libraries",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/use-hilt-with-other-jetpack-libraries/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/use-hilt-with-other-jetpack-libraries/"
  },"197": {
    "doc": "Use Kotlin coroutines with Lifecycle-aware components",
    "title": "Use Kotlin coroutines with Lifecycle-aware components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/use-kotlin-coroutines-with-lifecycle-aware-components/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/use-kotlin-coroutines-with-lifecycle-aware-components/"
  },"198": {
    "doc": "Using Dagger in Android apps",
    "title": "Using Dagger in Android apps",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-android-apps/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-android-apps/"
  },"199": {
    "doc": "Using Dagger in multi-module apps",
    "title": "Using Dagger in multi-module apps",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-multi-module-apps/",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-multi-module-apps/"
  },"200": {
    "doc": "Verify app links",
    "title": "Verify app links",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/verify-app-links/",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/verify-app-links/"
  },"201": {
    "doc": "View binding",
    "title": "View binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/view-binding/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/view-binding/"
  },"202": {
    "doc": "ViewModel APIs cheat sheet",
    "title": "ViewModel APIs cheat sheet",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-apis-cheat-sheet/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-apis-cheat-sheet/"
  },"203": {
    "doc": "ViewModels scoping APIs",
    "title": "ViewModels scoping APIs",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-scoping-apis/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-scoping-apis/"
  },"204": {
    "doc": "ViewModel",
    "title": "ViewModel",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel/"
  },"205": {
    "doc": "Work with observable data objects",
    "title": "Work with observable data objects",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/work-with-obserable-data-objects/",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/work-with-obserable-data-objects/"
  },"206": {
    "doc": "Working with the app",
    "title": "Working with the app",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/working-with-the-app/",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/working-with-the-app/"
  },"207": {
    "doc": "WorkManager",
    "title": "WorkManager",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/workmanager/",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/workmanager/"
  }
}
