{"0": {
    "doc": "About app architecture",
    "title": "About app architecture",
    "content": "Bu kılavuz, sağlam, yüksek kaliteli uygulamalar oluşturmak için best practiceleri ve önerilen mimariyi kapsar. Not: Bu sayfada Android Framework ile ilgili temel bilgilere sahip olduğunuz varsayılmaktadır. Android uygulama geliştirme konusunda yeniyseniz, başlamak ve bu kılavuzda bahsedilen kavramlar hakkında daha fazla bilgi edinmek için [Android Basics kursu](https://developer.android.com/courses/android-basics-kotlin/course) na göz atın. Mobile app user experiences . Tipik bir Android uygulaması, activities, fragments, services, content providers, and broadcast receivers dahil olmak üzere multiple app componentler içerir. Bu uygulama componentlerinin çoğunu app manifest dosyasinda bildirirsiniz. Android işletim sistemi daha sonra uygulamanızı cihazın genel kullanıcı deneyimine nasıl entegre edeceğine karar vermek için bu dosyayı kullanır. Tipik bir Android uygulamasının multiple component içerebileceği ve kullanıcıların genellikle kısa bir süre içinde birden çok uygulamayla etkileşime girdiği göz önüne alındığında, uygulamaların farklı türde kullanıcı odaklı iş akışlarına(user-driven workflows) ve tasklere uyum sağlaması gerekir. Mobil cihazlarda kaynaklarin kısıtlı olduğunu unutmayın; bu nedenle, işletim sistemi herhangi bir zamanda yenilerine yer açmak için bazı uygulama processlerini sonlandırabilir. Bu ortamın koşulları göz önüne alındığında, uygulama componentlerinizin ayrı ayrı ve duzensiz olarak başlatılması mümkündür ve işletim sistemi veya kullanıcı bunları herhangi bir zamanda sonlandirabilir. Bu olaylar sizin kontrolünüz altında olmadığından, uygulama componentlerinizdeki herhangi bir uygulama verisini veya state’ini saklamamalı veya bellekte tutmamalısınız ve uygulama componentleriniz birbirine bağimlı olmamalıdır. Common architectural principles . Uygulama verilerini ve state’ini tutumak için uygulama componentlerini kullanmamanız gerekiyorsa,peki uygulamanızı nasıl tasarlamanız gerekir? Android uygulamalarının boyutu büyüdükçe, uygulamanın ölçeklenmesini sağlayan, uygulamanın sağlamlığını artıran ve uygulamanın test edilmesini kolaylaştıran bir mimari tanımlamak önemlidir. Bir uygulama mimarisi, uygulamanın bölümleri arasındaki sınırları ve her bir bölümün sahip olması gereken sorumlulukları tanımlar. Yukarıda belirtilen ihtiyaçları karşılamak için uygulama mimarinizi birkaç belirli ilkeyi takip edecek şekilde tasarlamanız gerekir. Separation of concerns . İzlenecek en önemli ilke, separation of concers. Tüm kodunuzu bir Activity veya Fragment’a yazmak yaygın bir hatadır. Bu UI tabanlı sınıflar yalnızca UI ve işletim sistemi interactionlarini handle eden mantığı(logic) içermelidir. Bu sınıfları olabildiğince yalın tutarak, component yaşam döngüsüyle(lifecycle) ilgili birçok sorunu önleyebilir ve bu sınıfların test edilebilirliğini kolaylastirabilirsiniz. Aktivite ve Fragment implementasyonlari uzerinde bir sahipliginiz olmadığını unutmayın; bunlar yalnızca Android işletim sistemi ile uygulamanız arasındaki sözleşmeyi temsil eden glue classlardir. İşletim sistemi, kullanıcı etkileşimlerine bağlı olarak veya düşük bellek gibi sistem koşulları nedeniyle herhangi bir zamanda bunları yok edebilir. Tatmin edici bir kullanıcı deneyimi ve daha yönetilebilir bir uygulama bakım deneyimi sağlamak için bunlara bağımlılığınızı en aza indirmek en iyisidir. Drive UI from data models . Bir diğer önemli ilke, kullanıcı arayüzünüzü(UI) data modellerinden, tercihen kalıcı(persistent) modellerden olusturmaniz gerektiğidir. Data modelleri, bir uygulamanın verilerini temsil eder. Uygulamanızdaki UI öğelerinden ve diğer componentlerden bağımsızdırlar. Bu, kullanıcı arayüzüne ve uygulama bileşeni yaşam döngüsüne bağlı olmadıkları, ancak işletim sistemi uygulamanın sürecini bellekten kaldırmaya karar verdiğinde yine de yok edilecekleri anlamına gelir. Kalıcı modeller aşağıdaki nedenlerle idealdir: . | Android işletim sistemi, kaynakları boşaltmak için uygulamanızı yok ederse, kullanıcılarınız veri kaybetmez. | Uygulamanız, ağ bağlantısının kesintili olduğu veya kullanılamadığı durumlarda çalışmaya devam eder. | . Uygulama mimarinizi data model sınıflarına(viewmodel gibi) dayandırırsanız, uygulamanızı daha test edilebilir ve sağlam hale getirirsiniz. Single source of truth . Uygulamanızda yeni bir veri türü tanımlandığında, ona Tek Doğruluk Kaynağı (SSOT) atamanız gerekir. SSOT, bu verilerin sahibidir ve yalnızca SSOT onu modifiye edebilir veya değiştirebilir. Bunu başarmak için SSOT, immutable bir tip kullanarak verileri ortaya çıkarır ve verileri değiştirmek için SSOT, diğer tiplerin çağırabileceği fonksiyonlari ortaya çıkarır veya eventleri receive eder. Bu model birden fazla fayda sağlar: . | Belirli bir veri türündeki tüm değişiklikleri tek bir yerde merkezileştirir. | Diğer tiplerin kurcalamaması için verileri korur. | Verilerdeki değişiklikleri daha izlenebilir hale getirir. Böylece buglarin fark edilmesi daha kolaydır. | . Offline-first bir uygulamada, uygulama verilerinin doğruluğunun kaynağı(ssot) tipik olarak bir veritabanıdır. Diğer bazı durumlarda, kaynak bir ViewModel veya hatta UI olabilir. Unidirectional Data Flow . Doğruluğun tek kaynağı ilkesi(single source of truth principle(ssot)), Tek Yönlü Veri Akışı (UDF) modeliyle birlikte kılavuzlarımızda sıklıkla kullanılmaktadır. UDF’de state sadece bir yönde akar. Event ise veri akışını ters yönde değiştirendir. Android’de, state veya veriler genellikle hiyerarşinin yüksek scope türlerinden daha düşük scope türlere doğru akar. Eventler, ilgili veri türü için SSOT’a ulaşana kadar genellikle daha düşük scope türlerden tetiklenir. Örneğin, uygulama verileri genellikle veri kaynaklarından kullanıcı arayüzüne akar. Button basmaları gibi kullanıcı eventleri, uygulama verilerinin değiştirildiği ve immutable bir türde gösterildiği UI’den SSOT’a akar. Bu pattern, veri tutarlılığını daha iyi garanti eder, hatalara daha az eğilimlidir, hata ayıklaması(debug) daha kolaydır ve SSOT patterinin tüm avantajlarını beraberinde getirir . Recommended app architecture . Bu bölüm, önerilen best practiseleri izleyerek uygulamanızı nasıl yapılandıracağınızı gösterir. Not: Bu sayfada sunulan öneriler ve best practiseler, ölçeklenmelerine, kalite ve sağlamlığı artırmalarına ve test edilmelerini kolaylaştırmalarına olanak sağlamak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Bahsedilen ortak mimari ilkeler göz önüne alındığında, her uygulamada en az iki katman olmalıdır: . | Uygulama verilerini ekranda görüntüleyen UI layer. | Uygulamanızın iş mantığını(business logic) içeren ve uygulama verilerini ortaya çıkaran data layer. | . Kullanıcı arabirimi(UI) ve veri katmanları arasındaki etkileşimleri basitleştirmek ve yeniden kullanmak için domain layer adı verilen ek bir katman ekleyebilirsiniz. Tipik bir uygulama mimari diagrami bu sekilde gorunur. Not:Buradaki oklar katmanlar arasi bagimliliklari gostermektedir. Mesela domain layer, data layer a bagimlidir. Modern App Architecture . Bu Modern App Architecture, diğerlerinin yanı sıra aşağıdaki tekniklerin kullanılmasını teşvik eder: . | Reaktif ve katmanlı bir mimari. | Uygulamanın tüm katmanlarında Tek Yönlü Veri Akışı (UDF). | UI’nin karmaşıklığını yönetmek için state holder’ları olan bir UI layer’ı. | Coroutine’ler ve flow’lar. | Dependency injection best practiceleri. | . Daha fazla bilgi için aşağıdaki bölümlere, içindekiler tablosundaki diğer Architecture sayfalarına ve en önemli best practice’lerin bir özetini içeren öneriler sayfasına bakın. UI Layer . UI katmanının (veya presentation katmanının) rolü, uygulama verilerini ekranda görüntülemektir. Veriler, kullanıcı etkileşimi(user interaction) (bir butona basmak gibi) veya external input(network response gibi) nedeniyle değiştiğinde, UI değişiklikleri yansıtacak şekilde güncellenmelidir. UI katmanı iki şeyden oluşur: . | Ekrandaki verileri handle eden UI elementleri. Bu öğeleri Views veya Jetpack Compose fonksiyonlarini kullanarak oluşturursunuz. | Verileri tutan, kullanıcı arayüzüne(UI) sunan ve mantığı(logic) handle eden state holderlar (ViewModel sınıfları gibi). | . Bu katman hakkında daha fazla bilgi edinmek için UI layer sayfasına bakın. Data Layer . Bir uygulamanın veri katmanı, iş mantığını(business logic) içerir. İş mantığı, uygulamanıza değer veren şeydir; uygulamanızın verileri nasıl oluşturduğunu, depoladığını ve değiştirdiğini belirleyen kurallardan oluşur. Veri katmanı, her biri sıfır ila birçok veri kaynağı içerebilen repositorylerden oluşur. Uygulamanızda handle edilen her farklı veri türü için bir repository sınıfı oluşturmalısınız. Örneğin, filmlerle ilgili veriler için bir MoviesRepository sınıfı veya ödemelerle ilgili veriler için bir PaymentsRepository sınıfı oluşturabilirsiniz. Repository sınıfları aşağıdaki görevlerden sorumludur: . | Verileri uygulamanın geri kalanına göstermek. | Verilerdeki değişiklikleri merkezileştirmek. | Birden çok veri kaynağı arasındaki çakışmaları çözmek. | Uygulamanın geri kalanından veri kaynaklarını soyutlamak. | Business logic içermek. | . Her veri kaynağı sınıfı(data source class), yalnızca tek bir veri kaynağıyla çalışma sorumluluğuna sahip olmalıdır ; bu veri kaynaklari dosya, ağ kaynağı(network source) veya yerel veritabanı(local database) olabilir. Veri kaynağı sınıfları, veri işlemleri için uygulama ile sistem arasındaki köprüdür. Bu katman hakkında daha fazla bilgi edinmek için data layer sayfasına bakın. Domain Layer . Domain katmanı(domain layer), kullanıcı arayüzü(UI layer) ve veri katmanları(data layer) arasında bulunan isteğe bağlı bir katmandır. Domain katmanı, karmaşık business logic’in veya birden fazla ViewModel tarafından yeniden kullanılan basit business logic’in enkapsüle edilmesinden sorumludur. Bu katman isteğe bağlıdır çünkü tüm uygulamalar bu gereksinimlere sahip olmayacaktır. Yalnızca gerektiğinde, örneğin karmaşıklığı yönetmek veya yeniden kullanılabilirliği desteklemek için kullanmalısınız. Bu katmandaki sınıflara yaygın olarak use case veya interactors denir. Her use case`in tek bir fonksiyonalite üzerinde sorumluluğu olmalıdır. Örneğin, birden fazla ViewModels, ekranda doğru mesajı görüntülemek için saat dilimlerine ihtiyac duyuyorsa, uygulamanız bir GetTimeZoneUseCase sınıfına sahip olabilir. Bu katman hakkında daha fazla bilgi edinmek için domain layer sayfasına bakın. Manage dependencies between components . Uygulamanızdaki sınıflar, düzgün çalışması için diğer sınıflara bağlıdır. Belirli bir sınıfın bağımlılıklarını toplamak için aşağıdaki design patternlerinden birini kullanabilirsiniz: . Dependency Injection: siniflarin bagimliliklarini olusturmadan tanimlamalarina izin verir. Runtime’da , bu bagimliliklari saglamaktan baska bir sinif sorumludur. Service Locater: siniflarin bagimliliklarini olusturmak yerine elde edebilecekleri registry saglar. Bu patternler, kodu çoğaltmadan veya karmaşıklık eklemeden bağımlılıkları yönetmek için clear pattern sağladıkları için kodunuzu ölçeklendirmenize olanak tanır. Ayrıca bu patternler, test ve production implementasyonlari arasında hızla geçiş yapmanızı sağlar. Android official olarak dependency leri yonetmek icin HILT librarysini onermektedir. Hilt, bağımlılık ağacında dolaşarak nesneleri otomatik olarak oluşturur, bağımlılıklara ilişkin derleme zamanı garantileri sağlar ve Android çerçeve sınıfları için bağımlılık containerlari oluşturur. General Best Practices . Programlama yaratıcı bir alandır ve Android uygulamaları oluşturmak da bir istisna değildir. Bir sorunu çözmenin birçok yolu vardır; verileri birden fazla activity veya fragment arasında iletebilir, uzaktaki verileri alıp offline mod için local olarak tutabilir veya basit olmayan uygulamaların karşılaştığı diğer yaygın senaryoları ele alabilirsiniz. Aşağıdaki öneriler zorunlu olmamakla birlikte, çoğu durumda bunları uygulamak kod tabanınızı uzun vadede daha sağlam, test edilebilir ve sürdürülebilir hale getirir: . Don`t store data in app components. Uygulamanizin activitileri, servisleri ve broadcast receiverlari gibi entry pointlerini veri kaynagi olarak belirlemekten kacinin. Veri kaynagi olarak belirlemek yerine o entry pointler ilgili veri alt kumelerini geri almak icin diger comoponentler ile koordine olmalidir. Her uygulama componenti, kullanıcının cihazıyla etkileşimine ve sistemin genel mevcut durumuna bağlı olarak oldukça kısa ömürlüdür. Reduce dependencies on Android classes. Uygulama componentleriniz, Context veya Toast gibi Android framework SDK API’lerine dayanan tek sınıf olmalıdır. Uygulamanızdaki diğer sınıfları onlardan soyutlamak, test edilebilirliğe yardımcı olur ve uygulamanızdaki coupling i azaltır. Create well-defined boundaries(sinirlari) of responsibility between various(cesitli) modules in your app. Örneğin, ağdan veri yükleyen kodu kod tabanınızdaki birden fazla sınıfa veya pakete yaymayın. Benzer şekilde, aynı sınıfta data caching ve data binding gibi birden fazla ilgisiz sorumluluk tanımlamayın. Önerilen uygulama mimarisini takip etmek bu konuda size yardımcı olacaktır. Modüllere mümkün olduğunca az maruz kalın.( Expose as little as possible from each module.) . Örneğin, bir modülden dahili bir implementasyon ayrıntısını ortaya cikaran bir kısayol oluşturmaya cezbedilmeyin. Kısa vadede biraz zaman kazanabilirsiniz, ancak code baseniz geliştikçe birçok kez teknik borçla karşılaşmanız olasıdır. Focus on the unique core of your app so it stands out from other apps. Ayni boilerplate(basmakalip) kodu tekrar tekrar yazarak tekerlegi yeniden icat etmeye gerek yoktur. Bunun yerine, zamanınızı ve enerjinizi uygulamanızı benzersiz kılan şeylere odaklayın ,Jetpack kutuphanelerinin ve önerilen diğer kutuphanelerin tekrar eden boilerplateleri handle etmesine izin verin. Consider how to make each part of your app testable in isolation.(Uygulamanizin her parcasini nasil ayri ayri test edilebilir hale gelecegini dusunun ) . Örneğin, ağdan veri almak için iyi tanımlanmış bir API’ye sahip olmak, bu verileri yerel bir veritabanında tutan modülün test edilmesini kolaylaştırır. Bunun yerine, bu iki modülün mantığını tek bir yerde mixlerseniz veya ağ kodunuzu tüm cade base e dağıtırsanız, etkili bir şekilde test etmek çok daha zor - imkansız değilse de - olur. Tipler, eşzamanlılık(concurrency) ilkelerinden sorumludur. Bir tip long-running blocking işi yapıyorsa, bu computation’u doğru thread e taşımaktan sorumlu olmalıdır. Bu belirli tip, yaptığı hesaplamanın tipini ve hangi threadde yürütülmesi gerektiğini bilir. Tipler main thread için main safe olmalıdır, yani bloklanmadan main threadden safe call etmektir. Mümkün olduğu kadar alakalı ve yeni verilerde ısrar edin. Bu şekilde kullanıcılar, cihazları çevrimdışı moddayken bile uygulamanızın işlevselliğinin keyfini çıkarabilir. Tüm kullanıcılarınızın sürekli, yüksek hızlı bağlantıya sahip olmadığına, sahip olsalar bile kalabalık yerlerde kötü sinyal alabileceklerini unutmayın. Benefits of Architecture (Mimarinin faydalari) . Uygulamanızda iyi bir Mimarinin uygulanması, proje ve mühendislik ekiplerine birçok fayda sağlar: . | Uygulamanin genel gidisatini, sürdürülebilirliğini, kalitesini ve sağlamlığını artırır. | Uygulamanın ölçeklenmesini sağlar. Daha fazla kişi ve daha fazla takim, minimum kod çakışmasıyla aynı code base e katkıda bulunabilir. | Alışmaya yardımcı olur. Mimari projenize tutarlılık katarken, ekibin yeni üyeleri hızla hızlanabilir ve daha kısa sürede daha verimli olabilir. | Test etmek daha kolaydır. İyi bir Mimari, genellikle test edilmesi daha kolay olan daha basit türleri teşvik eder. | Buglar, iyi tanımlanmış süreçlerle metodik olarak araştırılabilir. | . Mimariye yatırım yapmanın kullanıcılarınız üzerinde de doğrudan bir etkisi vardır. Daha istikrarlı bir uygulamadan ve daha üretken bir mühendislik ekibi sayesinde daha fazla özellikten faydalanırlar. Bununla birlikte, Mimari aynı zamanda öncelikli bir zaman yatırımı gerektirir. Bu zamanı şirketinizin geri kalanına gerekçelendirmenize yardımcı olması için, diğer şirketlerin uygulamalarında iyi bir mimariye sahip olduklarında başarı hikayelerini paylaştıkları bu vaka çalışmalarına bir göz atın. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/about-app-architecture.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/about-app-architecture.html"
  },"1": {
    "doc": "About app links",
    "title": "About app links",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/about-app-links.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/about-app-links.html"
  },"2": {
    "doc": "About app manifests",
    "title": "About app manifests",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/about-app-manifests.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/about-app-manifests.html"
  },"3": {
    "doc": "About app resources",
    "title": "About app resources",
    "content": " ",
    "url": "/docs/app-basics/app-resources/about-app-resources.html",
    
    "relUrl": "/docs/app-basics/app-resources/about-app-resources.html"
  },"4": {
    "doc": "About app shortcuts",
    "title": "About app shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/about-app-shortcuts.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/about-app-shortcuts.html"
  },"5": {
    "doc": "About data binding",
    "title": "About data binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/about-data-binding.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/about-data-binding.html"
  },"6": {
    "doc": "About dependency injection",
    "title": "About dependency injection",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/about-dependency-injection.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/about-dependency-injection.html"
  },"7": {
    "doc": "About fragments",
    "title": "About fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/about-fragments.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/about-fragments.html"
  },"8": {
    "doc": "About modularization",
    "title": "About modularization",
    "content": " ",
    "url": "/docs/app-architecture/modularization/about-modularization.html",
    
    "relUrl": "/docs/app-architecture/modularization/about-modularization.html"
  },"9": {
    "doc": "About Paging 2",
    "title": "About Paging 2",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/about-paging-2.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/about-paging-2.html"
  },"10": {
    "doc": "About paging",
    "title": "About paging",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/about-paging.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/about-paging.html"
  },"11": {
    "doc": "About resource types",
    "title": "About resource types",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/about-resource-types.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/about-resource-types.html"
  },"12": {
    "doc": "About the data layer",
    "title": "Data Layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer.html#data-layer",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer.html#data-layer"
  },"13": {
    "doc": "About the data layer",
    "title": "About the data layer",
    "content": "UI katmanı UI ile ilgili state ve UI logic’i içerirken, data katmanı uygulama verilerini ve business logic’i içerir. Business logic (iş mantığı) uygulamanıza değer katan şeydir; uygulama verilerinin nasıl oluşturulması, saklanması ve değiştirilmesi gerektiğini belirleyen gerçek dünya iş kurallarından oluşur. Separation of concerns ilkesinin bu sekilde olması, veri katmanının birden fazla ekranda kullanılmasına, uygulamanın farklı bölümleri arasında bilgi paylaşılmasına ve birim testi için iş mantığının kullanıcı arayüzünün dışında yeniden üretilmesine olanak tanır. Data katmanının faydaları hakkında daha fazla bilgi için Architecture Overview sayfasına göz atın. ot: Bu sayfada yer alan öneriler ve best practiceler, ölçeklenmelerini sağlamak, kaliteyi ve sağlamlığı artırmak ve test edilmelerini kolaylaştırmak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Architecture: The data layer - MAD Skills . Data layer architecture . Data katmanı, her biri sıfır ila çok sayıda veri kaynağı içerebilen repository’lerden oluşur. Uygulamanızda işlediğiniz her farklı veri türü için bir repository sınıfı oluşturmalısınız. Örneğin, filmlerle ilgili veriler için bir MoviesRepository sınıfı veya ödemelerle ilgili veriler için bir PaymentsRepository sınıfı oluşturabilirsiniz. Repository sınıfları aşağıdaki görevlerden sorumludur: . | Verilerin uygulamanın geri kalanına sunulması. | Verilerdeki değişiklikleri merkezileştirme. | Birden fazla veri kaynağı arasındaki çakışmaları çözme. | Uygulamanın geri kalanından veri kaynaklarını soyutlama. | Business logic’i içermek. | . Her veri kaynağı sınıfı(data source class) , bir dosya, bir network kaynağı veya local veritabanı olabilen sadece tek bir veri kaynağı ile çalışma sorumluluğuna sahip olmalıdır. Veri kaynağı sınıfları, veri işlemleri için uygulama ile sistem arasındaki köprüdür. Hiyerarşideki diğer katmanlar veri kaynaklarına asla doğrudan erişmemelidir; data katmanına entry pointler her zaman repository sınıflarıdır. State holder sınıfları (UI katmanı kılavuzuna bakın) veya use case sınıfları (domain katmanı kılavuzuna bakın) hiçbir zaman doğrudan bir bağımlılık olarak bir veri kaynağına sahip olmamalıdır. Repository sınıflarının entry point olarak kullanılması, mimarinin farklı katmanlarının bağımsız olarak ölçeklenebilmesini sağlar. Bu katman tarafından açığa çıkarılan veriler immutable olmalıdır, böylece diğer sınıflar tarafından kurcalanamaz, bu da değerlerini tutarsız bir duruma sokma riski taşır. Immutable veriler birden fazla thread tarafından da güvenli bir şekilde işlenebilir. Daha fazla ayrıntı için thread bölümüne bakın. Dependency injection best practices‘i takiben, repository veri kaynaklarını constructor’ında dependency olarak alır: . class ExampleRepository( private val exampleRemoteDataSource: ExampleRemoteDataSource, // network private val exampleLocalDataSource: ExampleLocalDataSource // database ) { /* ... */ } . Not: Genellikle, bir repository yalnızca tek bir veri kaynağı içerdiğinde ve diğer repository'lere bağlı olmadığında, geliştiriciler repository'lerin ve veri kaynaklarının sorumluluklarını repository sınıfında birleştirir. Bunu yaparsanız, uygulamanızın sonraki bir sürümünde repository'nin başka bir kaynaktan gelen verileri işlemesi gerekiyorsa fonksiyonları bölmeyi unutmayın. Expose APIs . Data katmanındaki sınıflar genellikle tek seferlik Create, Read, Update ve Delete (CRUD) çağrıları gerçekleştirmek veya zaman içindeki veri değişikliklerinden haberdar olmak için fonksiyonları kullanıma sunar. Data katmanı bu durumların her biri için aşağıdakileri sağlamalıdır: . | Tek seferlik işlemler: Data katmanı Kotlin’de suspend fonksiyonlarını kullanıma sunmalıdır; ve Java programlama dili için, data katmanı işlemin sonucunu bildirmek için bir callback sağlayan fonksiyonları veya RxJava Single, Maybe veya Completable tiplerini kullanıma sunmalıdır. | Zaman içindeki veri değişikliklerinden haberdar olmak için: Data katmanı Kotlin’de flow‘ları kullanıma sunmalıdır; ve Java programlama dili için data katmanı yeni veriyi veya RxJava Observable veya Flowable türünü yayınlayan bir callback’i kullanıma sunmalıdır. | . class ExampleRepository( private val exampleRemoteDataSource: ExampleRemoteDataSource, // network private val exampleLocalDataSource: ExampleLocalDataSource // database ) { val data: Flow&lt;Example&gt; = ... suspend fun modifyData(example: Example) { ... } } . Naming conventions in this guide . Bu kılavuzda, repository sınıfları sorumlu oldukları verilere göre adlandırılmıştır. Kurallar aşağıdaki gibidir: . veri türü + Repository. Örneğin: NewsRepository, MoviesRepository veya PaymentsRepository. Veri kaynağı sınıfları, sorumlu oldukları verilerden ve kullandıkları kaynaktan sonra adlandırılır. Kurallar aşağıdaki gibidir: . veri türü + kaynak türü + DataSource. Veri türü için, uygulamalar değişebileceğinden daha genel olması için Remote veya Local kullanın. Örneğin: NewsRemoteDataSource veya NewsLocalDataSource. Kaynağın önemli olması durumunda daha spesifik olmak için kaynağın türünü kullanın. Örneğin: NewsNetworkDataSource veya NewsDiskDataSource. Veri kaynağını bir uygulama detayına göre adlandırmayın (örneğin UserSharedPreferencesDataSource) çünkü bu veri kaynağını kullanan repository’ler verilerin nasıl kaydedildiğini bilmemelidir. Bu kurala uyarsanız, veri kaynağının uygulamasını, bu kaynağı çağıran katmanı etkilemeden değiştirebilirsiniz ( örneğin, SharedPreferences’ tan DataStore‘a geçiş). Not: Bir veri kaynağının yeni bir implementasyonuna geçerken, veri kaynağı için bir interface oluşturabilir ve veri kaynağının iki implementasyonuna sahip olabilirsiniz: biri eski backing teknolojisi için, diğeri de yenisi için. Bu durumda, veri kaynağı sınıf adları için teknolojinin adını kullanmanızda bir sakınca yoktur (bu bir uygulama ayrıntısı olsa bile) çünkü repository veri kaynağı sınıflarının kendisini değil yalnızca interface'i görür. Taşıma işlemini tamamladığınızda, yeni sınıfı, adında uygulama ayrıntısı içermeyecek şekilde yeniden adlandırabilirsiniz. Multiple levels of repositories . Daha karmaşık iş gereksinimlerini içeren bazı durumlarda, bir repository’nin diğer repository’lere bağımlı olması gerekebilir. Bunun nedeni, ilgili verilerin birden fazla veri kaynağından toplanması veya sorumluluğun başka bir repository sınıfında encapsulated edilmesi gerekliligi olabilir. Örneğin, kullanıcı kimlik doğrulama verilerini işleyen bir repository, UserRepository, gereksinimlerini yerine getirmek için LoginRepository ve RegistrationRepository gibi diğer repository’lere bağımlı olabilir. Not: Geleneksel olarak, bazı geliştiriciler diğer repository sınıflarına bağlı olan repository sınıflarını manager olarak adlandırırlar; örneğin UserRepository yerine UserManager. İsterseniz bu adlandırma kuralını kullanabilirsiniz. Source of truth . Her repository’nin tek bir doğruluk kaynağı(single source of truth) tanımlaması önemlidir. Doğruluk kaynağı her zaman tutarlı, doğru ve güncel veriler içerir. Aslında, repository’den açığa çıkan veriler her zaman doğrudan doğruluk kaynağından gelen veriler olmalıdır. Doğruluk kaynağı bir veri kaynağı (örneğin veri tabanı) ya da repository’nin içerebileceği bir in-memory cache olabilir. Repository’ler farklı veri kaynaklarını birleştirir ve veri kaynakları arasındaki olası çakışmaları çözerek tek doğruluk kaynağını düzenli olarak veya bir user input event nedeniyle günceller. Uygulamanızdaki farklı veri repositoryleri farklı doğruluk kaynaklarına sahip olabilir. Örneğin, LoginRepository sınıfı doğruluk kaynağı olarak cache’ini kullanabilir ve PaymentsRepository sınıfı network veri kaynağını kullanabilir. Offline-first desteği sağlamak için, veritabanı gibi local bir veri kaynağı önerilen doğruluk kaynağıdır. Threading . Veri kaynaklarını ve repository’leri çağırmak, main thread’den çağırmak için main-safe/güvenli olmalıdır. Bu sınıflar, uzun süreli bloklama operasyonları gerçekleştirirken logiclerinin yürütülmesini uygun thread’e taşımaktan sorumludur. Örneğin, bir veri kaynağının bir dosyadan okuma yapması ya da bir veri repository’sinin büyük bir liste üzerinde yüklü filtreleme yapması main-safe olmalıdır. Çoğu veri kaynağının Room, Retrofit veya Ktor tarafından sağlanan suspend metot çağrıları gibi main-safe API’leri zaten sağladığını unutmayın. Repositoryniz, kullanılabilir olduklarında bu API’lerden yararlanabilir. Threading hakkında daha fazla bilgi edinmek için background processing kılavuzuna bakın. Kotlin kullanıcıları için coroutine’ler önerilen seçenektir. Java programlama dili için önerilen seçenekler için Android task’larını background thread’lerde çalıştırma bölümüne bakın. Lifecycle . Data katmanındaki sınıfların instance’ları, bir garbage collection root’undan (genellikle uygulamanızdaki diğer nesnelerden referans alınarak) erişilebilir oldukları sürece bellekte kalırlar. Bir sınıf in-memory veriler içeriyorsa (örneğin bir cache), bu sınıfın aynı instance’ını belirli bir süre için yeniden kullanmak isteyebilirsiniz. Bu, sınıf instance’ının yaşam döngüsü olarak da adlandırılır. Sınıfın sorumluluğu tüm uygulama için çok önemliyse, bu sınıfın bir instance’ını Application sınıfına scope edebilirsiniz. Bu, instance’ın uygulamanın yaşam döngüsünü takip etmesini sağlar. Alternatif olarak, aynı instance’ı yalnızca uygulamanızdaki belirli bir akışta (örneğin, kayıt veya oturum açma akışı) yeniden kullanmanız gerekiyorsa, instance’ı bu akışın yaşam döngüsüne sahip olan sınıfa scope etmelisiniz. Örneğin, in-memory veriler içeren bir RegistrationRepository’yi RegistrationActivity’ye veya kayıt akışının navigation graph’ine scope edebilirsiniz. Her bir instance’ın yaşam döngüsü, uygulamanızda bağımlılıkları nasıl sağlayacağınıza karar vermede kritik bir faktördür. Bağımlılıkların yönetildiği ve bağımlılık contaitnerlarina scop edilebildiği dependency injection best practicelerini takip etmeniz önerilir. Android’de scoping hakkında daha fazla bilgi edinmek için Android’de Scoping ve Hilt blog gönderisine bakın. Represent business models . Data katmanından göstermek istediğiniz veri modelleri, farklı veri kaynaklarından aldığınız bilgilerin bir alt kümesi olabilir. İdeal olarak, farklı veri kaynakları (hem network hem de local) yalnızca uygulamanızın ihtiyaç duyduğu bilgileri döndürmelidir; ancak durum genellikle böyle değildir. Örneğin, yalnızca makale bilgilerini değil, aynı zamanda düzenleme geçmişini, kullanıcı yorumlarını ve bazı meta verileri de döndüren bir News API sunucusu düşünün: . data class ArticleApiModel( val id: Long, val title: String, val content: String, val publicationDate: Date, val modifications: Array&lt;ArticleApiModel&gt;, val comments: Array&lt;CommentApiModel&gt;, val lastModificationDate: Date, val authorId: Long, val authorName: String, val authorDateOfBirth: Date, val readTimeMin: Int ) . Uygulama, makale hakkında çok fazla bilgiye ihtiyaç duymaz çünkü ekranda yalnızca makalenin içeriğini ve yazarıyla ilgili temel bilgileri görüntüler. Model sınıflarını ayırmak ve repository’lerinizin yalnızca hiyerarşinin diğer katmanlarının ihtiyaç duyduğu verileri göstermesini sağlamak iyi bir pratiktir. Örneğin, bir Article model sınıfını domain ve UI katmanlarına göstermek için ArticleApiModel’i ağdan şu şekilde kırpabilirsiniz: . data class Article( val id: Long, val title: String, val content: String, val publicationDate: Date, val authorName: String, val readTimeMin: Int ) . Model sınıflarını ayırmak aşağıdaki şekillerde faydalıdır: . | Verileri yalnızca ihtiyaç duyulana indirgeyerek uygulama belleğinden tasarruf sağlar. | Harici veri türlerini uygulamanız tarafından kullanılan veri türlerine uyarlar - örneğin, uygulamanız tarihleri temsil etmek için farklı bir veri türü kullanabilir. | Separation of concers ilkesini daha iyi sağlar; örneğin, model sınıfı önceden tanımlanırsa büyük bir ekibin üyeleri bir feature’in network ve UI katmanları üzerinde ayrı ayrı çalışabilir. | . Bu pratiği genişletebilir ve uygulama mimarinizin diğer bölümlerinde de ayrı model sınıfları tanımlayabilirsiniz; örneğin veri kaynağı sınıflarında ve ViewModel’lerde. Ancak bu, düzgün bir şekilde belgelemeniz ve test etmeniz gereken ekstra sınıflar ve logic tanımlamanızı gerektirir. En azından, bir veri kaynağının uygulamanızın geri kalanının beklediği verilerle eşleşmeyen veriler aldığı her durumda yeni modeller oluşturmanız önerilir. Types of daya operations . Data katmanı, ne kadar kritik olduklarına bağlı olarak değişen işlem türleriyle çalışabilir:UI-oriented, app-oriented, and business-oriented operations. UI-oriented operations . UI odaklı işlemler yalnızca kullanıcı belirli bir ekrandayken geçerlidir ve kullanıcı o ekrandan ayrıldığında iptal edilirler. Veritabanından elde edilen bazı verilerin görüntülenmesi buna bir örnektir. UI odaklı işlemler genellikle UI katmanı tarafından tetiklenir ve çağıranın yaşam döngüsünü (örneğin ViewModel’in yaşam döngüsü) takip eder. UI odaklı bir işlem örneği için Network isteği yapma bölümüne bakın. App-oriented operations . Uygulama odaklı işlemler, uygulama açık olduğu sürece geçerlidir. Uygulama kapatılırsa veya işlem öldürülürse, bu işlemler iptal edilir. Bir network isteğinin sonucunun, gerektiğinde daha sonra kullanılabilmesi için önbelleğe alınması buna bir örnektir. Daha fazla bilgi için in-memory data caching bölümüne bakın. Bu işlemler genellikle Application sınıfının veya data katmanının yaşam döngüsünü takip eder. Bir örnek için, Bir işlemi ekrandan daha uzun süre yaşatın bölümüne bakın. Business-oriented operations . İş odaklı işlemler iptal edilemez. İşlem ölümünden sağ çıkmalıdırlar. Kullanıcının profiline göndermek istediği bir fotoğrafın yüklemesini bitirmek buna bir örnektir. İş odaklı işlemler için öneri WorkManager kullanmaktır. Daha fazla bilgi edinmek için WorkManager kullanarak görevleri zamanlama bölümüne bakın. Expose errors . Repositorylerle ve veri kaynaklarıyla etkileşimler başarılı olabilir veya bir hata oluştuğunda bir exception fırlatabilir. Coroutine’ler ve flow’lar için Kotlin’in yerleşik hata işleme mekanizmasını kullanmalısınız. Suspend fonksiyonları tarafından tetiklenebilecek hatalar için, uygun olduğunda try/catch bloklarını kullanın; ve flow’larda catch operatörünü kullanın. Bu yaklaşımla, UI katmanının data katmanını çağırırken exception’ları ele alması beklenir. Data katmanı farklı hata türlerini anlayabilir ve işleyebilir ve bunları özel exception’lar (örneğin UserNotAuthenticatedException) kullanarak gösterebilir. Not: Data katmanı ile etkileşimlerin sonucunu modellemenin bir başka yolu da bir Result sınıfı kullanmaktır. Bu model, sonucun işlenmesinin bir parçası olarak ortaya çıkabilecek hataları ve diğer sinyalleri modeller. Bu modelde, data katmanı T yerine bir Result tipi döndürerek UI'nin belirli senaryolarda oluşabilecek bilinen hatalardan haberdar olmasını sağlar. Bu, [LiveData]gibi uygun exception handling'e sahip olmayan reaktif programlama API'leri için gereklidir. &lt;/mark&gt; . Coroutine’lerdeki hatalar hakkında daha fazla bilgi edinmek için Exceptions in coroutines blog gönderisine bakın. Common tasks . Aşağıdaki bölümlerde, Android uygulamalarında yaygın olan belirli görevleri gerçekleştirmek için data katmanının nasıl kullanılacağına ve tasarlanacağına dair örnekler sunulmaktadır. Örnekler, kılavuzun önceki bölümlerinde bahsedilen tipik News uygulamasını temel almaktadır. Make a network request . Ağ isteği yapmak, bir Android uygulamasının gerçekleştirebileceği en yaygın görevlerden biridir. News uygulamasının kullanıcıya ağdan alınan en son haberleri sunması gerekir. Bu nedenle, uygulamanın ağ işlemlerini yönetmek için bir veri kaynağı sınıfına ihtiyacı vardır: NewsRemoteDataSource. Bilgileri uygulamanın geri kalanına göstermek için, haber verileri üzerindeki işlemleri gerçekleştiren yeni bir repository oluşturulur: NewsRepository. Gereklilik, kullanıcı ekranı açtığında en son haberlerin her zaman güncellenmesi gerektiğidir. Dolayısıyla, bu UI odaklı(UI-oriented) bir operasyondur. Create the data source . Veri kaynağının en son haberleri döndüren bir fonksiyon sunması gerekir: ArticleHeadline instancelarının bir listesi. Veri kaynağının ağdan en son haberleri almak için main-safe bir yol sağlaması gerekir. Bunun için, task’in çalıştırılacağı CoroutineDispatcher ya da Executor’a dependency(bağımlılık) alması gerekir. Bir ağ isteği yapmak, yeni bir fetchLatestNews() metodu tarafından yürütülen tek seferlik bir çağrıdır: . class NewsRemoteDataSource( private val newsApi: NewsApi, private val ioDispatcher: CoroutineDispatcher ) { /** * Fetches the latest news from the network and returns the result. * This executes on an IO-optimized thread pool, the function is main-safe. */ suspend fun fetchLatestNews(): List&lt;ArticleHeadline&gt; = // Move the execution to an IO-optimized thread since the ApiService // doesn't support coroutines and makes synchronous requests. withContext(ioDispatcher) { newsApi.fetchLatestNews() } } // Makes news-related network synchronous requests. interface NewsApi { fun fetchLatestNews(): List&lt;ArticleHeadline&gt; } . NewsApi interface’i network API client’ının implementasyonunu gizler; interface’in Retrofit veya HttpURLConnection tarafından desteklenmesi fark etmez. Interface’lere güvenmek, API implementasyonlarını uygulamanızda değiştirilebilir hale getirir. Püf Noktası: Interface'lere güvenmek, API implementasyonlarını uygulamanızda değiştirilebilir hale getirir. Ölçeklenebilirlik sağlamanın ve bağımlılıkları daha kolay değiştirmenize izin vermenin yanı sıra, testlere sahte veri kaynağı uygulamaları ekleyebildiğiniz için test edilebilirliği de destekler. Create the repository . Bu görev için repository sınıfında ekstra bir mantık gerekmediğinden, NewsRepository network veri kaynağı için bir proxy görevi görür. Bu ekstra soyutlama katmanını eklemenin faydaları in-memory caching bölümünde açıklanmıştır. // NewsRepository is consumed from other layers of the hierarchy. class NewsRepository( private val newsRemoteDataSource: NewsRemoteDataSource ) { suspend fun fetchLatestNews(): List&lt;ArticleHeadline&gt; = newsRemoteDataSource.fetchLatestNews() } . Repository sınıfını doğrudan UI katmanından nasıl kullanacağınızı öğrenmek için UI layer kılavuzuna bakın. Implement in-memory data caching . News uygulaması için yeni bir gereksinim getirildiğini varsayalım: kullanıcı ekranı açtığında, daha önce bir istek yapılmışsa cache’lenmiş haberler kullanıcıya sunulmalıdır. Aksi takdirde, uygulama en son haberleri almak için bir network isteği yapmalıdır. Yeni gereksinim göz önüne alındığında, uygulama, kullanıcı uygulamayı açık tuttuğu sürece en son haberleri bellekte tutmalıdır. Dolayısıyla, bu app-oriented operation (uygulama odaklı işlem)dur. Caches . In-memory data caching (bellek içi veri önbellekleme) ekleyerek kullanıcı uygulamanızdayken verileri koruyabilirsiniz. Cache’ler, bazı bilgileri belirli bir süre boyunca (bu durumda kullanıcı uygulamada olduğu sürece) bellekte saklamak içindir. Cache implementasyonları farklı şekillerde olabilir. Basit bir değiştirilebilir değişkenden, birden fazla thread üzerinde okuma/yazma işlemlerinden koruyan daha sofistike bir sınıfa kadar değişebilir. Kullanım durumuna bağlı olarak, caching repository’de veya veri kaynağı sınıflarında uygulanabilir. Cache the result of the network request . Basitlik açısından NewsRepository, en son haberleri cache’lemek için mutable bir değişken kullanır. Farklı thread’lerden gelen okuma ve yazmaları korumak için bir Mutex kullanılır. Paylaşılan mutable state ve concurrency hakkında daha fazla bilgi edinmek için Kotlin belgelerine bakın. Aşağıdaki implementasyon, en son haber bilgilerini repository’de bir Mutex ile yazma korumalı bir değişkene cache’ler. Network isteğinin sonucu başarılı olursa, veriler latestNews değişkenine atanır. class NewsRepository( private val newsRemoteDataSource: NewsRemoteDataSource ) { // Mutex to make writes to cached values thread-safe. private val latestNewsMutex = Mutex() // Cache of the latest news got from the network. private var latestNews: List&lt;ArticleHeadline&gt; = emptyList() suspend fun getLatestNews(refresh: Boolean = false): List&lt;ArticleHeadline&gt; { if (refresh || latestNews.isEmpty()) { val networkResult = newsRemoteDataSource.fetchLatestNews() // Thread-safe write to latestNews latestNewsMutex.withLock { this.latestNews = networkResult } } return latestNewsMutex.withLock { this.latestNews } } } . Make an operation live longer than the screen . Ağ isteği devam ederken kullanıcı ekrandan uzaklaşırsa, istek iptal edilir ve sonuç cache’lenmez. NewsRepository bu logici gerçekleştirmek için Caller’ın CoroutineScope’unu kullanmamalıdır. Bunun yerine, NewsRepository kendi yaşam döngüsüne bağlı bir CoroutineScope kullanmalıdır. En son haberleri getirmenin app-oriented bir operasyon olması gerekir. Dependency injection best practicelerini takip etmek için NewsRepository kendi CoroutineScope’unu oluşturmak yerine constructor’ında parametre olarak bir scope almalıdır. Repository’lerin işlerinin çoğunu background thread’lerde yapması gerektiğinden, CoroutineScope’u Dispatchers.Default ya da kendi thread havuzunuz ile yapılandırmalısınız. class NewsRepository( ..., // This could be CoroutineScope(SupervisorJob() + Dispatchers.Default). private val externalScope: CoroutineScope ) { ... } . NewsRepository harici CoroutineScope ile app oriented operasyonlar gerçekleştirmeye hazır olduğundan, veri kaynağına çağrıyı gerçekleştirmeli ve sonucunu bu scope tarafından başlatılan yeni bir coroutine ile kaydetmelidir: . class NewsRepository( private val newsRemoteDataSource: NewsRemoteDataSource, private val externalScope: CoroutineScope ) { /* ... */ suspend fun getLatestNews(refresh: Boolean = false): List&lt;ArticleHeadline&gt; { return if (refresh) { externalScope.async { newsRemoteDataSource.fetchLatestNews().also { networkResult -&gt; // Thread-safe write to latestNews. latestNewsMutex.withLock { latestNews = networkResult } } }.await() } else { return latestNewsMutex.withLock { this.latestNews } } } } . async, coroutine’i harici scope’da başlatmak için kullanılır. await, network isteği geri gelene ve sonuç cache’e kaydedilene kadar askıya almak için yeni coroutine üzerinde çağrılır. O zamana kadar kullanıcı hala ekrandaysa, en son haberleri görecektir; kullanıcı ekrandan uzaklaşırsa, await iptal edilir ancak async içindeki logic çalışmaya devam eder. CoroutineScope patternleri hakkında daha fazla bilgi edinmek için bu blog yazısına bakın. Save and retrieve data from disk . Bookmark edilmiş haberler ve kullanıcı tercihleri gibi verileri kaydetmek istediğinizi varsayalım. Bu tür verilerin process death’den kurtulması ve kullanıcı network’e bağlı olmasa bile erişilebilir olması gerekir. Üzerinde çalıştığınız verilerin process death’den kurtulması gerekiyorsa, aşağıdaki yollardan biriyle diskte saklamanız gerekir: . -Sorgulanması gereken, referans bütünlüğüne ihtiyaç duyan veya kısmi güncellemelere ihtiyaç duyan büyük veri kümeleri için verileri bir Room veritabanına kaydedin. News uygulaması örneğinde, haber makaleleri veya yazarları veritabanına kaydedilebilir. -Yalnızca alınması ve ayarlanması gereken (sorgulanmayan veya kısmen güncellenmeyen) küçük veri kümeleri için DataStore kullanın. News uygulaması örneğinde, kullanıcının tercih ettiği tarih biçimi veya diğer görüntüleme tercihleri DataStore’a kaydedilebilir. -JSON nesnesi gibi veri parçaları için bir dosya kullanın. Source of truth bölümünde belirtildiği gibi, her veri kaynağı yalnızca bir kaynakla çalışır ve belirli bir veri türüne karşılık gelir (örneğin, News, Authors, NewsAndAuthors veya UserPreferences). Veri kaynağını kullanan sınıflar, verilerin nasıl kaydedildiğini bilmemelidir (örneğin, bir veritabanına veya bir dosyaya). Room as a data source . Her veri kaynağının belirli bir veri türü için yalnızca bir kaynakla çalışma sorumluluğuna sahip olması gerektiğinden, bir Room veri kaynağı parametre olarak ya bir veri erişim nesnesi (DAO) ya da veritabanının kendisini alacaktır. Örneğin, NewsLocalDataSource parametre olarak NewsDao’nun bir instance’ını alabilir ve AuthorsLocalDataSource AuthorsDao’nun bir instance’ını alabilir. Bazı durumlarda, ekstra bir lojik gerekmiyorsa, DAO testlerde kolayca değiştirebileceğiniz bir interface olduğundan, DAO’yu doğrudan repository’ye enjekte edebilirsiniz. Room API’leri ile çalışma hakkında daha fazla bilgi edinmek için Room kılavuzlarına bakın. DataStore as a data source . DataStore, kullanıcı ayarları gibi key-value çiftlerini saklamak için mükemmeldir. Örnekler arasında zaman biçimi, bildirim tercihleri ve kullanıcı okuduktan sonra haber öğelerinin gösterilip gösterilmeyeceği veya gizlenip gizlenmeyeceği yer alabilir. DataStore aynı zamanda protocol buffer‘ları olan tiplendirilmiş nesneleri de depolayabilir. Diğer tüm nesnelerde olduğu gibi, DataStore tarafından desteklenen bir veri kaynağı, belirli bir türe veya uygulamanın belirli bir bölümüne karşılık gelen verileri içermelidir. Bu durum DataStore için daha da geçerlidir çünkü DataStore okumaları, bir değer her güncellendiğinde yayılan bir akış olarak açığa çıkar. Bu nedenle, ilgili tercihleri aynı DataStore’da saklamalısınız. Örneğin, yalnızca bildirimle ilgili tercihleri işleyen bir NotificationsDataStore’a ve yalnızca haber ekranıyla ilgili tercihleri işleyen bir NewsPreferencesDataStore’a sahip olabilirsiniz. Bu şekilde, newsScreenPreferencesDataStore.data akışı yalnızca o ekranla ilgili bir tercih değiştirildiğinde yayıldığı için güncellemeleri daha iyi kapsamlandırabilirsiniz. Bu aynı zamanda nesnenin yaşam döngüsünün daha kısa olabileceği anlamına gelir çünkü yalnızca haber ekranı görüntülendiği sürece yaşayabilir. DataStore API’leri ile çalışma hakkında daha fazla bilgi edinmek için DataStore kılavuzlarına bakın. A file as a data source . JSON nesnesi veya bitmap gibi büyük nesnelerle çalışırken, bir File nesnesiyle çalışmanız ve thread’leri değiştirmeniz gerekir. Storage ile çalışma hakkında daha fazla bilgi edinmek için Storage oveview sayfasına bakın. Schedule tasks using WorkManager . News uygulaması için yeni bir gereksinim daha getirildiğini varsayalım: Uygulama, kullanıcıya cihaz şarjda olduğu ve kesintisiz bir ağa bağlı olduğu sürece en son haberleri düzenli ve otomatik olarak alma seçeneği sunmalıdır. Bu da bunu business-oriented operation haline getiriyor. Bu gereklilik, kullanıcı uygulamayı açtığında cihazın bağlantısı olmasa bile kullanıcının en son haberleri görebilmesini sağlar. WorkManager, asenkron ve güvenilir iş planlamayı kolaylaştırır ve kısıtlama yönetimiyle ilgilenebilir. Kalıcı işler için önerilen kütüphanedir. Yukarıda tanımlanan görevi gerçekleştirmek için bir Worker sınıfı oluşturulur: RefreshLatestNewsWorker. Bu sınıf, en son haberleri getirmek ve diske cache’lemek için NewsRepository’yi dependency olarak alır. class RefreshLatestNewsWorker( private val newsRepository: NewsRepository, context: Context, params: WorkerParameters ) : CoroutineWorker(context, params) { override suspend fun doWork(): Result = try { newsRepository.refreshLatestNews() Result.success() } catch (error: Throwable) { Result.failure() } } . Bu tür görevler için business logic kendi sınıfında kapsüllenmeli ve ayrı bir veri kaynağı olarak ele alınmalıdır. WorkManager daha sonra yalnızca tüm kısıtlamalar karşılandığında işin bir background thread üzerinde yürütülmesini sağlamaktan sorumlu olacaktır. Bu kalıba bağlı kalarak, gerektiğinde farklı ortamlardaki uygulamaları hızlı bir şekilde değiştirebilirsiniz. Bu örnekte, haberlerle ilgili bu görev, bağımlılık olarak yeni bir veri kaynağı alacak olan NewsRepository’den çağrılmalıdır: NewsTasksDataSource, aşağıdaki gibi implemente edilmiştir: . private const val REFRESH_RATE_HOURS = 4L private const val FETCH_LATEST_NEWS_TASK = \"FetchLatestNewsTask\" private const val TAG_FETCH_LATEST_NEWS = \"FetchLatestNewsTaskTag\" class NewsTasksDataSource( private val workManager: WorkManager ) { fun fetchNewsPeriodically() { val fetchNewsRequest = PeriodicWorkRequestBuilder&lt;RefreshLatestNewsWorker&gt;( REFRESH_RATE_HOURS, TimeUnit.HOURS ).setConstraints( Constraints.Builder() .setRequiredNetworkType(NetworkType.TEMPORARILY_UNMETERED) .setRequiresCharging(true) .build() ) .addTag(TAG_FETCH_LATEST_NEWS) workManager.enqueueUniquePeriodicWork( FETCH_LATEST_NEWS_TASK, ExistingPeriodicWorkPolicy.KEEP, fetchNewsRequest.build() ) } fun cancelFetchingNewsPeriodically() { workManager.cancelAllWorkByTag(TAG_FETCH_LATEST_NEWS) } } . Bu tür sınıflar sorumlu oldukları verilere göre adlandırılır; örneğin NewsTasksDataSource veya PaymentsTasksDataSource. Belirli bir veri türüyle ilgili tüm görevler aynı sınıfta kapsüllenmelidir. Görevin uygulama başlangıcında tetiklenmesi gerekiyorsa, repository’i bir Initializer‘dan çağıran App Startup kütüphanesini kullanarak WorkManager isteğini tetiklemeniz önerilir. WorkManager API’leri ile çalışma hakkında daha fazla bilgi edinmek için WorkManager kılavuzlarına bakın. Testing . Dependency injection best practiceleri, uygulamanızı test ederken yardımcı olur. Harici kaynaklarla iletişim kuran sınıflar için interface’lere güvenmek de faydalıdır. Bir birimi test ederken, testi deterministik ve güvenilir hale getirmek için bağımlılıklarının sahte sürümlerini enjekte edebilirsiniz. Unit tests . Veri katmanını test ederken genel test yönergeleri geçerlidir. Birim testleri için, gerektiğinde gerçek nesneler kullanın ve bir dosyadan okuma veya ağdan okuma gibi harici kaynaklara ulaşan bağımlılıkları taklit edin. Integration tests . Harici kaynaklara erişen entegrasyon testleri, gerçek bir cihaz üzerinde çalıştırılmaları gerektiğinden daha az deterministik olma eğilimindedir. Entegrasyon testlerini daha güvenilir hale getirmek için bu testleri kontrollü bir ortamda yürütmeniz önerilir. Room, veritabanları için testlerinizde tamamen kontrol edebileceğiniz bir in-memory database oluşturmanıza olanak tanır. Daha fazla bilgi edinmek için Test and debug your database sayfasına bakın. Networking için, WireMock veya MockWebServer gibi HTTP ve HTTPS çağrılarını taklit etmenize ve isteklerin beklendiği gibi yapıldığını doğrulamanıza olanak tanıyan popüler kütüphaneler vardır. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer.html"
  },"14": {
    "doc": "About the navigation components",
    "title": "About the navigation components",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/about-the-navigation-components.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/about-the-navigation-components.html"
  },"15": {
    "doc": "About the UI layer",
    "title": "UI Layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer.html#ui-layer",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer.html#ui-layer"
  },"16": {
    "doc": "About the UI layer",
    "title": "About the UI layer",
    "content": "Kullanıcı arayüzünün(UI) rolü, uygulama verilerini ekranda görüntülemek ve ayrıca kullanıcı etkileşiminin(user interaction) birincil noktası olarak hizmet etmektir. Veriler, kullanıcı etkileşimi (bir butona basmak gibi) veya harici giriş (bir network response gibi) nedeniyle değiştiğinde, kullanıcı arayüzü bu değişiklikleri yansıtacak şekilde güncellenmelidir. Yani, UI, data katmanından alınan uygulama state’inin görsel bir temsilidir. Ancak data katmanından aldığınız uygulama verileri genellikle görüntülemeniz gereken bilgilerden farklı bir formattadır. Örneğin, UI için verilerin yalnızca bir kısmına ihtiyacınız olabilir veya kullanıcıyla ilgili bilgileri sunmak için iki farklı veri kaynağını birleştirmeniz gerekebilir. Uyguladığınız logic ne olursa olsun, tam olarak işlemesi için ihtiyaç duyduğu tüm bilgileri UI’ye iletmeniz gerekir. UI katmanı, uygulama veri değişikliklerini UI’in sunabileceği bir forma dönüştüren ve ardından bunu görüntüleyen piplinedir. Şekil 1. Uygulama mimarisinde UI katmanının rolü; . Not: Bu sayfada sunulan öneriler ve best practiceler, ölçeklenmelerine, kalite ve sağlamlığı artırmalarına ve test edilmelerini kolaylaştırmalarına olanak sağlamak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Architecture: The UI Layer - MAD Skills . A basic case study . Bir kullanıcının okuması için haber makaleleri getiren bir uygulama düşünün. Uygulama, okunabilecek makaleler sunan bir makaleler ekranına sahiptir ve ayrıca oturum açmış kullanıcıların gerçekten öne çıkan makalelere yer işareti koymasına olanak tanır. Her an çok sayıda makale olabileceği göz önüne alındığında, okuyucunun makalelere kategorilere göre göz atabilmesi gerekir. Özetle, uygulama, kullanıcıların aşağıdakileri yapmasına izin verir: . | Okunabilecek makaleleri görüntüleyin. | Makalelere kategoriye göre göz atın. | Oturum açın ve belirli makalelere yer işareti koyun. | Uygunsa bazı premium özelliklere erişin. | . Aşağıdaki bölümler, bu örneği, tek yönlü veri akışı ilkelerini tanıtmak ve bu ilkelerin UI katmanı için uygulama mimarisi bağlamında çözmeye yardımcı olduğu sorunları göstermek için bir use case olarak kullanır. UI layer Architecture . UI terimi, bunu yapmak için hangi API’leri kullandıklarından bağımsız olarak (Views veya Jetpack Compose) verileri görüntüleyen activity ve fragment gibi UI elementlerini ifade eder. Data katmanının rolü uygulama verilerini tutmak, yönetmek ve bunlara erişim sağlamak olduğundan, UI katmanı aşağıdaki adımları gerçekleştirmelidir: . | Uygulama verilerini tüketin(consume etmek) ve UI’in kolayca render edilebilecegi verilere dönüştürün. | UI ile render edilebilir verileri tüketin ve kullanıcıya sunulmak üzere UI elementlerine dönüştürün. | Bu birleştirilmiş UI elementlerinden kullanıcı input eventlerini tüketin ve etkilerini gerektiği gibi UI verilerine yansıtın. | 1’den 3’e kadar olan adımları gerektiği kadar tekrarlayın. | . Bu kılavuzun geri kalanı, bu adımları gerçekleştiren bir UI katmanının nasıl implementasyonunu gösterir. Bu kılavuz özellikle aşağıdaki görevleri ve kavramları kapsar: . | UI state nasıl tanımlanır. | UI state’ini üretme(produce) ve yönetme aracı olarak tek yönlü veri akışı ((Undirectional Data Flow)UDF). | UDF ilkelerine göre observable veri türleriyle UI state’i nasıl ortaya çıkar. | Observable UI state’ini tüketen UI nasıl implement edilir. Bunlardan en temel olanı UI state’inin tanımıdır. | . Define UI State . Daha önce özetlenen case study üzerinden devam edelim. Kısacası, kullanıcı arayüzü her makale için bazı metadata ile birlikte bir makale listesi gösterir. Uygulamanın kullanıcıya sunduğu bu bilgiler, UI state’dir. Başka bir deyişle: UI, kullanıcının gördüğü şeyse, UI state, uygulamanın görmeleri gerektiğini söylediği şeydir. Aynı madalyonun iki yüzü gibi, UI da UI state’in görsel temsilidir. UI state’indeki herhangi bir değişiklik, hemen UI’ye yansıtılır. Use case incelemesini düşünün; News uygulamasının gereksinimlerini karşılamak için, kullanıcı arayüzünü tam olarak oluşturmak için gereken bilgiler, aşağıdaki gibi tanımlanan bir NewsUiState data classda encapsule edilebilir: . data class NewsUiState( val isSignedIn: Boolean = false, val isPremium: Boolean = false, val newsItems: List&lt;NewsItemUiState&gt; = listOf(), val userMessages: List&lt;Message&gt; = listOf() ) data class NewsItemUiState( val title: String, val body: String, val bookmarked: Boolean = false, ... ) . Immutability . Yukarıdaki örnekteki UI state tanımı immutabledir(degismez). Bunun en önemli faydası, immutable nesnelerin zamanın bir anında uygulamanın state’ine ilişkin garantiler sağlamasıdır. Bu, UI’i tek bir role odaklanmak için serbest bırakır: state’i okumak ve UI elementlerini buna göre güncellemek. Sonuç olarak, UI verilerinin tek kaynağı(ssot) UI’nin kendisi olmadığı sürece UI state’ini asla doğrudan UI’de değiştirmemelisiniz. Bu ilkeyi ihlal etmek, aynı bilgi parçası için birden fazla doğruluk kaynağına(multiple source of truth istenmeyen durumdur) yol açarak veri tutarsızlıklarına ve ince hatalara neden olur. Örneğin, use casedeki UI state’ten bir NewsItemUiState nesnesindeki bookmarked flag’i Activity sınıfında güncellenseydi, bu flag bir makalenin bookmarked statüsünün kaynağı olarak data katmanı ile rekabet halinde olacaktı. Immutable data class’lar bu tür antipattern’leri önlemek için çok kullanışlıdır. Kilit Nokta: Yalnızca veri kaynakları veya ownerlari, ortaya koydukları verilerin güncellenmesinden sorumlu olmalıdır. Naming conventions in this guide . Bu kılavuzda, UI state sınıfları, ekranın veya tanımladıkları ekranın bir bölümünün fonksiyonalitesine göre adlandırılır. Sözleşme şu şekildedir: fonksiyonalite + UiState. Örneğin, haberleri görüntüleyen bir ekranın state’i NewsUiState olarak adlandırılabilir ve haber öğeleri listesindeki bir haber öğesinin state’i NewsItemUiState olabilir. Manage State with Undirectional Data Flow . Önceki bölüm, UI state’inin, UI’in oluşturması için gereken ayrıntıların immutable bir snapshot olduğunu belirttik. Ancak, uygulamalardaki verilerin dinamik doğası geregi, bu state’in zaman içinde değişebileceği anlamına gelir. Bunun nedeni, uygulamayı doldurmak(populate) için kullanılan temel verileri değiştiren kullanıcı etkileşimi(user interaction) veya diğer eventlar olabilir. Bu etkileşimler, bunları işlemek, her event’e uygulanacak logic’i tanımlamak ve UI state ini oluşturmak için backing data resource lerine gerekli transformationlari gerçekleştirmek için bir arabulucudan(mediator) yararlanabilir. Bu etkileşimler ve bunların logici kullanıcı arayüzünün kendisinde barındırılabilir, ancak kullanıcı arayüzü adından da anlaşılacağı gibi data owner, producer, transformer ve daha fazlası haline gelmeye başladıkça bu durum hızla hantallaşabilir. Ayrıca, ortaya çıkan kod, ayırt edilebilir sınırları olmayan tightly coupled bir karışım olduğundan, bu durum test edilebilirliği etkileyebilir. Sonuç olarak, kullanıcı arayüzü azaltılmış yükten faydalanmaya hazırdır. UI state’i çok basit olmadığı sürece, UI’nin tek sorumluluğu UI state’ini kullanmak ve görüntülemek olmalıdır. Bu bölümde, healthy separation of responsibility uygulanmasına yardımcı olan bir mimari model olan Tek Yönlü Veri Akışı (unidirectional data flow (UDF) ele alınmaktadır. State Holders . UI state’inin üretilmesinden sorumlu olan ve o görev için gerekli logici içeren sınıflara state holder denir. State Holderlar, yönettikleri ilgili UI elementlerinin scope una bağlı olarak, bottom appbar gibi tek bir widget öğesinden tüm ekrana veya bir navigation hedefine kadar çeşitli boyutlarda gelir. İkinci durumda, tipik uygulama bir ViewModel örneğidir, ancak uygulamanın gereksinimlerine bağlı olarak basit bir sınıf yeterli olabilir. Yukarıdaki case study deki News uygulaması, örneğin, o bölümde görüntülenen ekran için UI state oluşturmak üzere state holder olarak bir NewsViewModel sınıfını kullanır. Kilit Nokta: ViewModel türü, veri katmanına erişimle birlikte ekran düzeyinde Ui state’inin yönetimi için önerilen implementasyondur. Ayrıca, yapılandırma değişikliklerinden(configuration changes) otomatik olarak kurtulur. ViewModel sınıfları, uygulamadaki eventlara uygulanacak logic’i tanımlar ve sonuç olarak güncellenmiş state’i üretir. UI ile state producer arasındaki karşılıklı bağımlılığı modellemenin birçok yolu vardır. Bununla birlikte,UI ile ViewModel sınıfı arasındaki etkileşim, büyük ölçüde event input ve ardından gelen state output olarak anlaşılabileceğinden, ilişki aşağıdaki şemada gösterildiği gibi gösterilebilir: State’in aşağı doğru aktığı ve eventlarin yukarı doğru aktığı patterne tek yönlü veri akışı(unidirectional data flow) ( UDF) denir. Uygulama mimarisi için bu modelin sonuçları aşağıdaki gibidir: . | ViewModel, UI tarafından tüketilecek state’i tutar ve gösterir. UI state’i,ViewModel tarafından dönüştürülen uygulama verileridir. | UI, kullanıcı eventlerini ViewModel’e bildirir. | ViewModel, kullanıcı eylemlerini işler ve state’i günceller. | Güncellenen state, işlenmek üzere kullanıcı arayüzüne(UI) geri beslenir. | Yukarıdaki durum, bir state değişimine neden olan herhangi bir event için tekrarlanır. | . Navigation destinations veya ekranlar için ViewModel, veri almak ve bunları UI state’ine dönüştürmek için repository’ler veya use case sınıfları ile birlikte çalışır ve aynı zamanda state’in değişmesine neden olabilecek event’lerin etkilerini de dahil eder. Daha önce bahsedilen case study, her biri bir başlık, açıklama, kaynak, yazar adı, yayın tarihi ve bookmarked olup olmadığına sahip bir makale listesi içerir. Her bir makale öğesi için UI aşağıdaki gibi görünür: . Bir makaleye bookmark koymak isteyen bir kullanıcı, state değişimlerine neden olabilecek bir event’a örnektir. State producer olarak, ViewModel’in sorumluluğundaki sey; UI state’in deki tüm alanları doldurmak ve UI’in tam olarak işlemesi için gereken eventlari handle etmek amaciyla gereken tüm logici tanımlamaktır. Aşağıdaki bölümlerde, state değişikliklerine neden olan eventlere ve bunların UDF kullanılarak nasıl handle edilebilecegine daha yakından bakılmaktadır. Types of Logic . Bir makaleyi bookmarklamak, uygulamanıza değer kattığı için bir iş mantığı(business logic) örneğidir. Bununla ilgili daha fazla bilgi edinmek için veri katmanı(data layer) sayfasına bakın. Ancak, tanımlanması önemli olan farklı logic türleri vardır: . | Business logic, uygulama verileri için ürün gereksinimlerinin implement edilmesidir. Daha önce belirtildiği gibi, case study uygulamasında bir makaleye bookmark koymaktır. Business logic genellikle domain veya data katmanlarına yerleştirilir, ancak asla UI katmanına yerleştirilmez. | UI behavior logic veya UI logic, state değişikliklerinin ekranda nasıl görüntüleneceğidir. Örnekler arasında, Android Resourcelerini kullanarak ekranda gösterilecek doğru metni elde etmek, kullanıcı bir butonu tıkladığında belirli bir ekrana gitmek veya bir toast veya snackbar kullanarak ekranda bir kullanıcı mesajı görüntülemek yer alır. | . UI logici, özellikle Context gibi UI türlerini içerdiğinde, ViewModel’de değil UI’de yaşamalıdır. UI’in karmaşıklığı artarsa ve UI logicini test edilebilirliği ve endişelerin ayrılmasını(separation of concerns) desteklemek için başka bir sınıfa devretmek istiyorsanız, state holder olarak basit bir sınıf oluşturabilirsiniz. UI’de oluşturulan basit sınıflar, UI’nin yaşam döngüsünü takip ettikleri için Android SDK bağımlılıklarını alabilir; ViewModel nesnelerinin ömrü daha uzundur. State holderlar ve bunların UI oluşturmaya yardımcı olma bağlamına nasıl uydukları hakkında daha fazla bilgi için Jetpack Compose State kılavuzuna bakın. Why use UDF? . UDF, state değişimlerinin başladığı yeri, dönüştüğü yeri ve nihai olarak tüketildiği yeri de ayırır. Bu ayrım, kullanıcı arayüzünün tam olarak adının ima ettiği şeyi yapmasına olanak tanır yani state değişikliklerini gözlemleyerek(observe) bilgileri görüntüleyin ve bu değişiklikleri ViewModel’e ileterek user’in amacını iletin. Başka bir deyişle, UDF aşağıdakilere izin verir: . | Veri tutarlılığı. Kullanıcı arayüzü için tek bir doğruluk kaynağı(ssot) vardır. | Test edilebilirlik. State kaynağı yalıtılmıştır ve bu nedenle kullanıcı arabiriminden bağımsız olarak test edilebilir. | Bakım kolaylığı. State degisikligi, degisikliklerin hem kullanıcı eventlerinin hem de çektikleri veri kaynaklarının bir sonucu olduğu iyi tanımlanmış bir model izler. | . Expose UI State . UI state’inizi tanımlayıp, o state’in üretimini(produce) nasıl yöneteceğinizi belirledikten sonra sıra, üretilen state’i UI’ye sunmaktır. State’in üretimini yönetmek için UDF kullandığınız için, üretilen state’i bir stream olarak düşünebilirsiniz; başka bir deyişle, state’in birden çok sürümü zaman içinde üretilecektir. Sonuç olarak, UI state’ini LiveData veya StateFlow gibi gözlemlenebilir bir data holderla göstermelisiniz. Bunun nedeni, kullanıcı arabiriminin, verileri doğrudan ViewModel’den manuel olarak çekmek zorunda kalmadan state’de yapılan herhangi bir değişikliğe tepki verebilmesidir. Bu tipler ayrıca, yapılandırma değişikliklerinden sonra hızlı durum geri yüklemesi için yararlı olan, kullanıcı arayüzü state’inin her zaman en son sürümünün önbelleğe alınması avantajına sahiptir. //views class NewsViewModel(...) : ViewModel() { val uiState: StateFlow&lt;NewsUiState&gt; = … } . //compose class NewsViewModel(...) : ViewModel() { val uiState: NewsUiState = … } . Observable bir data holder olarak LiveData’ya giriş için bu codelab‘e bakın. Kotlin flowlara benzer bir giriş için bkz. Android’de Kotlin flows. Not: Jetpack Compose uygulamalarında, UI state’inin gösterilmesi için Compose'un mutableStateOf veya snapshotFlow gibi gözlemlenebilir State API'lerini kullanabilirsiniz. Bu kılavuzda gördüğünüz StateFlow veya LiveData gibi her türlü gözlemlenebilir data holder, uygun extensionlar kullanılarak Compose'da kolayca tüketilebilir. UI’ye maruz kalan verilerin nispeten basit olduğu durumlarda, state holderin yayılımı(emission) ile ilişkili ekran veya UI elementi arasındaki ilişkiyi aktardığı için genellikle verileri bir UI state tipine sarmaya değer. Ayrıca, UI elementi daha karmaşık hale geldikçe, UI elementini render etmek için gereken ekstra bilgileri barındırmak için UI state tanımına ekleme yapmak her zaman daha kolaydır. Bir UiState akışı oluşturmanın yaygın bir yolu, backing mutable stream’i ViewModel’den immutable stream olarak göstermektir; örneğin, MutableStateFlow'i StateFlow olarak göstermek gibi. //views class NewsViewModel(...) : ViewModel() { private val _uiState = MutableStateFlow(NewsUiState()) val uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow() ... } //compose class NewsViewModel(...) : ViewModel() { var uiState by mutableStateOf(NewsUiState()) private set ... } . ViewModel daha sonra state’i dahili olarak değiştiren methodlari expose edebilir ve UI’in tüketmesi için güncellemeler yayınlayabilir. Örneğin, asenkron bir action’in gerçekleştirilmesi gereken durumu ele alalım; viewModelScope kullanılarak bir coroutine başlatılabilir ve mutable state tamamlandıktan sonra güncellenebilir. //views class NewsViewModel( private val repository: NewsRepository, ... ) : ViewModel() { private val _uiState = MutableStateFlow(NewsUiState()) val uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow() private var fetchJob: Job? = null fun fetchArticles(category: String) { fetchJob?.cancel() fetchJob = viewModelScope.launch { try { val newsItems = repository.newsItemsForCategory(category) _uiState.update { it.copy(newsItems = newsItems) } } catch (ioe: IOException) { // Handle the error and notify the UI when appropriate. _uiState.update { val messages = getMessagesFromThrowable(ioe) it.copy(userMessages = messages) } } } } } //compose class NewsViewModel( private val repository: NewsRepository, ... ) : ViewModel() { var uiState by mutableStateOf(NewsUiState()) private set private var fetchJob: Job? = null fun fetchArticles(category: String) { fetchJob?.cancel() fetchJob = viewModelScope.launch { try { val newsItems = repository.newsItemsForCategory(category) uiState = uiState.copy(newsItems = newsItems) } catch (ioe: IOException) { // Handle the error and notify the UI when appropriate. val messages = getMessagesFromThrowable(ioe) uiState = uiState.copy(userMessages = messages) } } } } . Yukarıdaki örnekte, NewsViewModel sınıfı, belirli bir kategori için makaleleri getirmeye çalışır ve ardından, girişimin sonucunu (başarılı veya başarısız) UI’in buna uygun şekilde tepki verebileceği UI state’inde yansıtır. Hata handle etme hakkında daha fazla bilgi edinmek için Show errors on the screen bölümüne bakın . Not: State’in ViewModel'deki fonksiyonlar aracılığıyla değiştirildiği yukarıdaki örnekte gösterilen pattern, tek yönlü veri akışının(UDF) en popüler uygulamalarından biridir. Additional considerations . Önceki kılavuza ek olarak, UI state’ini gösterirken aşağıdakileri göz önünde bulundurun: . | Bir UI state object, birbiriyle ilişkili stateleri handle edebilmelidir. Bu, daha az tutarsızlığa yol açar ve kodun anlaşılmasını kolaylaştırır. News item listesini ve bookmarlarin sayısını iki farklı streamde gösterirseniz, birinin güncellenip diğerinin güncellenmediği bir durumla karşılaşabilirsiniz. Tek bir stream kullandığınızda, her iki element de güncel tutulur. Ayrıca, bazı business logic, resourcelerin bir kombinasyonunu gerektirebilir. Örneğin, yalnızca kullanıcı oturum açmışsa ve bu kullanıcı bir premium haber hizmetine aboneyse, bir bookmark butonunu göstermeniz gerekebilir. Bir UI state sınıfını aşağıdaki gibi tanımlayabilirsiniz: | . data class NewsUiState( val isSignedIn: Boolean = false, val isPremium: Boolean = false, val newsItems: List&lt;NewsItemUiState&gt; = listOf() ) val NewsUiState.canBookmarkNews: Boolean get() = isSignedIn &amp;&amp; isPremium . Bu bildirimde, bookmark butonunun görünürlüğü diğer iki propertynin türetilmiş bir propertysidir. Business logic daha karmaşık hale geldikçe, tüm propertylerin anında kullanılabilir olduğu tek bir UiState sınıfına sahip olmak giderek daha önemli hale geliyor. | Ui stateleri: tek stream mı yoksa multiple stream mı? UI stateinin tek bir akışta veya birden çok akışta göstermek arasında seçim yapmak için temel yol gösterici ilke, previous bullet pointtir: emit edilmis itemler arasındaki ilişki. Tek akış gosteriminin en büyük avantajı kolaylık ve veri tutarlılığıdır: statedeki tüketiciler her zaman her an en son bilgilere sahiptir. Ancak, ViewModel’den ayrı state akışlarının uygun olabileceği durumlar vardır: . | İlişkisiz veri türleri: Kullanıcı arayüzünü oluşturmak için gereken bazı stateler birbirinden tamamen bağımsız olabilir. Bu gibi durumlarda, özellikle bu statelerden biri diğerinden daha sık güncelleniyorsa, bu farklı stateleri bir araya getirmenin maliyeti faydalarından daha ağır basabilir. | UiState diffing: Bir UiState nesnesinde ne kadar çok field varsa, fieldlarindan birinin güncellenmesi sonucunda akışın emit etme(yayilma) olasılığı o kadar yüksektir. Viewlerin, ardışık yaymalari farklı mı yoksa aynı mı olduğunu anlamak için farklılaştırma mekanizması olmadığından, her yayma, viewde bir güncellemeye neden olur. Bu, LiveData’da Flow API’lerini veya distinctUntilChanged() gibi methodlari kullanarak hafifletmenin gerekli olabileceği anlamına gelir. | . | . Consume UI State . UI’deki UiState objelerinin streamini tüketmek için, kullandığınız gözlemlenebilir veri türü için terminal operatorunu kullanırsınız. Örneğin, LiveData için observe() methodunu, Kotlin flowlar için ise collect() methodunu veya onun varyasyonlarını kullanırsınız. UI’da observable data holder kullanırken, UI’in yaşam döngüsünü dikkate aldığınızdan emin olun. View kullanıcıya gösterilmediğinde UI’ in state’ini gözlemlememesi gerektiğinden bu önemlidir. Bu konu hakkında daha fazla bilgi edinmek için bu blog gönderisine bakın. LifecycleOwner, LiveData’yı kullanırken implicit olarak yaşam döngüsü endişelerini giderir. Flowlari kullanırken, bunu uygun coroutine kapsamı ve repeatOnLifecycle API’si ile halletmek en iyisidir: . //views class NewsActivity : AppCompatActivity() { private val viewModel: NewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { ... lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { // Update UI elements } } } } } //compose @Composable fun LatestNewsScreen( viewModel: NewsViewModel = viewModel() ) { // Show UI elements based on the viewModel.uiState } . Not: Bu örnekte kullanılan belirli StateFlow objectleri, active collectorleri olmadığında çalışmayı durdurmaz, ancak flowlarla çalışırken bunların nasıl uygulandığını bilmeyebilirsiniz. Yaşam döngüsüne duyarlı flow collection kullanmak, daha sonra downstream collector kodunu tekrar ziyaret etmeden ViewModel flowlarinda bu tür değişiklikleri yapmanızı sağlar. Show in-progress operations . Bir UiState sınıfında yükleme statelerini temsil etmenin basit bir yolu, bir boole alanı kullanmaktır: . data class NewsUiState( val isFetchingArticles: Boolean = false, ... ) . Bu flag’in değeri, UI’de bir progress bar’in varlığını veya yokluğunu temsil eder. //views class NewsActivity : AppCompatActivity() { private val viewModel: NewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { ... lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { // Bind the visibility of the progressBar to the state // of isFetchingArticles. viewModel.uiState .map { it.isFetchingArticles } .distinctUntilChanged() .collect { progressBar.isVisible = it } } } } } //compose @Composable fun LatestNewsScreen( modifier: Modifier = Modifier, viewModel: NewsViewModel = viewModel() ) { Box(modifier.fillMaxSize()) { if (viewModel.uiState.isFetchingArticles) { CircularProgressIndicator(Modifier.align(Alignment.Center)) } // Add other UI elements. For example, the list. } } . Show errors on the screen . UI’de hataların gösterilmesi, devam eden işlemleri göstermeye benzer çünkü her ikisi de varlıklarını veya yokluklarını gösteren boolean değerlerle kolayca temsil edilir. Ancak hatalar, kullanıcıya geri iletmek için ilişkili bir mesajı veya başarısız işlemi yeniden deneyen bunlarla ilişkili bir action de içerebilir. Bu nedenle, devam eden bir işlem yüklenirken veya yüklenmezken, hata durumlarının, hatanın bağlamına uygun meta verileri barındıran data classlar ile modellenmesi gerekebilir. Örneğin, makaleler getirilirken bir progress bar gösteren önceki bölümdeki örneği ele alalım. Bu işlem bir hatayla sonuçlanırsa, kullanıcıya neyin yanlış gittiğini açıklayan bir veya daha fazla mesaj görüntülemek isteyebilirsiniz. data class Message(val id: Long, val message: String) data class NewsUiState( val userMessages: List&lt;Message&gt; = listOf(), ... ) . Hata mesajları daha sonra kullanıcıya snackbar gibi UI elementleri biçiminde sunulabilir. Bu, UI eventlerinin nasıl üretildiği ve tüketildiği ile ilgili olduğundan, daha fazla bilgi edinmek için UI eventleri sayfasına bakın. Threading and concurrency . Bir ViewModel’de gerçekleştirilen herhangi bir çalışma, main threadden çağrı yapmak için main-safe olmalıdır. Bunun nedeni, işi farklı bir threade taşımaktan data ve domain layerlarin sorumlu olmasıdır. Bir ViewModel uzun süren işlemler gerçekleştiriyorsa, bu logici bir background threade taşımaktan da sorumludur. Kotlin coroutineler, concurrent operasyonlari yönetmenin harika bir yoludur ve Jetpack Architecture Components, bunlar için yerleşik destek sağlar. Android uygulamalarında coroutineleri kullanma hakkında daha fazla bilgi edinmek için bkz. Kotlin coroutines on Android. Navigation . Uygulama navigationdaki değişiklikler genellikle event benzeri yayilmalardan(emission) kaynaklanır. Örneğin, bir SignInViewModel sınıfı bir oturum açma gerçekleştirdikten sonra, UiState’in isSignedIn fieldi true olarak ayarlanmış olabilir. Bunun gibi tetikleyiciler, consumption implementasyonunun Navigation componentini ertelemesi dışında, yukarıdaki Consume UI State bölümünde kapsananlar gibi tüketilmelidir. Paging . Paging library, UI’de PagingData adlı bir tip ile tüketilir. PagingData, zaman içinde değişebilen öğeleri temsil ettiğinden ve içerdiğinden - başka bir deyişle immutable bir tip değildir - sabit bir UI state’inde temsil edilmemelidir. Bunun yerine, ViewModel’den bağımsız olarak kendi akışında göstermelisiniz. Bunun belirli bir örneği için Android Paging codelab bakın. Animations . Akıcı ve sorunsuz top level navigation transitions sağlamak için, animasyona başlamadan önce ikinci ekranın veri yüklemesini beklemek isteyebilirsiniz. Android view framework, postponeEnterTransition() ve startPostponedEnterTransition() API’leri ile fragment destinationslari arasındaki geçişleri(transitions) geciktirmek için hook sağlar. Bu API’ler, ikinci ekrandaki UI elementleri (genellikle ağdan getirilen bir görüntü), kullanıcı arabirimi bu ekrana geçişi animate etmeden önce görüntülenmeye hazır olmasını sağlamanın bir yolunu sağlar. Daha fazla ayrıntı ve uygulama özellikleri için Android Motion örneğine bakın. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer.html"
  },"17": {
    "doc": "About view binding",
    "title": "About view binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/about-view-binding.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/about-view-binding.html"
  },"18": {
    "doc": "About ViewModel",
    "title": "About ViewModel",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/about-viewmodel.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/about-viewmodel.html"
  },"19": {
    "doc": "About WorkManager",
    "title": "About WorkManager",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/about-workmanager.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/about-workmanager.html"
  },"20": {
    "doc": "action",
    "title": "action",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/action.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/action.html"
  },"21": {
    "doc": "Activities",
    "title": "Activities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/activities.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/activities.html"
  },"22": {
    "doc": "action",
    "title": "action",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/activity-alias.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/activity-alias.html"
  },"23": {
    "doc": "Activity state changes",
    "title": "Activity state changes",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/activity-state-changes.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/activity-state-changes.html"
  },"24": {
    "doc": "activity",
    "title": "activity",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/activity.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/activity.html"
  },"25": {
    "doc": "Add capabilities",
    "title": "Add capabilities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/add-capabilities.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/add-capabilities.html"
  },"26": {
    "doc": "Add new destination types",
    "title": "Add new destination types",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/add-new-destination-types.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/add-new-destination-types.html"
  },"27": {
    "doc": "Add support for back navigation",
    "title": "Add support for back navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/add-support-for-back-navigation.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/add-support-for-back-navigation.html"
  },"28": {
    "doc": "Advanced concepts",
    "title": "Advanced concepts",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/advanced-concepts/advanced-concepts.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/advanced-concepts/advanced-concepts.html"
  },"29": {
    "doc": "Animate transitions between destinations",
    "title": "Animate transitions between destinations",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/animate-transitions-between-destinations.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/animate-transitions-between-destinations.html"
  },"30": {
    "doc": "Animate transitions between fragments",
    "title": "Animate transitions between fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/animate-transitions-between-fragments.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/animate-transitions-between-fragments.html"
  },"31": {
    "doc": "Animation",
    "title": "Animation",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/animation.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/animation.html"
  },"32": {
    "doc": "App architecture",
    "title": "App architecture",
    "content": "CSS utility classes come in handy when you to want to override default styles to create additional whitespace (margins/padding), correct unexpected shifts in font size or weight, add color, or hide (or show) something at a specific screen size. ",
    "url": "/docs/app-architecture",
    
    "relUrl": "/docs/app-architecture"
  },"33": {
    "doc": "App basics",
    "title": "App basics",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "/docs/app-basics",
    
    "relUrl": "/docs/app-basics"
  },"34": {
    "doc": "App entry points",
    "title": "App entry points",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-entry-points.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-entry-points.html"
  },"35": {
    "doc": "App fundamentals",
    "title": "App fundamentals",
    "content": " ",
    "url": "/docs/app-basics/app-fundamentals.html",
    
    "relUrl": "/docs/app-basics/app-fundamentals.html"
  },"36": {
    "doc": "App links",
    "title": "App links",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/app-links.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/app-links.html"
  },"37": {
    "doc": "App manifest file",
    "title": "App manifest file",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/app-manifest-file.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/app-manifest-file.html"
  },"38": {
    "doc": "App navigation",
    "title": "App navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-navigation.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-navigation.html"
  },"39": {
    "doc": "App resources",
    "title": "App resources",
    "content": " ",
    "url": "/docs/app-basics/app-resources/app-resources.html",
    
    "relUrl": "/docs/app-basics/app-resources/app-resources.html"
  },"40": {
    "doc": "App shortcuts",
    "title": "App shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/app-shortcuts.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/app-shortcuts.html"
  },"41": {
    "doc": "App startup",
    "title": "App startup",
    "content": " ",
    "url": "/docs/app-architecture/app-startup.html",
    
    "relUrl": "/docs/app-architecture/app-startup.html"
  },"42": {
    "doc": "application",
    "title": "application",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/application.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/application.html"
  },"43": {
    "doc": "Architecture components",
    "title": "Architecture components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/architecture-components.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/architecture-components.html"
  },"44": {
    "doc": "Architecture recommendations",
    "title": "Architecture recommendations",
    "content": "Recommendations for Android Architecture . Bu sayfada çeşitli Architecture best practiceleri ve önerileri sunulmaktadır. Uygulamanızın kalitesini, sağlamlığını ve ölçeklenebilirliğini artırmak için bunları benimseyin. Ayrıca uygulamanızın bakımını ve test edilmesini de kolaylaştırırlar. Not: Bu belgedeki önerileri katı gereklilikler olarak değil tavsiyeler olarak ele almalısınız. Gerektiğinde bunları uygulamanıza uyarlayın. Aşağıdaki best practiceler konuya göre gruplandırılmıştır. Her birinin, ekibin ne kadar güçlü bir şekilde önerdiğini yansıtan bir önceliği vardır. Öncelikler listesi aşağıdaki gibidir: . | Strongly recommended: Yaklaşımınızla temelden çelişmediği sürece bu pratiği uygulamalısınız. | Recommended: Bu pratiğin uygulamanızı geliştirmesi muhtemeldir. | Optional: Bu pratik, belirli durumlarda uygulamanızı geliştirebilir. | . Not: Bu önerileri anlamak için [Architecture kılavuzu](guide-to-app-architecture)na aşina olmanız gerekir. Layer Architecture . Önerdiğimiz katmanlı mimari, seperation of concern’i destekler. UI’yi veri modellerinden yönlendirir, single source of truth ilkesine uyar ve undirectional data flow ilkelerini takip eder. İşte katmanlı mimari için bazı best practiceler: . | Recommendation | Description | . | Açıkça tanımlanmış bir data katmanı kullanın. Strongly recommended: | Data katmanı, uygulama verilerini uygulamanın geri kalanına sunar ve uygulamanızın business logic’inin büyük çoğunluğunu içerir.&lt;/br&gt; * Sadece tek bir veri kaynağı içerse bile veri repositorylerini oluşturmalısınız. &lt;/br&gt;* Küçük uygulamalarda, data katmanı türlerini bir data paketine veya modülüne yerleştirmeyi seçebilirsiniz | . | Açıkça tanımlanmış bir UI katmanı kullanın. Strongly recommended: | UI katmanı, uygulama verilerini ekranda görüntüler ve kullanıcı etkileşiminin birincil noktası olarak hizmet eder.&lt;/br&gt;* Küçük uygulamalarda, data katmanı tiplerini bir UI paketine veya modülüne yerleştirmeyi seçebilirsiniz.Daha fazla UI katmanı best practiceleri burada. | . | Data katmanı, bir repository kullanarak uygulama verilerini açığa çıkarmalıdır. Strongly recommended: | UI katmanındaki componentler, activity’ler veya ViewModel’lar gibi componentler doğrudan bir veri kaynağı ile etkileşime girmemelidir. Veri kaynaklarına örnekler şunlardır: &lt;/br&gt;* Databases, DataStore, SharedPreferences, Firebase APIs.&lt;/br&gt; * GPS location providers. &lt;/br&gt; * Bluetooth data providers.&lt;/br&gt; * Network connectivity status provider. | . | Coroutines ve flowlari kullanin. Strongly recommended: | Katmanlar arasında iletişim kurmak için coroutine’leri ve flow’ları kullanın. More coroutines best practices here. | . | Domain layer kullanin. Recommended in big apps | Birden fazla ViewModel’de data katmanıyla etkileşime giren business logic’i yeniden kullanmanız gerekiyorsa veya belirli bir ViewModel’in business logic karmaşıklığını basitleştirmek istiyorsanız bir domain katmanı, use caseleri kullanın. | . UI Layer . UI katmanının rolü, uygulama verilerini ekranda görüntülemek ve kullanıcı etkileşiminin birincil noktası olarak hizmet etmektir. İşte UI katmanı için bazı best practiceler: . | Recommendation | Description | . | Unidirectional Data Flow (UDF’i takip edin.. Strongly recommended: | ViewModel’lerin observer pattern kullanarak UI state’ini gösterdiği ve metot çağrıları yoluyla UI’dan action’lar aldığı Unidirectional Data Flow (UDF) prensiplerini takip edin. | . | Faydaları uygulamanız için uygunsa AAC ViewModellerini kullanın. Strongly recommended: | Business logic’i handle etmek için AAC ViewModels’i kullanın ve UI state’ini UI’ye göstermek için uygulama verilerini getirin (Compose veya Android Views).&lt;/br&gt; See more ViewModel best practices here.&lt;/br&gt;See the benefits of ViewModels here. | . | Yaşam döngüsüne duyarlı UI state collection kullanın. Strongly recommended: | Uygun yaşam döngüsüne duyarlı coroutine builder kullanarak UI state’ini UI’dan collect edin: View sisteminde repeatOnLifecycle ve Jetpack Compose’da collectAsStateWithLifecycle.&lt;/br&gt;Read more about repeatOnLifecycle.&lt;/br&gt; Read more about about collectAsStateWithLifecycle. | . | ViewModel’den UI’ye event göndermeyin. Strongly recommended: | Event’i ViewModel’de doğrudan işleyin ve event’in işlenmesinin sonucuyla bir state güncellemesine neden olun. UI event’leri hakkında daha fazla bilgiyi burada bulabilirsiniz. | . | Single-activity application kullanin. Recommended | Uygulamanızın birden fazla ekranı varsa ekranlar arasında gezinmek ve uygulamanıza deep link vermek için Navigation Fragments veya Navigation Compose kullanın. | . | Jetpack Compose kullanin. Recommended | Telefonlar, tabletler, katlanabilir cihazlar ve Wear OS için yeni uygulamalar oluşturmak üzere Jetpack Compose’u kullanın. | . Aşağıdaki kod parçacığı, UI state’inin yaşam döngüsüne duyarlı bir şekilde nasıl collect edileceğini özetlemektedir: . //Views class MyFragment : Fragment() { private val viewModel: MyViewModel by viewModel() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycleScope.launch { viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { // Process item } } } } } //Compose @Composable fun MyScreen( viewModel: MyViewModel = viewModel() ) { val uiState by viewModel.uiState.collectAsStateWithLifecycle() } . ViewModel . ViewModeller, UI state’ini sağlamaktan ve data katmanına erişimden sorumludur. ViewModel’ler için bazı best practiceler aşağıda verilmiştir: . | Recommendation | Description | . | ViewModeller Android yaşam döngüsünden bağımsız olmalıdır. Strongly recommended: | ViewModel’ler Yaşam Döngüsü ile ilgili herhangi bir tipe referans tutmamalıdır. Activity, Fragment, Context veya Resources’ı bağımlılık olarak geçirmeyin. Bir şeyin ViewModel’de bir Context’e ihtiyacı varsa, bunun doğru katmanda olup olmadığını mutlaka değerlendirmelisiniz. | . | Coroutine’leri ve flow’ları kullanın. Strongly recommended: | ViewModel, data veya domain katmanları ile etkileşime girer:&lt;/br&gt;Uygulama verilerini almak için Kotlin flow’ları,&lt;/br&gt; viewModelScope kullanarak actionlari gerçekleştirmek için suspend fonksiyonlari kullanin. | . | Ekran seviyesinde ViewModelleri kullanın.&lt;/br&gt; Strongly recommended: | ViewModel’ları yeniden kullanılabilir UI parçalarında kullanmayın. ViewModel’leri şuralarda kullanmalısınız;&lt;/br&gt;Screen-level composables,&lt;/br&gt;Activities/Fragments in Views,&lt;/br&gt;Destinations or graphs when using Jetpack Navigation. | . | Use plain state holder classes in reusable UI components.&lt;/br&gt; Strongly recommended: | Yeniden kullanılabilir UI component’lerinde karmaşıklığı ele almak için düz state holder sınıflarını kullanın. Bunu yaparak, state harici olarak çağrılabilir ve kontrol edilebilir. | . | AndroidViewModel kullanma. Recommended | ViewModel class kullanin, AndroidViewModel kullanmayin. ViewModelde Application class kullanmamalisiniz. Bunun yerine, bağımlılığı UI veya data katmanına taşıyın. | . | Bir UI state açığa çıkarın. Recommended | ViewModeller, uiState adlı single property aracılığıyla UI’ye veri göstermelidir. UI birden fazla, ilgisiz veri parçası gösteriyorsa, VM multiple UI state property gösterebilir.&lt;/br&gt;uiState’i bir StateFlow yapmalısınız.&lt;/br&gt;Veriler hiyerarşinin diğer katmanlarından bir veri akışı olarak geliyorsa, WhileSubscribed(5000) ilkesiyle (örnek) stateIn operatörünü kullanarak uiState oluşturmalısınız.&lt;/br&gt;Data katmanından gelen veri akışlarının olmadığı daha basit durumlar için, immutable bir StateFlow olarak açığa çıkan bir MutableStateFlow kullanmak kabul edilebilir (örnek).&lt;/br&gt;Data, error ve loading sinyalleri içerebilen bir data class olarak ${Screen}UiState’e sahip olmayı seçebilirsiniz. Bu sınıf, farklı statelerin özel olması halinde sealed class da olabilir.Application sınıfı ViewModel’de kullanılmamalıdır. Application sınıfı ViewModel’de kullanılmamalıdır. Bunun yerine, bağımlılığı kullanıcı arayüzüne veya veri katmanına taşıyın. | . Aşağıdaki kod parçacığı, UI state’inin bir ViewModel’den nasıl açığa çıkarılacağını özetlemektedir: . @HiltViewModel class BookmarksViewModel @Inject constructor( newsRepository: NewsRepository ) : ViewModel() { val feedState: StateFlow&lt;NewsFeedUiState&gt; = newsRepository .getNewsResourcesStream() .mapToFeedState(savedNewsResourcesState) .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = NewsFeedUiState.Loading ) // ... } . Lifecycle . Aşağıda Android yaşam döngüsü ile çalışmaya yönelik best practiceler yer almaktadır: . | Recommendation | Description | . | Activity’lerde veya Fragment’larda yaşam döngüsü metotlarını override etmeyin.&lt;/br&gt; Strongly recommended: | Activity’lerde veya Fragment’larda onResume gibi yaşam döngüsü metodlarını override etmeyin. Bunun yerine LifecycleObserver kullanın. Uygulamanın, yaşam döngüsü belirli bir Lifecycle.State değerine ulaştığında iş yapması gerekiyorsa repeatOnLifecycle API’sini kullanın. | . Aşağıdaki kod parçacığı, belirli bir Yaşam Döngüsü state’i verildiğinde işlemlerin nasıl gerçekleştirileceğini özetlemektedir: . //Views class MyFragment: Fragment() { override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) viewLifecycleOwner.lifecycle.addObserver(object : DefaultLifecycleObserver { override fun onResume(owner: LifecycleOwner) { // ... } override fun onPause(owner: LifecycleOwner) { // ... } } } } //Compose @Composable fun MyApp() { val lifecycleOwner = LocalLifecycleOwner.current DisposableEffect(lifecycleOwner, ...) { val lifecycleObserver = object : DefaultLifecycleObserver { override fun onStop(owner: LifecycleOwner) { // ... } } lifecycleOwner.lifecycle.addObserver(lifecycleObserver) onDispose { lifecycleOwner.lifecycle.removeObserver(lifecycleObserver) } } } . Handle dependencies . Componentler arasındaki bağımlılıkları yönetirken gözlemlemeniz gereken birkaç best practice vardir: . | Recommendation | Description | . | Dependency injection kullanin.&lt;/br&gt; Strongly recommended: | Dependency injection best practiceleri kullanin, ozellikle mumkun oldugunca constructor injection kullanin. | . | Gerektiginde bir componentin scope’nu belirleyin.&lt;/br&gt; Strongly recommended: | Scope to a dependency container; tip paylaşılması gereken mutable veriler içerdiğinde veya tipin init edilmesi pahalı olduğunda ve uygulamada yaygın olarak kullanıldığında. | . | Hilt kullanin. Recommended | Basit uygulamalarda Hilt veya manual dependency injection kullanin. Uygulamaniz karmasiklastiginda Hilt kullanin. Ornegin asagidakilere sahipseniz: &lt;/br&gt;Multiple screens with ViewModels—integration&lt;/br&gt;WorkManager usage—integration&lt;/br&gt;Advance usage of Navigation, such as ViewModels scoped to the nav graph—integration. | . Testing . Aşağıda test için bazı best practiceler verilmiştir: . | Recommendation | Description | . | Neyi test edeceginizi bilin. Strongly recommended: | Unless the project is roughly as simple as a hello world app, you should test it, at minimum with:&lt;/br&gt;Unit test ViewModels, including Flows.&lt;/br&gt;Unit test data layer entities. That is, repositories and data sources.&lt;/br&gt;UI navigation tests that are useful as regression tests in CI. | . | Prefer fakes to mocks. Strongly recommended: | Read more in the Use test doubles in Android documentation. | . | Test StateFlows. Strongly recommended: | When testing StateFlow:&lt;/br&gt;Assert on the value property whenever possible&lt;/br&gt;You should create a collectJob if using WhileSubscribed | . Daha fazla bilgi için Android DAC’da neleri test etmeli kılavuzuna bakın. Models . Uygulamalarınızda model geliştirirken bu best practiceleri uymalısınız: . | Recommendation | Description | . | Karmaşık uygulamalarda her katman için bir model oluşturun. Recommended | Karmaşık uygulamalarda, mantıklı olduğunda farklı katmanlarda veya componentlerde yeni modeller oluşturun. Aşağıdaki örnekleri göz önünde bulundurun:&lt;/br&gt;Uzak bir veri kaynağı, ağ üzerinden aldığı modeli, yalnızca uygulamanın ihtiyaç duyduğu verileri içeren daha basit bir sınıfla eşleyebilir&lt;/br&gt;Repository’ler DAO modellerini sadece UI katmanının ihtiyaç duyduğu bilgilerle daha basit data classlara eşleyebilir.&lt;/br&gt;ViewModel, UiState sınıflarındaki data katmanı modellerini içerebilir. | . Naming Conventions . Kod tabanınızı adlandırırken, aşağıdaki best practice’lerden haberdar olmalısınız: . | Recommendation | Description | . | Methodlari isimlendirmek.&lt;/br&gt; Optional: | Metodlar bir fiil cümlesi olmalıdır. Örneğin, makePayment(). | . | Propertyleri isimlendirmek.&lt;/br&gt; Optional: | Propertyler bir isim cümlesi olmalıdır. Örneğin, inProgressTopicSelection. | . | Data akislarini isimlendirmek&lt;/br&gt; Optional: | Bir sınıf bir Flow stream, LiveData veya başka bir stream sunduğunda, adlandırma kuralı get{model}Stream() şeklindedir. Örneğin, getAuthorStream(): Flow. Fonksiyon bir model listesi döndürüyorsa, model adı çoğul olmalıdır:getAuthorsStream(): Flow&lt;List&gt; | . | Interface implementasyonlarini isimlendirmek.&lt;/br&gt; Optional: | Interfacelerin implementasyonları için isimler anlamlı olmalıdır. Daha iyi bir isim bulunamazsa önek olarak Default kullanın. Örneğin, bir NewsRepository interface’i için OfflineFirstNewsRepository veya InMemoryNewsRepository kullanabilirsiniz. Eğer iyi bir isim bulamazsanız, DefaultNewsRepository kullanın. Sahte implementasyonların önüne FakeAuthorsRepository’de olduğu gibi Fake eklenmelidir. | . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/architecture-recommendatios.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/architecture-recommendatios.html"
  },"45": {
    "doc": "Best practices for multi-module projects",
    "title": "Best practices for multi-module projects",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/best-practices-for-multi-module-projects.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/best-practices-for-multi-module-projects.html"
  },"46": {
    "doc": "Best practices for shortcuts",
    "title": "Best practices for shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/best-practices-for-shortcuts.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/best-practices-for-shortcuts.html"
  },"47": {
    "doc": "Best practices",
    "title": "Best practices",
    "content": " ",
    "url": "/docs/best-practices",
    
    "relUrl": "/docs/best-practices"
  },"48": {
    "doc": "Bind layout views to architecture components",
    "title": "Bind layout views to architecture components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/bind-layout-views-to-archtecture-components.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/bind-layout-views-to-archtecture-components.html"
  },"49": {
    "doc": "Binding adapters",
    "title": "Binding adapters",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/binding-adapters.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/binding-adapters.html"
  },"50": {
    "doc": "Build Your First App",
    "title": "Build Your First App",
    "content": " ",
    "url": "/docs/app-basics/build-your-first-app.html",
    
    "relUrl": "/docs/app-basics/build-your-first-app.html"
  },"51": {
    "doc": "category",
    "title": "category",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/category.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/category.html"
  },"52": {
    "doc": "Color state list",
    "title": "Color state list",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/color-state-list.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/color-state-list.html"
  },"53": {
    "doc": "Common patterns",
    "title": "Common patterns",
    "content": " ",
    "url": "/docs/app-architecture/modularization/common-patterns.html",
    
    "relUrl": "/docs/app-architecture/modularization/common-patterns.html"
  },"54": {
    "doc": "Communicate with fragments",
    "title": "Communicate with fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/communicate-with-fragments.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/communicate-with-fragments.html"
  },"55": {
    "doc": "action",
    "title": "action",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/compatible-screens.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/compatible-screens.html"
  },"56": {
    "doc": "Complex XML resources",
    "title": "Complex XML resources",
    "content": " ",
    "url": "/docs/app-basics/app-resources/complex-xml-resources.html",
    
    "relUrl": "/docs/app-basics/app-resources/complex-xml-resources.html"
  },"57": {
    "doc": "Conditional navigation",
    "title": "Conditional navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/conditional-navigation.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/conditional-navigation.html"
  },"58": {
    "doc": "Core topics",
    "title": "Core topics",
    "content": " ",
    "url": "/docs/core-topics",
    
    "relUrl": "/docs/core-topics"
  },"59": {
    "doc": "Create a deep link for a destination",
    "title": "Create a deep link for a destination",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/create-a-deep-link-for-a-destination.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/create-a-deep-link-for-a-destination.html"
  },"60": {
    "doc": "Create a fragment",
    "title": "Create a fragment",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/create-a-fragment.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/create-a-fragment.html"
  },"61": {
    "doc": "Create app links for instant apps",
    "title": "Create app links for instant apps",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/create-app-links-for-instant-apps.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/create-app-links-for-instant-apps.html"
  },"62": {
    "doc": "Create a destination",
    "title": "Create a destination",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/create-destination.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/create-destination.html"
  },"63": {
    "doc": "Create shortcuts",
    "title": "Create shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/create-shortcuts.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/create-shortcuts.html"
  },"64": {
    "doc": "Create swipe views with tabs using ViewPager",
    "title": "Create swipe views with tabs using ViewPager",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager.html"
  },"65": {
    "doc": "Create swipe views with tabs using ViewPager2",
    "title": "Create swipe views with tabs using ViewPager2",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager2.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/create-swipe-views-with-tabs-using-viewpager2.html"
  },"66": {
    "doc": "Create ViewModels with dependencies",
    "title": "Create ViewModels with dependencies",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/create-viewmodels-with-dependencies.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/create-viewmodels-with-dependencies.html"
  },"67": {
    "doc": "Custom back navigation",
    "title": "Custom back navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/custom-back-navigation.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/custom-back-navigation.html"
  },"68": {
    "doc": "Dagger basics",
    "title": "Dagger basics",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/dagger-basics.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/dagger-basics.html"
  },"69": {
    "doc": "Dagger",
    "title": "Dagger",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/dagger.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/dagger.html"
  },"70": {
    "doc": "Data binding library",
    "title": "Data binding library",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/data-binding-library.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/data-binding-library.html"
  },"71": {
    "doc": "Data layer libraries",
    "title": "Data layer libraries",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/data-layer-libraries.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/data-layer-libraries.html"
  },"72": {
    "doc": "Data layer",
    "title": "Data layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/data-layer.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/data-layer.html"
  },"73": {
    "doc": "data",
    "title": "data",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/data.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/data.html"
  },"74": {
    "doc": "Datastore",
    "title": "Datastore",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/datastore.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/datastore.html"
  },"75": {
    "doc": "Debug your fragments",
    "title": "Debug your fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/debug-your-fragments.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/debug-your-fragments.html"
  },"76": {
    "doc": "Dependency Injection",
    "title": "Dependency Injection",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dependency-injection.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dependency-injection.html"
  },"77": {
    "doc": "Dependency injection with Hilt",
    "title": "Dependency injection with Hilt",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dependency-injetion-with-hilt.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dependency-injetion-with-hilt.html"
  },"78": {
    "doc": "Design for different form factors",
    "title": "Design for different form factors",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/design-for-different-form-factors.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/design-for-different-form-factors.html"
  },"79": {
    "doc": "Design navigation graphs",
    "title": "Design navigation graphs",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/design-navigation-graphs.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/design-navigation-graphs.html"
  },"80": {
    "doc": "Display paged lists",
    "title": "Display paged lists",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/display-paged-lists.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/display-paged-lists.html"
  },"81": {
    "doc": "Displaying dialogs with DialogFragment",
    "title": "Displaying dialogs with DialogFragment",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/displaying-dialogs-with-dialogfragment.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/displaying-dialogs-with-dialogfragment.html"
  },"82": {
    "doc": "Domain layer",
    "title": "Domain layer",
    "content": "Domain katmanı, UI katmanı ile data katmanı arasında yer alan isteğe bağlı bir katmandır. Domain katmanı, karmaşık business logic’in veya birden fazla ViewModel tarafından yeniden kullanılan basit business logic’in enkapsüle edilmesinden sorumludur. Bu katman isteğe bağlıdır çünkü tüm uygulamalar bu gereksinimlere sahip olmayacaktır. Yalnızca gerektiğinde kullanmalısınız - örneğin, karmaşıklığı handle etmek veya yeniden kullanılabilirliği kolaylaştırmak için. Domain katmanı aşağıdaki faydaları sağlar: . | Kod tekrarını önler. | Domain katmanı sınıflarını kullanan sınıflarda okunabilirliği artırır. | Uygulamanın test edilebilirliğini artırır. | Sorumlulukları bölmenize izin vererek büyük sınıfları önler. | . Bu sınıfları basit ve hafif tutmak için, her kullanım senaryosu yalnızca tek bir fonksiyonellik üzerinde sorumluluk sahibi olmalı ve mutable veri içermemelidir. Bunun yerine mutable verileri UI veya data katmanlarınızda ele almalısınız. Not: Bu sayfadaki öneriler ve best practiceler, ölçeklenmelerini sağlamak, kaliteyi ve sağlamlığı artırmak ve test edilmelerini kolaylaştırmak için geniş bir uygulama yelpazesine uygulanabilir. Ancak, bunları kılavuz olarak ele almalı ve gerektiğinde gereksinimlerinize göre uyarlamalısınız. Architecture: The Domain Layer - MAD Skills . Naming conventions in this guide . Bu kılavuzda, use case’ler sorumlu oldukları tek bir eylemden sonra adlandırılır. Kurallar aşağıdaki gibidir: . şimdiki zamanda fiil + isim/ne (isteğe bağlı) + UseCase. Örneğin: FormatDateUseCase, LogOutUserUseCase, GetLatestNewsWithAuthorsUseCase veya MakeLoginRequestUseCase. Dependencies . Tipik bir uygulama mimarisinde, use case sınıfları UI katmanındaki ViewModel’ler ile data katmanındaki repository’ler arasında yer alır. Bu, use case sınıflarının genellikle repository sınıflarına bağlı olduğu ve UI katmanı ile repository’lerin yaptığı gibi iletişim kurduğu anlamına gelir - ya callback’ler (Java için) ya da coroutine’ler (Kotlin için) kullanarak. Bu konuda daha fazla bilgi edinmek için data layer sayfasına bakın. Örneğin, uygulamanızda bir haber repository’sinden ve bir yazar repository’sinden veri alan ve bunları birleştiren bir use case sınıfınız olabilir: . class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository ) { /* ... */ } . Use case’ler yeniden kullanılabilir lojik içerdiğinden, diğer use case’ler tarafından da kullanılabilirler. Domain katmanında birden fazla use case seviyesi olması normaldir. Örneğin, aşağıdaki örnekte tanımlanan use case, UI katmanındaki birden fazla sınıfın ekranda uygun mesajı görüntülemek için saat dilimlerine güvenmesi durumunda FormatDateUseCase use case’ini kullanabilir: . class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository, private val formatDateUseCase: FormatDateUseCase ) { /* ... */ } . Example dependency graph for a use case that depends on other use cases . Call use cases in Kotlin . Kotlin’de, invoke() fonksiyonunu operatör modifier ile tanımlayarak use case sınıf instance’larını fonksiyon olarak çağrılabilir hale getirebilirsiniz. Aşağıdaki örneğe bakın: . class FormatDateUseCase(userRepository: UserRepository) { private val formatter = SimpleDateFormat( userRepository.getPreferredDateFormat(), userRepository.getPreferredLocale() ) operator fun invoke(date: Date): String { return formatter.format(date) } } . Bu örnekte, FormatDateUseCase’deki invoke() metodu, sınıfın instance’larını fonksiyonlarmış gibi çağırmanıza olanak tanır. invoke() metodu belirli bir imza ile sınırlandırılmamıştır; herhangi bir sayıda parametre alabilir ve herhangi bir tip döndürebilir. Ayrıca invoke() metodunu sınıfınızda farklı imzalarla overload edebilirsiniz. Yukarıdaki örnekteki use case’i aşağıdaki gibi çağırırsınız: . class MyViewModel(formatDateUseCase: FormatDateUseCase) : ViewModel() { init { val today = Calendar.getInstance() val todaysDate = formatDateUseCase(today) /* ... */ } } . invoke() operatörü hakkında daha fazla bilgi edinmek için Kotlin dokümanlarına bakın. Lifecycle . Use Case’lerin kendi yaşam döngüleri yoktur. Bunun yerine, onları kullanan sınıfa göre scopelandırılırlar. Bu, use case’leri UI katmanındaki sınıflardan, hizmetlerden veya Application sınıfının kendisinden çağırabileceğiniz anlamına gelir. Use case’ler mutable veriler içermemesi gerektiğinden, bir use case sınıfını bağımlılık olarak her ilettiğinizde bu sınıfın yeni bir instance’ını oluşturmanız gerekir. Threading . Domain katmanındaki Use Case’ler main-safe olmalıdır; başka bir deyişle, main thread’den çağrılmaları güvenli olmalıdır. Use case sınıfları uzun süren bloklama işlemleri gerçekleştiriyorsa, bu lojiği uygun iş parçacığına taşımaktan sorumludurlar. Ancak bunu yapmadan önce, bu engelleme işlemlerinin hiyerarşinin diğer katmanlarına yerleştirilmesinin daha iyi olup olmayacağını kontrol edin. Tipik olarak, karmaşık hesaplamalar yeniden kullanılabilirliği veya önbelleğe almayı teşvik etmek için data katmanında gerçekleşir. Örneğin, büyük bir liste üzerindeki yoğun kaynak gerektiren bir işlem, sonucun uygulamanın birden fazla ekranında yeniden kullanılabilmesi için önbelleğe alınması gerekiyorsa, domain katmanından ziyade data katmanına daha iyi yerleştirilir. Aşağıdaki örnekte, çalışmasını bir background thread üzerinde gerçekleştiren bir use case gösterilmektedir: . class MyUseCase( private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default ) { suspend operator fun invoke(...) = withContext(defaultDispatcher) { // Long-running blocking operations happen on a background thread. } } . Common Tasks . Bu bölümde, yaygın domain katmanı görevlerinin nasıl gerçekleştirileceği açıklanmaktadır. Reusable simple business logic UI katmanında bulunan tekrarlanabilir business logic’i bir use case sınıfında encapsulate etmelisiniz. Bu, logic’in kullanıldığı her yerde herhangi bir değişikliği gerçekleştirmeyi kolaylaştırır. Ayrıca lojiği izole bir şekilde test etmenize de olanak tanır. Daha önce açıklanan FormatDateUseCase örneğini düşünün. Tarih biçimlendirmeyle ilgili iş gereksinimleriniz gelecekte değişirse, kodu yalnızca tek bir merkezi yerde değiştirmeniz gerekir. Not: Bazı durumlarda, use case'lerde bulunabilecek lojik, bunun yerine Util sınıflarındaki statik metotların bir parçası olabilir. Ancak, Util sınıflarını bulmak genellikle zor olduğundan ve işlevlerini keşfetmek zor olduğundan, ikincisi önerilmez. Ayrıca, use case'ler temel sınıflarda thread ve error handling gibi ortak işlevleri paylaşabilir ve bu da ölçek olarak daha büyük ekiplere fayda sağlayabilir. Combine repositories . Bir haber uygulamasında, sırasıyla haber ve yazar veri işlemlerini gerçekleştiren NewsRepository ve AuthorsRepository sınıflarına sahip olabilirsiniz. NewsRepository’nin sunduğu Article sınıfı yalnızca yazarın adını içerir, ancak ekranda yazar hakkında daha fazla bilgi görüntülemek istersiniz. Yazar bilgileri AuthorsRepository’den elde edilebilir. Logic birden fazla repository içerdiğinden ve karmaşık hale gelebileceğinden, logic’i ViewModel’den soyutlamak ve daha okunabilir hale getirmek için bir GetLatestNewsWithAuthorsUseCase sınıfı oluşturursunuz. Bu aynı zamanda logic’in tek başına test edilmesini ve uygulamanın farklı bölümlerinde yeniden kullanılabilir olmasını kolaylaştırır. /** * This use case fetches the latest news and the associated author. */ class GetLatestNewsWithAuthorsUseCase( private val newsRepository: NewsRepository, private val authorsRepository: AuthorsRepository, private val defaultDispatcher: CoroutineDispatcher = Dispatchers.Default ) { suspend operator fun invoke(): List&lt;ArticleWithAuthor&gt; = withContext(defaultDispatcher) { val news = newsRepository.fetchLatestNews() val result: MutableList&lt;ArticleWithAuthor&gt; = mutableListOf() // This is not parallelized, the use case is linearly slow. for (article in news) { // The repository exposes suspend functions val author = authorsRepository.getAuthor(article.authorId) result.add(ArticleWithAuthor(article, author)) } result } } . Logic, haber listesindeki tüm öğeleri mapler; bu nedenle data katmanı main-safe olsa da, bu iş main thread’i bloke etmemelidir çünkü kaç öğeyi process edeceğini bilemezsiniz. Bu nedenle use case, varsayılan dispatcher’ı kullanarak işi bir background thread’e taşır. Not: Room kütüphanesi, bir veritabanındaki farklı entityler arasındaki ilişkileri sorgulamanızı sağlar. Veritabanı source of truth ise, tüm bu işi sizin için yapan bir query oluşturabilirsiniz. Bu durumda, bir use case yerine NewsWithAuthorsRepository gibi bir repository sınıfı oluşturmak daha iyidir. Other consumers . UI katmanının yanı sıra, domain katmanı servisler ve Application sınıfı gibi diğer sınıflar tarafından da yeniden kullanılabilir. Ayrıca, TV veya Wear gibi diğer platformlar mobil uygulama ile kod tabanını paylaşıyorsa, UI katmanları da domain katmanının yukarıda bahsedilen tüm avantajlarını elde etmek için use case’leri yeniden kullanabilir. Data layer access restriction . Domain katmanını implemente ederken göz önünde bulundurmanız gereken bir diğer husus da UI katmanından data katmanına doğrudan erişime izin vermeniz ya da her şeyi domain katmanı üzerinden yapmaya zorlamanız gerekip gerekmediğidir. Bu kısıtlamayı yapmanın bir avantajı, örneğin data katmanına her erişim isteğinde analitik loglama yapıyorsanız, UI’nizin domain katmanı logic’ini bypass etmesini engellemesidir. Bununla birlikte, potansiyel olarak önemli dezavantajı, sizi data katmanına basit fonksiyon çağrıları olsa bile use case’ler eklemeye zorlamasıdır, bu da çok az fayda için karmaşıklık yaratabilir. İyi bir yaklaşım, use case’leri yalnızca gerektiğinde eklemektir. UI katmanınızın verilere neredeyse yalnızca use case’ler aracılığıyla eriştiğini fark ederseniz, verilere yalnızca bu şekilde erişmek mantıklı olabilir. Nihayetinde data katmanına erişimi kısıtlama kararı, kod tabanınıza ve katı kuralları mı yoksa daha esnek bir yaklaşımı mı tercih ettiğinize bağlıdır. Testing Domain katmanını test ederken genel test kılavuzu geçerlidir. Diğer UI testleri için geliştiriciler genellikle sahte repository’ler kullanır ve domain katmanını test ederken de sahte repository’ler kullanmak iyi bir yöntemdir. Sample . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/domain-layer.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/domain-layer.html"
  },"83": {
    "doc": "Drawable",
    "title": "Drawable",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/drawable.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/drawable.html"
  },"84": {
    "doc": "Enabling links to app content",
    "title": "Enabling links to app content",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/enabling-links-to-app-content.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/enabling-links-to-app-content.html"
  },"85": {
    "doc": "Font",
    "title": "Font",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/font.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/font.html"
  },"86": {
    "doc": "Fragment lifecycle",
    "title": "Fragment lifecycle",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragment-lifecycle.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragment-lifecycle.html"
  },"87": {
    "doc": "Fragment manager",
    "title": "Fragment manager",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragment-manager.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragment-manager.html"
  },"88": {
    "doc": "Fragment transactions",
    "title": "Fragment transactions",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragment-transactions.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragment-transactions.html"
  },"89": {
    "doc": "Fragments",
    "title": "Fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/fragments.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/fragments.html"
  },"90": {
    "doc": "Generated binding classes",
    "title": "Generated binding classes",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/generated-binding-classes.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/generated-binding-classes.html"
  },"91": {
    "doc": "Get started",
    "title": "Get started",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/get-started.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/get-started.html"
  },"92": {
    "doc": "Getting started",
    "title": "Getting started",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/getting-started.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/getting-started.html"
  },"93": {
    "doc": "Getting started",
    "title": "Getting started",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/getting-started.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/getting-started.html"
  },"94": {
    "doc": "Global actions",
    "title": "Global actions",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/global-actions.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/global-actions.html"
  },"95": {
    "doc": "grant-uri-permission",
    "title": "grant-uri-permission",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/grant-uri-permission.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/grant-uri-permission.html"
  },"96": {
    "doc": "Guide to app architecture",
    "title": "Guide to app architecture",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/guide-to-app-architecture.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/guide-to-app-architecture.html"
  },"97": {
    "doc": "Handle configuration changes",
    "title": "Handle configuration changes",
    "content": " ",
    "url": "/docs/app-basics/app-resources/handle-configuration-changes.html",
    
    "relUrl": "/docs/app-basics/app-resources/handle-configuration-changes.html"
  },"98": {
    "doc": "Handle configuration changes",
    "title": "Handle configuration changes",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/handle-configuration-changes.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/handle-configuration-changes.html"
  },"99": {
    "doc": "Lifecycle-aware components",
    "title": "Lifecycle-aware components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/handle-lifecycles.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/handle-lifecycles.html"
  },"100": {
    "doc": "Hilt and Dagger annotations cheat sheet",
    "title": "Hilt and Dagger annotations cheat sheet",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/hilt-and-dagger-annotations-cheat-sheet.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/hilt-and-dagger-annotations-cheat-sheet.html"
  },"101": {
    "doc": "Hilt in multi-module apps",
    "title": "Hilt in multi-module apps",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/hilt-in-multi-module-apps.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/hilt-in-multi-module-apps.html"
  },"102": {
    "doc": "Hilt testing guide",
    "title": "Hilt testing guide",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/hilt-testing-guide.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/hilt-testing-guide.html"
  },"103": {
    "doc": "How to guides",
    "title": "How to guides",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/how-to-guides/how-to-guides.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/how-to-guides/how-to-guides.html"
  },"104": {
    "doc": "Ana Sayfa",
    "title": "Android Dokümantasyonu Türkçe Çeviri Projesi",
    "content": "Bu proje, Android dokümantasyonunun Türkçe çevirisini oluşturmak amacıyla başlatılmıştır. Android platformunun genişleyen ve gelişen yapısı nedeniyle, geliştiricilerin öğrenmek ve anlamak istedikleri konuları daha rahat anlayabilecekleri bir dilde sunmak amacıyla böyle bir proje hayata geçirilmiştir. Bu GitHub sayfası, proje ekibi tarafından çevirisi yapılmış olan Android dokümantasyonunun Türkçe sürümüne erişmenizi sağlamak için oluşturulmuştur. Ayrıca projeye katılmak ve çeviri sürecine katkıda bulunmak isteyen geliştiricilerin de buradan projeye dahil olabileceği bir ortam sunulmaktadır. Projenin ilerleyişi ve son durumu hakkında güncel bilgilere bu sayfa üzerinden erişebilirsiniz. Ayrıca projenin GitHub deposuna da erişim sağlayarak, kodlar üzerinde değişiklik yapabilir ve pull requestler ile projeye katkıda bulunabilirsiniz. Bu projede yer alarak, Android geliştirme topluluğuna katkıda bulunmuş olacak ve Türkçe dilinde daha geniş bir Android dokümantasyonu kütüphanesi oluşmasına destek vermiş olacaksınız. ",
    "url": "/#android-dok%C3%BCmantasyonu-t%C3%BCrk%C3%A7e-%C3%A7eviri-projesi",
    
    "relUrl": "/#android-dokümantasyonu-türkçe-çeviri-projesi"
  },"105": {
    "doc": "Ana Sayfa",
    "title": "Proje Ekibi",
    "content": "Mustafa UNLU . ",
    "url": "/#proje-ekibi",
    
    "relUrl": "/#proje-ekibi"
  },"106": {
    "doc": "Ana Sayfa",
    "title": "Ana Sayfa",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"107": {
    "doc": "instrumentation",
    "title": "instrumentation",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/instrumentation.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/instrumentation.html"
  },"108": {
    "doc": "intent-filter",
    "title": "intent-filter",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/intent-filter.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/intent-filter.html"
  },"109": {
    "doc": "Interact programmatically",
    "title": "Interact programmatically",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/interact-programmatically.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/interact-programmatically.html"
  },"110": {
    "doc": "Introduction to activities",
    "title": "Introduction to activities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/introcution-to-activities.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/introcution-to-activities.html"
  },"111": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "Uygulama mimarisi tasarımı(app architecture design), uygulamalarınızın sağlam, test edilebilir ve sürdürülebilir olmasını sağlamak için önemli bir husustur. Android, uygulamanızı best practicelere göre oluşturmanıza yardımcı olacak bir dizi library ve component sağlar. Building a scalable, modularized, testable app from scratch . | Guide to app architecture ile sağlam bir uygulamayı bir araya getirmenin temellerini öğrenin. | Uygulama navigasyonunda ince ayar yaparak kullanıcı deneyimini iyileştirin. | Dependency injection kılavuzlarıyla boilerplate kodlari azaltın ve kodunuzun bakımını kolaylaştırın. | . ",
    "url": "/docs/app-architecture/introduction.html",
    
    "relUrl": "/docs/app-architecture/introduction.html"
  },"112": {
    "doc": "Kotlin DSL",
    "title": "Kotlin DSL",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/kotlin-dsl.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/kotlin-dsl.html"
  },"113": {
    "doc": "Language and locale resolution",
    "title": "Language and locale resolution",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/language-and-locale-resolution.html",
    
    "relUrl": "/docs/app-basics/app-resources/localization/language-and-locale-resolution.html"
  },"114": {
    "doc": "layout",
    "title": "layout",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/layout.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/layout.html"
  },"115": {
    "doc": "Layout",
    "title": "Layout",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/layout.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/layout.html"
  },"116": {
    "doc": "Layouts and binding expressions",
    "title": "Layouts and binding expressions",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/layouts-and-binding-expressions.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/layouts-and-binding-expressions.html"
  },"117": {
    "doc": "Learning pathway",
    "title": "Learning Pathway",
    "content": "Learning Pathway icin tiklayiniz. ",
    "url": "/docs/app-architecture/guide-to-app-architecture/learning-pathway.html#learning-pathway",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/learning-pathway.html#learning-pathway"
  },"118": {
    "doc": "Learning pathway",
    "title": "Learning pathway",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/learning-pathway.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/learning-pathway.html"
  },"119": {
    "doc": "Lifecycle-aware components",
    "title": "Lifecycle-aware components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/lifecycle-aware-components.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/lifecycle-aware-components.html"
  },"120": {
    "doc": "LiveData",
    "title": "LiveData",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/livedata.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/livedata.html"
  },"121": {
    "doc": "About paging",
    "title": "About paging",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/load-and-display-paged-data.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/load-and-display-paged-data.html"
  },"122": {
    "doc": "Load page data",
    "title": "Load page data",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/load-page-data.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/load-page-data.html"
  },"123": {
    "doc": "Loaders",
    "title": "Loaders",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/loaders.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/loaders.html"
  },"124": {
    "doc": "Localization",
    "title": "Localization",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/localization.html",
    
    "relUrl": "/docs/app-basics/app-resources/localization/localization.html"
  },"125": {
    "doc": "Localize your app",
    "title": "Localize your app",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/localize-your-app.html",
    
    "relUrl": "/docs/app-basics/app-resources/localization/localize-your-app.html"
  },"126": {
    "doc": "Manage and present loading states",
    "title": "Manage and present loading states",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/manage-and-present-loading-states.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/manage-and-present-loading-states.html"
  },"127": {
    "doc": "Manage shortcuts",
    "title": "Manage shortcuts",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/app-shortcuts/manage-shortcuts.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/app-shortcuts/manage-shortcuts.html"
  },"128": {
    "doc": "manifest",
    "title": "manifest",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/manifest.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/manifest.html"
  },"129": {
    "doc": "Manual dependency injection",
    "title": "Manual dependency injection",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/manual-dependency-injection.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/manual-dependency-injection.html"
  },"130": {
    "doc": "Layout",
    "title": "Layout",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/menu.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/menu.html"
  },"131": {
    "doc": "meta-data",
    "title": "meta-data",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/meta-data.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/meta-data.html"
  },"132": {
    "doc": "Migrate from Kotlin Synthetics to View Binding",
    "title": "Migrate from Kotlin Synthetics to View Binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/migrate-from-kotlin-synthetics-to-view-binding.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/migrate-from-kotlin-synthetics-to-view-binding.html"
  },"133": {
    "doc": "Migrate to Paging 3",
    "title": "Migrate to Paging 3",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/migrate-to-paging-3.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/migrate-to-paging-3.html"
  },"134": {
    "doc": "Migrate to the Navigation component",
    "title": "Migrate to the Navigation component",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/migrate-to-the-nanvigation-component.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/migrate-to-the-nanvigation-component.html"
  },"135": {
    "doc": "Migrating from Firebase JobDispatcher",
    "title": "Migrating from Firebase JobDispatcher",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-firebase-jobdispatcher.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-firebase-jobdispatcher.html"
  },"136": {
    "doc": "Migrating from GCMNetworkManager",
    "title": "Migrating from GCMNetworkManager",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-gcmnetworkmanager.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/migrating-from-gcmnetworkmanager.html"
  },"137": {
    "doc": "Modularization",
    "title": "Modularization",
    "content": " ",
    "url": "/docs/app-architecture/modularization/modularization.html",
    
    "relUrl": "/docs/app-architecture/modularization/modularization.html"
  },"138": {
    "doc": "More types",
    "title": "More types",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/more-types.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/more-types.html"
  },"139": {
    "doc": "Navigate to a destination",
    "title": "Navigate to a destination",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/navigate-to-a-destination.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/navigate-to-a-destination.html"
  },"140": {
    "doc": "Navigate with feature modules",
    "title": "Navigate with feature modules",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/navigate-with-feature-modules.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/navigate-with-feature-modules.html"
  },"141": {
    "doc": "Navigation component",
    "title": "Navigation component",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/navigation-component.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/navigation-component.html"
  },"142": {
    "doc": "Navigation",
    "title": "Navigation",
    "content": " ",
    "url": "/docs/app-architecture/modularization/navigation.html",
    
    "relUrl": "/docs/app-architecture/modularization/navigation.html"
  },"143": {
    "doc": "Nested graphs",
    "title": "Nested graphs",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/nested-graphs.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/nested-graphs.html"
  },"144": {
    "doc": "Offline first",
    "title": "Offline first",
    "content": "Çevrimdışı öncelikli(offline-first) bir uygulama, temel işlevselliğinin tamamını veya kritik bir alt kümesini internet erişimi olmadan gerçekleştirebilen bir uygulamadır. Yani, iş mantığının bir kısmını veya tamamını çevrimdışı olarak gerçekleştirebilir. Çevrimdışı öncelikli bir uygulama oluşturmaya yönelik hususlar, uygulama verilerine ve business logic’e erişim sunan data katmanında başlar. Uygulamanın bu verileri zaman zaman cihaz dışındaki kaynaklardan yenilemesi gerekebilir. Bunu yaparken, güncel kalmak için ağ kaynaklarını kullanması gerekebilir. Ağ kullanılabilirliği her zaman garanti edilmez. Cihazlarda genellikle ağ bağlantısının zayıf veya yavaş olduğu dönemler olabilir. Kullanıcılar aşağıdakilerle karşılaşabilir: . | Sınırlı internet bant genişliği | Asansör veya tünelde olduğu gibi geçici bağlantı kesintileri. | Ara sıra veri erişimi. Örneğin, yalnızca WiFi kullanan tabletler. | . Nedeni ne olursa olsun, bir uygulamanın bu koşullarda yeterli şekilde çalışması genellikle mümkündür. Uygulamanızın çevrimdışı olarak doğru şekilde çalıştığından emin olmak için aşağıdakileri yapabilmelidir: . | Güvenilir bir ağ bağlantısı olmadan kullanılabilirliğini sürdürme. | İlk ağ çağrısının tamamlanmasını veya başarısız olmasını beklemek yerine kullanıcılara yerel verileri hemen sunun. | Pil ve veri durumunun bilincinde olacak şekilde veri alın. Örneğin, yalnızca şarj olurken veya WiFi’da olduğu gibi en uygun koşullarda veri getirme talebinde bulunarak. Yukarıdaki kriterleri karşılayabilen bir uygulama genellikle çevrimdışı öncelikli uygulama(offline-first app) olarak adlandırılır. | . Create offline-first apps . Design an offline-first app . Çevrimdışı öncelikli bir uygulama tasarlarken data katmanından ve uygulama verileri üzerinde gerçekleştirebileceğiniz iki ana işlemden başlamalısınız: . | Reads: Kullanıcıya bilgi göstermek gibi uygulamanın diğer bölümleri tarafından kullanılmak üzere veri çekme. | Writes: User input’u daha sonra kullanmak üzere kalıcı hale getirme. | . Veri katmanındaki repository‘ler, uygulama verilerini sağlamak için veri kaynaklarını birleştirmekten sorumludur. Çevrimdışı öncelikli bir uygulamada, en kritik görevlerini gerçekleştirmek için ağ erişimine ihtiyaç duymayan en az bir veri kaynağı olmalıdır. Bu kritik görevlerden biri de veri okumaktır. Not: En azından, çevrimdışı öncelikli bir uygulama ağ erişimi olmadan okuma yapabilmelidir. Model data in an offline-first app . Çevrimdışı öncelikli bir uygulama, ağ kaynaklarını kullanan her repository için en az 2 veri kaynağına sahiptir: . | Local veri kaynağı | Network veri kaynağı | . Not: Çevrimdışı öncelikli bir uygulamada ağ erişimi olan bir repository her zaman lokal bir veri kaynağına sahip olmalıdır. The local data source . Lokal veri kaynağı, uygulama için standart haline gelmiş source of truth‘tır. Uygulamanın daha yüksek katmanlarının okuduğu tüm verilerin özel kaynağı olmalıdır. Bu, bağlantı durumları arasında veri tutarlılığı sağlar. Lokal veri kaynağı genellikle diske kalıcı olarak aktarılan bir depolama alanı tarafından desteklenir. Verileri diske kalıcı hale getirmenin bazı yaygın yolları şunlardır: . | Room gibi ilişkisel veritabanları gibi yapılandırılmış veri kaynakları. | Yapılandırılmamış veri kaynakları. Örneğin, Datastore ile protocol buffers. | Basit dosyalar | . The network data source . Network veri kaynağı uygulamanın gerçek state’idir. Lokal veri kaynağı en iyi ihtimalle network veri kaynağı ile senkronize edilir. Bunun gerisinde de kalabilir, bu durumda uygulamanın tekrar çevrimiçi olduğunda güncellenmesi gerekir. Tersine, network veri kaynağı, bağlantı geri geldiğinde uygulama onu güncelleyene kadar lokal veri kaynağının gerisinde kalabilir. Uygulamanın domain ve UI katmanları asla network katmanı ile doğrudan bağlantı kurmamalıdır. Onunla iletişim kurmak ve lokal veri kaynağını güncellemek için onu kullanmak hosting repository’nin sorumluluğundadır. Exposing resources . Lokal ve network veri kaynakları, uygulamanızın bunları nasıl okuyabileceği ve yazabileceği konusunda temel farklılıklar gösterebilir. Lokal bir veri kaynağını sorgulamak, SQL sorguları kullanmak gibi hızlı ve esnek olabilir. Buna karşılık, network veri kaynakları yavaş ve kısıtlı olabilir, örneğin RESTful kaynaklarına id ile artımlı olarak erişirken olduğu gibi. Sonuç olarak, her veri kaynağı genellikle sağladığı verilerin kendi temsiline ihtiyaç duyar. Bu nedenle lokal veri kaynağı ve network veri kaynağı kendi modellerine sahip olabilir. Aşağıdaki dizin yapısı bu kavramı görselleştirmektedir. AuthorEntity, uygulamanın lokal veritabanından okunan bir yazarın temsilidir ve NetworkAuthor, network üzerinden serileştirilen bir yazarın temsilidir: . data/ ├─ local/ │ ├─ entities/ │ │ ├─ AuthorEntity │ ├─ dao/ │ ├─ NiADatabase ├─ network/ │ ├─ NiANetwork │ ├─ models/ │ │ ├─ NetworkAuthor ├─ model/ │ ├─ Author ├─ repository/ . AuthorEntity ve NetworkAuthor’un ayrıntıları aşağıdaki gibidir: . /** * Network representation of [Author] */ @Serializable data class NetworkAuthor( val id: String, val name: String, val imageUrl: String, val twitter: String, val mediumPage: String, val bio: String, ) /** * Defines an author for either an [EpisodeEntity] or [NewsResourceEntity]. * It has a many-to-many relationship with both entities */ @Entity(tableName = \"authors\") data class AuthorEntity( @PrimaryKey val id: String, val name: String, @ColumnInfo(name = \"image_url\") val imageUrl: String, @ColumnInfo(defaultValue = \"\") val twitter: String, @ColumnInfo(name = \"medium_page\", defaultValue = \"\") val mediumPage: String, @ColumnInfo(defaultValue = \"\") val bio: String, ) . Hem AuthorEntity hem de NetworkAuthor’u veri katmanının içinde tutmak ve harici katmanların kullanması için üçüncü bir türü ortaya çıkarmak iyi bir pratiktir. Bu, harici katmanları, uygulamanın davranışını temelden değiştirmeyen lokal ve network veri kaynaklarındaki küçük değişikliklerden korur. Bu, aşağıdaki snippet’te gösterilmiştir: . /** * External data layer representation of a \"Now in Android\" Author */ data class Author( val id: String, val name: String, val imageUrl: String, val twitter: String, val mediumPage: String, val bio: String, ) . Network modeli daha sonra bunu lokal modele dönüştürmek için bir extension metodu tanımlayabilir ve lokal model de benzer şekilde aşağıda gösterildiği gibi bunu harici temsile dönüştürmek için bir metoda sahiptir: . /** * Converts the network model to the local model for persisting * by the local data source */ fun NetworkAuthor.asEntity() = AuthorEntity( id = id, name = name, imageUrl = imageUrl, twitter = twitter, mediumPage = mediumPage, bio = bio, ) /** * Converts the local model to the external model for use * by layers external to the data layer */ fun AuthorEntity.asExternalModel() = Author( id = id, name = name, imageUrl = imageUrl, twitter = twitter, mediumPage = mediumPage, bio = bio, ) . Not: Yukarıdaki gibi mapper'lar genellikle farklı modüllerde tanımlanan modeller arasında eşleme yapar. Sonuç olarak, tightly coupled modüllerden kaçınmak için bu mapperlari kullanıldıkları modüllerde tanımlamak genellikle faydalıdır. Daha fazla ayrıntı için [modularization kılavuzu](/docs/app-architecture/modularization/common-patterns.md#module-to-module-communication)na bakın. Reads . Okumalar, çevrimdışı öncelikli bir uygulamada uygulama verileri üzerindeki temel işlemdir. Bu nedenle, uygulamanızın verileri okuyabildiğinden ve yeni veriler mevcut olur olmaz uygulamanın bunları görüntüleyebildiğinden emin olmalısınız. Bunu yapabilen bir uygulama reaktif bir uygulamadır çünkü okuma API’lerini observable tiplerle sunarlar. Aşağıdaki kod parçasında, OfflineFirstTopicRepository tüm okuma API’leri için Flow döndürür. Bu, network veri kaynağından güncellemeler aldığında okuyucularını güncellemesini sağlar. Başka bir deyişle, OfflineFirstTopicRepository’nin lokal veri kaynağı invalid edildiğinde değişiklikleri iletmesine olanak tanır. Bu nedenle, OfflineFirstTopicRepository’nin her okuyucusu, uygulamaya network bağlantısı yeniden sağlandığında tetiklenebilecek veri değişikliklerini ele almaya hazır olmalıdır. Ayrıca, OfflineFirstTopicRepository verileri doğrudan lokal veri kaynağından okur. Veri değişikliklerini okuyucularına ancak önce lokal veri kaynağını güncelleyerek bildirebilir. class OfflineFirstTopicsRepository( private val topicDao: TopicDao, private val network: NiaNetworkDataSource, ) : TopicsRepository { override fun getTopicsStream(): Flow&lt;List&lt;Topic&gt;&gt; = topicDao.getTopicEntitiesStream() .map { it.map(TopicEntity::asExternalModel) } } . Not: Çevrimdışı öncelikli bir uygulamada repository'lerden okuma işlemleri doğrudan lokal veri kaynağından okunmalıdır. Herhangi bir güncelleme önce lokal veri kaynağına yazılmalıdır ve lokal veri kaynağı observable olduğu için tüketicilerini güncelleyecektir. Error handling strategies . Çevrimdışı öncelikli uygulamalarda hataları ele almanın, oluşabilecekleri veri kaynaklarına bağlı olarak benzersiz yolları vardır. Aşağıdaki alt bölümlerde bu stratejiler özetlenmektedir. | Local data source Lokal veri kaynağından okuma sırasında oluşan hatalar nadir olmalıdır. Okuyucuları hatalardan korumak için, okuyucunun veri topladığı Flow’larda catch operatörünü kullanın. | . Bir ViewModel’de catch operatörünün kullanımı aşağıdaki gibidir: . class AuthorViewModel( authorsRepository: AuthorsRepository, ... ) : ViewModel() { private val authorId: String = ... // Observe author information private val authorStream: Flow&lt;Author&gt; = authorsRepository.getAuthorStream( id = authorId ) .catch { emit(Author.empty()) } } . Not: catch operatörü yalnızca exception'ın uygulamayı çökertmesini engeller, backing Flow yine de sonlanır. Exception'dan sonra flow'tan collecting'e devam etmek için [retry](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/retry.html) metodunu kullanın. | Network data source Bir network veri kaynağından veri okunurken hata oluşursa, uygulamanın veri getirmeyi yeniden denemek için bir heuristic yöntem kullanması gerekecektir. Yaygın heuristic yöntemler şunlardır: . | Exponential backoff . Exponential backoff‘ta uygulama, başarılı olana veya diğer koşullar durması gerektiğini belirleyene kadar artan zaman aralıklarıyla network veri kaynağından okumayı denemeye devam eder. Uygulamanın backing off yapmaya devam edip etmeyeceğini değerlendirmek için kriterler şunlardır: . | Network veri kaynağının belirttiği hata türü. Örneğin, bağlantı eksikliğini gösteren bir hata döndüren network çağrılarını yeniden denemelisiniz. Tersine, uygun kimlik bilgileri mevcut olana kadar yetkilendirilmemiş HTTP isteklerini yeniden denememelisiniz. | İzin verilen maksimum yeniden deneme sayısı. | . | Network connectivity monitoring Bu yaklaşımda, uygulama network veri kaynağına bağlanabileceğinden emin olana kadar okuma istekleri kuyruğa alınır. Bağlantı kurulduktan sonra okuma isteği kuyruktan çıkarılır, veri okunur ve lokal veri kaynağı güncellenir. Android’de bu kuyruk bir Room veritabanı ile tutulabilir ve WorkManager kullanılarak kalıcı iş olarak tüketilebilir. | . | . Writes . Çevrimdışı öncelikli bir uygulamada veri okumak için önerilen yol observable tipleri kullanmak olsa da, yazma API’leri için eşdeğer olan suspend fonksiyonları gibi asenkron API’lerdir. Bu, UI thread’inin engellenmesini önler ve çevrimdışı öncelikli uygulamalardaki yazma işlemleri bir network sınırını geçerken başarısız olabileceğinden hata ele almaya yardımcı olur. interface UserDataRepository { /** * Updates the bookmarked status for a news resource */ suspend fun updateNewsResourceBookmark(newsResourceId: String, bookmarked: Boolean) } . Yukarıdaki kod parçasında, yukarıdaki metot askıya aldığı için tercih edilen asenkron API Coroutines‘tir. Write strategies . Çevrimdışı öncelikli uygulamalarda veri yazarken göz önünde bulundurulması gereken üç strateji vardır. Hangisini seçeceğiniz, yazılmakta olan veri türüne ve uygulamanın gereksinimlerine bağlıdır: . | Online-only writes . Verileri network sınırı boyunca yazmayı deneyin. Başarılı olursa, lokal veri kaynağını günceller, aksi takdirde bir exception atar ve uygun şekilde yanıt vermeyi çağırana bırakır. Bu strateji genellikle neredeyse gerçek zamanlı olarak çevrimiçi gerçekleşmesi gereken yazma işlemleri için kullanılır. Örneğin, bir banka transferi. Yazma işlemleri başarısız olabileceğinden, genellikle kullanıcıya yazmanın başarısız olduğunu bildirmek veya kullanıcının ilk etapta veri yazmaya çalışmasını önlemek gerekir. Bu senaryolarda kullanabileceğiniz bazı stratejiler şunları içerebilir: . | Bir uygulama veri yazmak için internet erişimi gerektiriyorsa, kullanıcıya veri yazmasına izin veren bir UI sunmamayı veya en azından bunu devre dışı bırakmayı tercih edebilir. | Kullanıcının çevrimdışı olduğunu bildirmek için kullanıcının reddedemeyeceği bir açılır mesaj veya geçici bir mesaj kullanabilirsiniz. | . | Queued writes . Yazmak istediğiniz bir nesne olduğunda, bunu bir kuyruğa ekleyin. Uygulama tekrar çevrimiçi olduğunda exponential back off ile kuyruğu tüketmeye devam edin. Android’de çevrimdışı bir kuyruğu tüketmek, genellikle WorkManager’a devredilen kalıcı bir iştir. Bu yaklaşım aşağıdaki durumlarda iyi bir seçimdir: . | Verilerin ağa yazılması zorunlu değildir. | İşlem zamana duyarlı değildir. | İşlemin başarısız olması durumunda kullanıcının bilgilendirilmesi gerekli değildir. | . Bu yaklaşımın kullanım alanları arasında analytics eventlar ve loglama yer alır. | Lazy writes . Önce lokal veri kaynağına yazın, ardından en uygun zamanda network’e bildirmek için yazma işlemini kuyruğa alın. Uygulama tekrar çevrimiçi olduğunda network ve lokal veri kaynakları arasında çakışmalar olabileceğinden bu önemsiz bir işlem değildir. Çakışma çözümü ile ilgili bir sonraki bölümde daha fazla ayrıntı verilmektedir. Bu yaklaşım, veriler uygulama için kritik olduğunda doğru seçimdir. Örneğin, çevrimdışı öncelikli bir yapılacaklar listesi uygulamasında, veri kaybı riskini önlemek için kullanıcının çevrimdışı olarak eklediği tüm görevlerin lokal olarak saklanması çok önemlidir. Not: Çevrimdışı öncelikli uygulamalarda veri yazmak, olası çakışmalar nedeniyle genellikle veri okumaktan daha fazla dikkat gerektirir. Çevrimdışı öncelikli uygulamaların çevrimdışı öncelikli olarak kabul edilmesi için çevrimdışıyken veri yazabilmesi gerekmez. | . Synchronization and conflict resolution . Çevrimdışı öncelikli bir uygulama bağlantısını geri yüklediğinde, lokal veri kaynağındaki verileri network veri kaynağındaki verilerle bağdaştırması gerekir. Bu işleme senkronizasyon denir. Bir uygulamanın network veri kaynağıyla senkronize olmasının iki ana yolu vardır: 1-Pull-based synchronization, 2-Push-based synchronization . | Pull-based synchronization | . Pull-based senkronizasyonda uygulama, talep üzerine en son uygulama verilerini okumak için network’e ulaşır. Bu yaklaşım için yaygın bir heuristic yontem, uygulamanın verileri yalnızca kullanıcıya sunmadan hemen önce aldığı navigation-based’dir. Bu yaklaşım, uygulamanın network bağlantısının olmadığı kısa veya ara dönemler beklediği durumlarda en iyi sonucu verir. Bunun nedeni, veri yenilemenin fırsatçı olması ve uzun süreli bağlantısızlık durumlarında kullanıcının eskimiş ya da boş bir önbellekle uygulama hedeflerini ziyaret etmeye çalışması olasılığının artmasıdır. Belirli bir ekran için sonsuz kaydırma listesindeki öğeleri getirmek üzere sayfa token’larının kullanıldığı bir uygulama düşünün. Uygulama lazy bir şekilde networke ulaşabilir, verileri lokal veri kaynağında kalıcı hale getirebilir ve daha sonra bilgileri kullanıcıya geri sunmak için lokal veri kaynağından okuyabilir. Network bağlantısının olmadığı durumlarda, repository sadece lokal veri kaynağından veri talep edebilir. Bu, Jetpack Paging Library tarafından RemoteMediator API‘si ile kullanılan modeldir. class FeedRepository(...) { fun feedPagingSource(): PagingSource&lt;FeedItem&gt; { ... } } class FeedViewModel( private val repository: FeedRepository ) : ViewModel() { private val pager = Pager( config = PagingConfig( pageSize = NETWORK_PAGE_SIZE, enablePlaceholders = false ), remoteMediator = FeedRemoteMediator(...), pagingSourceFactory = feedRepository::feedPagingSource ) val feedPagingData = pager.flow } . Pull Based senkronizasyonun avantaj ve dezavantajları aşağıdaki tabloda özetlenmiştir: . | Avantaj | Dezavantaj | . | Uygulaması nispeten kolay. | Yoğun veri kullanımına yatkındır. Bunun nedeni, bir navigasyon hedefine tekrarlanan ziyaretlerin, değişmeyen bilgilerin gereksiz yere yeniden alınmasını tetiklemesidir. Bunu uygun önbellekleme ile azaltabilirsiniz. Bu, cachedIn operatörü ile UI katmanında veya bir HTTP önbelleği ile network katmanında yapılabilir. | . | İhtiyaç duyulmayan veriler asla getirilmeyecektir | Çekilen modelin kendi kendine yeterli olması gerektiğinden ilişkisel verilerle iyi ölçeklenmez. Senkronize edilen model, kendisini doldurmak için getirilecek diğer modellere bağlıysa, daha önce bahsedilen yoğun veri kullanımı sorunu daha da önemli hale gelecektir. Ayrıca, üst modelin repository’leri ile iç içe geçmiş modelin repository’leri arasında bağımlılıklara neden olabilir. | . | Push-based synchronization | . Push based senkronizasyonda, lokal veri kaynağı network veri kaynağının bir replika setini elinden geldiğince taklit etmeye çalışır. Bir baseline belirlemek için ilk başlangıçta proaktif olarak uygun miktarda veri çeker, daha sonra bu veriler eskidiğinde kendisini uyarması için sunucudan gelen bildirimlere güvenir. Eskimiş bildiriminin alınmasının ardından uygulama, yalnızca eskimiş olarak işaretlenen verileri güncellemek için network’e ulaşır. Bu iş, network veri kaynağına ulaşan ve lokal veri kaynağına getirilen verileri kalıcı hale getiren Repository’ye devredilir. Repository verilerini gözlemlenebilir tiplerle sunduğundan, okuyucular herhangi bir değişiklikten haberdar edilecektir. class UserDataRepository(...) { suspend fun synchronize() { val userData = networkDataSource.fetchUserData() localDataSource.saveUserData(userData) } } . Bu yaklaşımda, uygulama network veri kaynağına çok daha az bağımlıdır ve uzun süreler boyunca onsuz çalışabilir. Çevrimdışıyken hem okuma hem de yazma erişimi sunar çünkü lokal olarak network veri kaynağından en son bilgilere sahip olduğu varsayılır. Push based senkronizasyonun avantajları ve dezavantajları aşağıdaki tabloda özetlenmiştir: . | Avantaj | Dezavantaj | . | Uygulama süresiz olarak çevrimdışı kalabilir. | Çakışma çözümü için verilerin versiyonlanması önemsizdir. | . | Minimum veri kullanımı. Uygulama yalnızca değişen verileri alır. | Senkronizasyon sırasında yazma endişelerini dikkate almanız gerekir. | . | İlişkisel veriler için iyi çalışır. Her repository yalnızca desteklediği model için veri getirmekten sorumludur. | Network veri kaynağının senkronizasyonu desteklemesi gerekir. | . | Hybrid synchronization | . Bazı uygulamalar, verilere bağlı olarak pull veya push based olan hibrit bir yaklaşım kullanır. Örneğin, bir sosyal medya uygulaması, akış güncellemelerinin yüksek sıklığı nedeniyle kullanıcının takip akışını talep üzerine almak için pull based senkronizasyon kullanabilir. Aynı uygulama, kullanıcı adı, profil resmi vb. dahil olmak üzere oturum açan kullanıcı hakkındaki veriler için push based senkronizasyonu kullanmayı tercih edebilir. Sonuç olarak, çevrimdışı öncelikli senkronizasyon seçimi ürün gereksinimlerine ve mevcut teknik altyapıya bağlıdır. Not: Uygulamanızın senkronizasyon yöntemi, uygulamanızın ihtiyaçlarına ve lokal ve network veri kaynaklarını destekleyen altyapının kısıtlamalarına bağlıdır. Conflict resolution . Uygulama çevrimdışıyken lokal olarak network veri kaynağıyla uyumsuz veri yazıyorsa, senkronizasyon gerçekleşmeden önce çözmeniz gereken bir çakışma meydana gelmiştir. Çakışma çözümü genellikle versiyonlama gerektirir. Uygulamanın, değişikliklerin ne zaman gerçekleştiğini takip etmek için bazı kayıt tutma işlemleri yapması gerekecektir. Bu, meta verileri network veri kaynağına aktarmasını sağlar. Network veri kaynağı daha sonra source of truth sağlama sorumluluğuna sahiptir. Uygulamanın ihtiyaçlarına bağlı olarak çakışma çözümü için dikkate alınması gereken çok çeşitli stratejiler vardır. Mobil uygulamalar için yaygın bir yaklaşım “son yazan kazanır(last write wins) “dır. | Last write wins | . Bu yaklaşımda, cihazlar network’e yazdıkları verilere zaman damgası metadatası eklerler. Network veri kaynağı bunları aldığında, mevcut state’inden daha yeni olanları kabul ederken mevcut state’inden daha eski olan verileri reddeder. Yukarıdaki şekilde, her iki cihaz da çevrimdışıdır ve başlangıçta network veri kaynağı ile senkronizedir. Çevrimdışıyken, her ikisi de lokal olarak veri yazar ve verilerini yazdıkları zamanı takip ederler. Her ikisi de tekrar çevrimiçi olduğunda ve network veri kaynağı ile senkronize edildiğinde, network, B cihazının verilerini daha sonra yazdığı için bu cihazın verilerini kalıcı hale getirerek çakışmayı çözer. WorkManager in offline-first apps . Yukarıda ele alınan okuma ve yazma stratejilerinin her ikisinde de iki ortak araç vardı: . | Queues . | Reads: Network bağlantısı mevcut olana kadar okumaları ertelemek için kullanılır. | Writes: Network bağlantısı mevcut olana kadar yazmaları ertelemek ve yeniden denemeler için yazmaları yeniden istemek için kullanılır. | . | Network connectivity monitors . | Reads: Uygulama bağlandığında okuma kuyruğunu boşaltmak ve senkronizasyon için bir sinyal olarak kullanılır | Writes: Uygulama bağlandığında yazma kuyruğunu boşaltmak ve senkronizasyon için bir sinyal olarak kullanılır | . | . Her iki durum da WorkManager’ın üstün olduğu persistent work örnekleridir. Örneğin Now in Android örnek uygulamasında, WorkManager lokal veri kaynağını senkronize ederken hem okuma kuyruğu hem de ağ monitörü olarak kullanılır. Başlangıçta, uygulama aşağıdaki eylemleri gerçekleştirir: . | Lokal veri kaynağı ile network veri kaynağı arasında eşitlik olduğundan emin olmak için okuma senkronizasyon işini kuyruga alın. | Okuma senkronizasyon kuyruğunu boşaltın ve uygulama çevrimiçi olduğunda senkronize etmeye başlayın. | Network veri kaynağından exponential backoff kullanarak bir okuma gerçekleştirin. | Okuma sonuçlarını, oluşabilecek çakışmaları çözerek yerel veri kaynağına aktarın. | Lokal veri kaynağındaki verileri uygulamanın diğer katmanlarının kullanması için sunun. | Yukarıda anlatılanlar aşağıdaki şemada gösterilmiştir: | . WorkManager ile senkronizasyon işinin kuyruğa alınması, KEEP ExistingWorkPolicy ile benzersiz iş olarak belirtilerek takip edilir: . class SyncInitializer : Initializer&lt;Sync&gt; { override fun create(context: Context): Sync { WorkManager.getInstance(context).apply { // Queue sync on app startup and ensure only one // sync worker runs at any time enqueueUniqueWork( SyncWorkName, ExistingWorkPolicy.KEEP, SyncWorker.startUpSyncWork() ) } return Sync } } . Not: \"Now in Android \"deki okuma kuyruğu sadece enqueueUniqueWork API'si ile temsil edilebilecek kadar basittir. Kuyruğun boşaltılma sırası hakkında daha sıkı garantiler için, Room veya Datastore gibi bir veri kalıcılığı API'si ile daha sağlam bir kuyruk uygulamasının gerçekleştirilmesi gerekecektir. Daha sonra bu kuyruğu sırayla boşaltmak için bir Worker ayarlanabilir. Burada SyncWorker.startupSyncWork() aşağıdaki gibi tanımlanır: . /** Create a WorkRequest to call the SyncWorker using a DelegatingWorker. This allows for dependency injection into the SyncWorker in a different module than the app module without having to create a custom WorkManager configuration. */ fun startUpSyncWork() = OneTimeWorkRequestBuilder&lt;DelegatingWorker&gt;() // Run sync as expedited work if the app is able to. // If not, it runs as regular work.setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST) .setConstraints(SyncConstraints) // Delegate to the SyncWorker.setInputData(SyncWorker::class.delegatedData()) .build() val SyncConstraints get() = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() . Özellikle, SyncConstraints tarafından tanımlanan Kısıtlamalar(Constraints) NetworkType‘ın NetworkType.CONNECTED olmasını gerektirir. Yani, çalışmadan önce network kullanılabilir olana kadar bekler. Network kullanılabilir olduğunda, Worker uygun Repository instance’larına temsilci atayarak SyncWorkName tarafından belirtilen benzersiz iş kuyruğunu boşaltır. Senkronizasyon başarısız olursa doWork() metodu Result.retry() ile döner. WorkManager, exponential backoff ile senkronizasyonu otomatik olarak yeniden deneyecektir. Aksi takdirde, senkronizasyonu tamamlayarak Result.success() döndürür. class SyncWorker(...) : CoroutineWorker(appContext, workerParams), Synchronizer { override suspend fun doWork(): Result = withContext(ioDispatcher) { // First sync the repositories in parallel val syncedSuccessfully = awaitAll( async { topicRepository.sync() }, async { authorsRepository.sync() }, async { newsRepository.sync() }, ).all { it } if (syncedSuccessfully) Result.success() else Result.retry() } } . Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/data-layer/offline-first.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/data-layer/offline-first.html"
  },"145": {
    "doc": "Page from network and database",
    "title": "Page from network and database",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/page-from-network-and-database.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/page-from-network-and-database.html"
  },"146": {
    "doc": "Paging 2",
    "title": "Paging 2",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/paging-2.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-2/paging-2.html"
  },"147": {
    "doc": "Paging library",
    "title": "Paging library",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-library.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/paging-library.html"
  },"148": {
    "doc": "Parcelables and bundles",
    "title": "Parcelables and bundles",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/parcelables-and-bundles.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/parcelables-and-bundles.html"
  },"149": {
    "doc": "Pass data between destinations",
    "title": "Pass data between destinations",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/pass-data-between-destinations.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/pass-data-between-destinations.html"
  },"150": {
    "doc": "path-permission",
    "title": "path-permission",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/path-permission.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/path-permission.html"
  },"151": {
    "doc": "Per-app language preferences",
    "title": "Per-app language preferences",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/perapp-language-preferences.html",
    
    "relUrl": "/docs/app-basics/app-resources/localization/perapp-language-preferences.html"
  },"152": {
    "doc": "permission-group",
    "title": "permission-group",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/permission-group.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/permission-group.html"
  },"153": {
    "doc": "permission tree",
    "title": "permission tree",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/permission-tree.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/permission-tree.html"
  },"154": {
    "doc": "permission",
    "title": "permission",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/permission.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/permission.html"
  },"155": {
    "doc": "Predictive back gesture",
    "title": "Predictive back gesture",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/predictive-back-gesture.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/add-support-for-back-navigation/predictive-back-gesture.html"
  },"156": {
    "doc": "Principles of navigation",
    "title": "Principles of navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/principles-of-navigation.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/principles-of-navigation.html"
  },"157": {
    "doc": "Processes and app lifecycle",
    "title": "Processes and app lifecycle",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/processes-and-app-lifecycle.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/processes-and-app-lifecycle.html"
  },"158": {
    "doc": "property",
    "title": "property",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/property.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/property.html"
  },"159": {
    "doc": "receiver",
    "title": "receiver",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/receiver.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/receiver.html"
  },"160": {
    "doc": "Recents screen",
    "title": "Recents screen",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/recents-screen.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/recents-screen.html"
  },"161": {
    "doc": "Recipes",
    "title": "Recipes",
    "content": " ",
    "url": "/docs/app-architecture/modularization/recipes.html",
    
    "relUrl": "/docs/app-architecture/modularization/recipes.html"
  },"162": {
    "doc": "Resource types",
    "title": "Resource types",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/resource-types.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/resource-types.html"
  },"163": {
    "doc": "Restrictions on starting activities from the background",
    "title": "Restrictions on starting activities from the background",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/restrictions-on-starting-activities-from-the-background.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/restrictions-on-starting-activities-from-the-background.html"
  },"164": {
    "doc": "Save UI states",
    "title": "Save UI states",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/save-ui-states.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/save-ui-states.html"
  },"165": {
    "doc": "Saved state module for ViewModel",
    "title": "Saved state module for ViewModel",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/saved-state-module-for-viewmodel.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/saved-state-module-for-viewmodel.html"
  },"166": {
    "doc": "Saving state with fragments",
    "title": "Saving state with fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/saving-state-with-fragments.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/saving-state-with-fragments.html"
  },"167": {
    "doc": "service",
    "title": "service",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/service.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/service.html"
  },"168": {
    "doc": "State holders and UI state",
    "title": "State holders and UI state",
    "content": "UI layer kılavuzu, UI katmanı için UI State oluşturma ve yönetme aracı olarak tek yönlü veri akışını (UDF) tartışır. Ayrıca, UDF yönetimini state holder adı verilen özel bir sınıfa devretmenin faydalarını da vurgular. Bir state holderi ViewModel veya düz bir sınıf aracılığıyla uygulayabilirsiniz. Bu dokümantasyon, state holderleri ve UI katmanında oynadıkları role daha yakından bakıyor. Bu belgenin sonunda, UI katmanında application state’inin nasıl yönetileceğini anlamalısınız; bu, UI state production pipelinedir. Aşağıdakileri anlayabilmeli ve bilmelisiniz: . | UI katmanında bulunan UI state türlerini anlayın. | UI katmanındaki bu UI stateleri üzerinde çalışan logic türlerini anlayın. | ViewModel veya basit bir sınıf gibi bir state holderin uygun implementasyonunu nasıl seçeceğinizi öğrenin. | . State holders and state production in the UI Layer . Elements of the UI state production pipeline . UI state ve onu üreten logic, UI katmanını tanımlar. UI state . UI state, UI’yi tanımlayan propertydir. İki tür UI state vardır: . | Screen UI State, ekranda görüntülemeniz gereken şeydir. Örneğin, bir NewsUiState sınıfı, UI oluşturmak için gereken haber makalelerini ve diğer bilgileri içerebilir. Bu state, uygulama verilerini içerdiğinden genellikle hiyerarşinin diğer katmanlarıyla bağlantılıdır. | UI element state, UI elementlerinin nasıl oluşturulduğunu etkileyen, onlara özgü propertyleri ifade eder. Bir UI elementi gösterilebilir veya gizlenebilir ve belirli bir yazı tipine, yazı tipi boyutuna veya yazı tipi rengine sahip olabilir. Androide, View, doğası gereği stateful olduğu için bu state’i kendisi yönetir ve state’i değiştirmek veya sorgulamak için methodlar sunar. Bunun bir örneği, text için TextView sınıfının get ve set methodlaridir. Jetpack Compose’da state composable olanın dışındadır ve hatta onu composable olanın hemen yakınından çağıran composable fonksiyona veya bir state holderine hoist edebilirsiniz. Bunun bir örneği, composable Scaffold için ScaffoldState’tir. | . Logic . Uygulama verileri ve kullanıcı eventleri, UI state’inin zaman içinde değişmesine neden olduğundan, UI state statik bir property değildir. Logic, UI state’inin hangi bölümlerinin değiştiği, neden değiştiği ve ne zaman değişmesi gerektiği dahil olmak üzere değişikliğin özelliklerini belirler. Logic, business logic veya UI logic olabilir: . | Business logic, uygulama verileri için ürün gereksinimlerinin implemente edilmesidir. Örneğin, kullanıcı butona dokunduğunda bir haber okuyucu uygulamasında bir makaleye yer işareti koyma. Bir yer imini bir dosyaya veya veritabanına kaydetme logic’i genellikle domain veya data katmanlarına yerleştirilir. State holder genellikle bu logic’i, ortaya çıkardıkları metodları çağırarak bu katmanlara devreder. | UI logic, UI state’inin ekranda nasıl görüntüleneceği ile ilgilidir. Örneğin, kullanıcı bir kategori seçtiğinde doğru arama çubuğu hint elde etmek, bir listede belirli bir öğeye kaydırma yapmak veya kullanıcı bir butona tıkladığında belirli bir ekrana navigate etme logic’i. | . Android lifecycle and the types of UI state and logic . UI katmanının iki bölümü vardır: UI lifecycle’a biri bağımlı, diğeri bağımsız. Bu ayrım, her fragmentin kullanabileceği veri kaynaklarını belirler ve bu nedenle farklı türde UI state ve logic gerektirir. | UI yaşam döngüsünden bağımsız(UI lifecycle independent): UI katmanının bu kısmı, uygulamanın veri üreten katmanlarıyla (data veya domain katmanları) ilgilenir ve business logic tarafından tanımlanır. UI’deki lifecycle, configuration changes ve activity oluşturma, UI state production pipeline in etkin olup olmadığını etkileyebilir, ancak üretilen verilerin geçerliliğini etkilemez. | UI yaşam döngüsüne bağlı(UI lifecycle dependent): UI katmanının bu kısmı, UI logici ile ilgilenir ve lifecycle veya configuration changeden doğrudan etkilenir. Bu değişiklikler, içinde okunan veri kaynaklarının geçerliliğini doğrudan etkiler ve sonuç olarak state ancak lifecycle aktif olduğunda değişebilir. Buna örnek olarak runtime izinleri ve localized stringler gibi yapılandırmaya bağlı kaynakların alınması dahildir. | . Yukarıdakiler aşağıdaki tablo ile özetlenebilir: . | Ui Lifecycle independent | Ui Lifecycle dependent | . | Business logic | UI logic | . | Screen UI state |   | . The UI state production pipeline . UI state production pipeline, UI state oluşturmak için atilan adımları ifade eder. Bu adımlar, daha önce tanımlanan logic türlerinin uygulanmasını içerir ve tamamen UI gereksinimlerine bağlıdır. Bazı UI’ler, pipeline’in hem UI Lifecycle independent hem de UI Lifecycle dependent bölümlerinden yararlanabilir veya hiçbirinden yararlanamaz. Yani, UI katman pipeline’in aşağıdaki permütasyonları geçerlidir: . | UI’in kendisi tarafından üretilen ve yönetilen UI state. Örneğin, basit, yeniden kullanılabilir bir temel sayaç: | . @Composable fun Counter() { // The UI state is managed by the UI itself var count by remember { mutableStateOf(0) } Row { Button(onClick = { ++count }) { Text(text = \"Increment\") } Button(onClick = { --count }) { Text(text = \"Decrement\") } } } . | UI logic → UI. Örneğin, kullanıcının bir listenin en üstüne atlamasına olanak tanıyan bir butonu göstermek veya gizlemek. | . @Composable fun ContactsList(contacts: List&lt;Contact&gt;) { val listState = rememberLazyListState() val isAtTopOfList by remember { derivedStateOf { listState.firstVisibleItemIndex &lt; 3 } } // Create the LazyColumn with the lazyListState ... // Show or hide the button (UI logic) based on the list scroll position AnimatedVisibility(visible = !isAtTopOfList) { ScrollToTopButton() } } . | Business logic → UI. Geçerli kullanıcının fotoğrafını ekranda gösteren bir UI elementi. | . @Composable fun UserProfileScreen(viewModel: UserProfileViewModel = hiltViewModel()) { // Read screen UI state from the business logic state holder val uiState by viewModel.uiState.collectAsStateWithLifecycle() // Call on the UserAvatar Composable to display the photo UserAvatar(picture = uiState.profilePicture) } . | Business logic → UI logic → UI.Belirli bir UI state için ekranda doğru bilgileri görüntülemek üzere kayan bir UI element. | . @Composable fun ContactsList(viewModel: ContactsViewModel = hiltViewModel()) { // Read screen UI state from the business logic state holder val uiState by viewModel.uiState.collectAsStateWithLifecycle() val contacts = uiState.contacts val deepLinkedContact = uiState.deepLinkedContact val listState = rememberLazyListState() // Create the LazyColumn with the lazyListState ... // Perform UI logic that depends on information from business logic if (deepLinkedContact != null &amp;&amp; contacts.isNotEmpty()) { LaunchedEffect(listState, deepLinkedContact, contacts) { val deepLinkedContactIndex = contacts.indexOf(deepLinkedContact) if (deepLinkedContactIndex &gt;= 0) { // Scroll to deep linked item listState.animateScrollToItem(deepLinkedContactIndex) } } } } . UI state production pipeline her iki tür mantığın da uygulandığı durumda, business logic her zaman UI logicten önce uygulanmalıdır. UI logicinden sonra busines logici uygulamaya çalışmak, business logicin UI logice bağlı olduğu anlamına gelir. Aşağıdaki bölümler, farklı logic türlerine ve state holderlerine derinlemesine bir bakışla bunun neden bir sorun olduğunu ele almaktadır. State holders and their responsibilities . State holderin sorumluluğu, uygulamanın okuyabilmesi için state’i saklamaktır. Logice ihtiyaç duyulan durumlarda aracılık yaparak gerekli logici barındıran veri kaynaklarına erişim sağlar. Bu şekilde, state holder logici uygun veri kaynağına devreder. Bu, aşağıdaki faydaları sağlar: . | Basit UI’lar: UIsadece state’ini bağlar. | Sürdürülebilirlik: State holderda tanımlanan logic, UI’in kendisi değiştirilmeden yinelenebilir. | Test Edilebilirlik: UI ve state production logici bağımsız olarak test edilebilir. | Okunabilirlik: Kodu okuyanlar, UI presentation kodu ile UI state production kodu arasındaki farkları açıkça görebilir. | . Boyutu veya kapsamı ne olursa olsun, her UI elementinin karşılık gelen state holderi ile 1:1 ilişkisi vardır. Ayrıca, bir state holderin, bir UI state değişikliği ile sonuçlanabilecek herhangi bir kullanıcı eylemini kabul edebilmesi ve işleyebilmesi ve ardından gelen state değişikliğini üretebilmesi gerekir. Not: State holderler kesinlikle gerekli değildir. Basit UI’kar, logiclerini presentation kodlarıyla inline olarak barındırabilir. Types of state holders . UI state’i ve logic’i tiplerini benzer şekilde, UI katmanında, UI yaşam döngüsüyle olan ilişkilerine göre tanımlanan iki tür state holder vardır: . | The business logic state holder. | The UI logic state holder. | . Aşağıdaki bölümlerde, business logic state holderinden başlayarak state holderlerin türlerine daha yakından bakılmaktadır. Not: Bir UI logic state holderi, data veya domain katmanlarından gelen bilgilere bağlıysa, bu bilgileri ona bir business logic state holderinden iletmelisiniz. Bunun nedeni, business logic state holderinin, UI yaşam döngüsünden bağımsız olduğu için UI logici state holderinden daha uzun ömürlü olmasıdır. Business logic and its state holder . Business logic state holderlari, kullanıcı eventlerini handle eder ve verileri data veya domain katmanlarından ekran UI state’ine dönüştürür. Android yaşam döngüsü ve uygulama configuration changes göz önünde bulundurulduğunda optimum kullanıcı deneyimi sağlamak için business logic kullanan state holderlerini aşağıdaki özelliklere sahip olması gerekir: . | Property | Detail | . | Produces UI State(UI State uretmek) | Business logic state holderlar, UI için UI state’i oluşturmaktan sorumludur. Bu UI state’i, genellikle kullanıcı eventlerinin handle edilmesiyle ve domain ve data katmanlarından verilerin okunmasının sonucudur. | . | Retained through activity recreation(activitynin yeniden olusturulmasina karsi korumak) | Business logic state holderlar, Activity’nin yeniden oluşturulması karsisinda state ve state processing pipelinelerini koruyarak sorunsuz bir kullanıcı deneyimi sağlamaya yardımcı olur. State holderin korunmadigi ve yeniden yaratıldığı durumlarda (genellikle işlem ölümünden sonra), state holderin tutarlı bir kullanıcı deneyimi sağlamak için son state’i kolayca yeniden oluşturabilmesi gerekir. | . | Possess long lived state(uzun omurlu state tutmak) | Business logic state holderlari genellikle navigasyon destinationlari için state’i yönetmek amacila kullanılır. Sonuç olarak, genellikle navigasyon graphden kaldırılana kadar statelerini navigasyon değişikliklerinde korurlar. | . | Is unique to its UI and is not reusable(Kullanıcı arayüzüne özgüdür ve yeniden kullanılamaz) | Business logic state holderleri tipik olarak belirli bir uygulama fonksiyonaltesi icin üretilir, örneğin bir TaskEditViewModel veya bir TaskListViewModel için state üretir ve bu nedenle yalnızca o uygulama fonksiyonalitesi için geçerlidir. Aynı state holder, farklı form faktörlerinde bu uygulama fonksiyonalitelerini destekleyebilir. Örneğin, uygulamanın mobil, TV ve tablet sürümleri aynı business logic state holderini yeniden kullanabilir. | . Not: Business logic state holderlar; ViewModel instancelari yukarıda belirtilen özelliklerin birçoğunu, özellikle de Activity yeniden oluşturma sırasında hayatta kaldigi icin, tipik olarak bir ViewModel instance ile implement edilirler. Örneğin, “Now in Android” uygulamasında yazar navigation hedefini göz önünde bulundurun: . Business logic state holder olarak hareket eden AuthorViewModel, bu durumda UI state’ini üretir: . @HiltViewModel class AuthorViewModel @Inject constructor( savedStateHandle: SavedStateHandle, private val authorsRepository: AuthorsRepository, newsRepository: NewsRepository ) : ViewModel() { val uiState: StateFlow&lt;AuthorScreenUiState&gt; = … // Business logic fun followAuthor(followed: Boolean) { … } } . AuthorViewModel’in daha önce belirtilen business logic state holder özelliklere sahip olduğuna dikkat edin: . | Property | Detail | . | Produces AuthorScreenUiState | The AuthorViewModel reads data from the AuthorsRepository and NewsRepository and uses that data to produce AuthorScreenUiState. It also applies business logic when the user wants to follow or unfollow an Author by delegating to the AuthorsRepository. | . | Has access to the data layer | An instance of AuthorsRepository and NewsRepository are passed to it in its constructor, allowing it to implement the business logic of following an Author. | . | Survives Activity recreation | Because it is implemented with a ViewModel, it will be retained across quick Activity recreation. In the case of process death, the SavedStateHandle object can be read from to provide the minimum amount of information required to restore the UI state from the data layer. | . | Possesses long lived state | The ViewModel is scoped to the navigation graph, therefore unless the author destination is removed from the nav graph, the UI state in the uiState StateFlow remains in memory. The use of the StateFlow also adds the benefit of making the application of the business logic that produces the state lazy because state is only produced if there is a collector of the UI state. | . | Is unique to its UI | The AuthorViewModel is only applicable to the author navigation destination and cannot be reused anywhere else. If there is any business logic that is reused across navigation destinations, that business logic must be encapsulated in a data- or domain-layer-scoped component. | . Not: ViewModel'i yalnızca destination düzeyinde UI ile kullanmalısınız. Bunları, UI’in arama çubukları veya chip grupları gibi yeniden kullanılabilir parçalarında kullanmamalısınız. Bu durumlarda düz sınıflar daha uygundur. Uyarı: ViewModel instancelarini diğer composable fonksiyonlara argüman olarak vermeyin. Bunu yapmak, composable fonksiyonu ViewModel türüyle birleştirerek daha az yeniden kullanılabilir ve test edilmesini ve önizlemesini zorlaştırır. Ayrıca, ViewModel instancesini yöneten net bir tek doğruluk kaynağı (SSOT) olmayacaktır. ViewModel'i devre dışı bırakmak, birden çok composable öğenin ViewModel fonksiyonlarini çağırmasına ve state’i değiştirmesine izin vererek hataların debugini zorlaştırır. Bunun yerine, UDF best practicelerini izleyin ve yalnızca gerekli state’i iletin. Aynı şekilde, yayılan eventleri ViewModel'in composable SSOT'sine ulaşana kadar iletin. Eventi handle eden ve karşılık gelen ViewModel methodlarini çağıran SSOT budur. The ViewModel as a business logic state holder . ViewModels’in Android geliştirmedeki faydaları, onları business logice erişim sağlamak ve uygulama verilerini ekranda presentation için hazırlamak için uygun hale getirir. Bu faydalar aşağıdakileri içerir: . | ViewModels tarafından tetiklenen işlemler configuration changelerden kurtulur . | Navigasyon ile Entegrasyon saglar; . | Navigasyon, ekran backstackde iken ViewModels’i önbelleğe(cacheler) alır. Bu, destinationunuza döndüğünüzde önceden yüklenmiş verilerinizin anında kullanılabilir olması açısından önemlidir. Bu, composable ekranın yaşam döngüsünü observe eden bir state holder ile yapılması daha zor bir şeydir. | ViewModel, hedef backstackden çıkarıldığında da temizlenir ve state’inizin otomatik olarak temizlenmesini sağlar. Bu, yeni bir ekrana gitme, bir configuration change nedeniyle veya başka nedenler gibi birçok nedenden dolayı meydana gelebilecek composable imhayı dinlemekten farklıdır. | . | Hilt gibi diğer Jetpack library ile entegrasyon saglar. | . Not: ViewModel avantajları kullanım durumunuz için geçerli değilse veya işleri farklı bir şekilde yapıyorsanız, ViewModel'in sorumluluklarını düz state holder sınıflara taşıyabilirsiniz. UI logic and its state holder . UI logic, UI’nin kendisinin sağladığı veriler üzerinde çalışan logictir. Bu, UI elementlerinin state’inde veya permissions API’si veya Resources gibi UI data kaynaklarında olabilir. UI logicini kullanan state holderlar tipik olarak aşağıdaki özelliklere sahiptir: . | UI state’ini üretir ve UI elementlerinin state’ini yönetir. | Activity’i yeniden olusturma durumunda hayatta kalmaz; UI logicinde barındırılan state holderlar, genellikle UI’nin kendisinden gelen veri kaynaklarına bağımlıdır ve bu bilgileri yapılandırma değişiklikleri boyunca tutmaya çalışmak, genellikle bir bellek sızıntısına neden olur. State holderlar, yapılandırma değişikliklerinde devam etmek için verilere ihtiyaç duyarsa, hayatta kalan Aktivite yeniden olusturulmasina daha uygun başka bir componente yetki vermeleri gerekir. Örneğin, Jetpack Compose’da, remembered fonksiyonlarla oluşturulan Composable UI element stateleri, Activity yeniden olusturulmasi boyunca state’i korumak için genellikle rememberSaveable’a yetki verir. Bu tür fonksiyonlarin örnekleri arasında, rememberScaffoldState() ve rememberLazyListState() bulunur. | UI scopeindaki veri kaynaklarına referansları vardır: UI logic state holder, UI ile aynı yaşam döngüsüne sahip olduğundan, yaşam döngüsü API’leri ve Resources gibi veri kaynaklarına güvenle başvurulabilir ve okunabilir. | Birden çok UI’de yeniden kullanılabilir: Aynı UI logic state holderinin farklı instancelari, uygulamanın farklı bölümlerinde yeniden kullanılabilir. Örneğin, bir chip grubu için kullanıcı input eventlerini yönetmek için bir state holder, filter chipleri için bir arama sayfasında ve ayrıca bir e-posta alıcıları için “to” fieldi için kullanılabilir. | . UI logic state holder, tipik olarak düz bir sınıfla uygulanır. Bunun nedeni, UI logic state holderinin oluşturulmasından UI’nin kendisinin sorumlu olması ve UI logic state holderinin, UI’nin kendisi ile aynı yaşam döngüsüne sahip olmasıdır. Örneğin Jetpack Compose’da state holder, Composition’un bir parçasıdır ve Composition’un yaşam döngüsünü takip eder. Not: Düz sınıf state holderleri, UI logici, UI'den taşınacak kadar karmaşık olduğunda kullanılır. Aksi takdirde, UI logici, UI'de inline olarak uygulanabilir. Now in Android örneğindeki aşağıdaki örnekte gösterilebilir: Now in Android örneği, cihazın ekran boyutuna bağlı olarak navigtion için bir bottom appbar veya bir navigation raili gösterir. Daha küçük ekranlar alttaki appbari ve daha büyük ekranlar navigation rail kullanır. NiaApp composable fonksiyonunda kullanılan uygun navigation UI elementine karar verme logici, business logice bağlı olmadığından, NiaAppState adlı düz bir sınıf state holder tarafından yönetilebilir: . @Stable class NiaAppState( val navController: NavHostController, val windowSizeClass: WindowSizeClass ) { // UI logic val shouldShowBottomBar: Boolean get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact || windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact // UI logic val shouldShowNavRail: Boolean get() = !shouldShowBottomBar // UI State val currentDestination: NavDestination? @Composable get() = navController .currentBackStackEntryAsState().value?.destination // UI logic fun navigate(destination: NiaNavigationDestination, route: String? = null) { /* ... */ } /* ... */ } . Yukarıdaki örnekte, NiaAppState ile ilgili aşağıdaki ayrıntılar dikkat çekicidir: . | Activity yeniden olustugunda hayatta kalamaz: NiaAppState, Compose adlandırma kurallarına uygun bir Composable fonksiyonu ile rememberNiaAppState oluşturularak Compositionda hatırlanır. Activity yeniden oluşturulduktan sonra, önceki instancelar kaybolur ve yeniden oluşturulan Activity’nin yeni yapılandırmasına uygun olarak tüm bağımlılıkları iletilmiş yeni bir instance oluşturulur. Bu bağımlılıklar yeni olabilir veya önceki yapılandırmadan geri yüklenebilir. Örneğin, rememberNavController(), niaAppState constructorunda kullanılır ve Activity yeniden olusturulmasi boyunca state’i korumak için rememberSaveable’a yetki verir. | UI kapsamlı veri kaynaklarına referansları vardır: NavigationController, Resources ve diğer benzer yaşam döngüsü kapsamındaki tiplere yapılan refereanslar, aynı yaşam döngüsü kapsamını paylaştıklarından NiaAppState’te güvenle tutulabilir. | . Not: Düz state holder sınıfları, arama çubukları veya chip grupları gibi yeniden kullanılabilir kullanıcı arabirimi parçaları için önerilir. Bu durumda ViewModels'i kullanmamalısınız çünkü bunlar en iyi navigation destination için state’i yönetmek ve business logice erişim için kullanılır. Choose between a ViewModel and plain class for a state holder . Yukarıdaki bölümlerden, bir ViewModel ve bir düz sınıf state holder arasında seçim yapmak, UI state’ine uygulanan logice ve logicin üzerinde çalıştığı veri kaynaklarına iner. Not: Çoğu uygulama, aksi takdirde düz sınıf state holderine yerleştirilebilecek olan UI logicini UI’in kendisinde inline olarak gerçekleştirmeyi seçer. Bu, basit durumlar için iyidir, ancak diğer durumlar için, logici düz bir sınıf state holderine çekerek okunabilirliği artırabilirsiniz Özetle, aşağıdaki diyagram, UI State’i production pipelinedaki state holderlerinin pozisyonunu gösterir: Sonuç olarak, tüketildiği yere en yakın state holderlerini kullanarak UI state’i üretmelisiniz. Daha az resmi olarak, uygun ownershipligi surdururken state’i mümkün olduğunca düşük tutmalısınız. Business logice erişmeniz gerekiyorsa ve UI state’inin, Activity yeniden olusturulmasi genelinde bile bir ekrana gidilebildiği sürece devam etmesi gerekiyorsa, bir ViewModel, business logic state holder implement etmeniz için harika bir seçimdir. Daha kısa ömürlü UI state ve UI logic için, yaşam döngüsü yalnızca UI’ye bağlı olan düz bir sınıf yeterli olmalıdır. State holders are compoundable . Bağımlılıklar eşit veya daha kısa bir ömre sahip olduğu sürece state holderlar diğer state holderlara bağımlı olabilir. Bunun örnekleri şunlardır: . | bir UI logic state holder başka bir UI logic state holder’a bağlı olabilir. | bir screen level state holder, bir UI logic state holder’a bağlı olabilir. | . Aşağıdaki kod parçacığı, Compose’un DrawerState‘inin başka bir dahili state holder olan SwipeableState‘e nasıl bağlı olduğunu ve bir uygulamanın UI logic state holder’ının DrawerState’e nasıl bağlı olabileceğini göstermektedir: . @Stable class DrawerState(/* ... */) { internal val swipeableState = SwipeableState(/* ... */) // ... } @Stable class MyAppState( private val drawerState: DrawerState, private val navController: NavHostController ) { /* ... */ } @Composable fun rememberMyAppState( drawerState: DrawerState = rememberDrawerState(DrawerValue.Closed), navController: NavHostController = rememberNavController() ): MyAppState = remember(drawerState, navController) { MyAppState(drawerState, navController) } . Dikkat: Screen level state holderların bir ekranın veya ekranın bir kısmının business logic karmaşıklığını yönettiği göz önüne alındığında, bir screen level state holderın başka bir screen level state holdera bağlı olması mantıklı olmayacaktır. Bu senaryodaysanız, ekranlarınızı ve state holder'larınızı yeniden gözden geçirin ve ihtiyacınız olanın bu olduğundan emin olun. Bir state holder’dan daha uzun ömürlü bir bağımlılık örneği, bir screen level state holder’a bağlı olan bir UI logic state holder olabilir. Bu, daha kısa ömürlü state holder’ın yeniden kullanılabilirliğini azaltır ve gerçekte ihtiyaç duyduğundan daha fazla logic ve state’e erişmesini sağlar. Daha kısa ömürlü state holder’ın daha yüksek scope’lu bir state holder’dan belirli bilgilere ihtiyacı varsa, state holder instance’ını geçmek yerine yalnızca ihtiyaç duyduğu bilgileri parametre olarak geçirin. Örneğin, aşağıdaki kod parçasında, UI logic state holder sınıfı, ViewModel instance’ının tamamını bir bağımlılık olarak geçirmek yerine ViewModel’den parametre olarak sadece ihtiyaç duyduğu bilgileri alır. class MyScreenViewModel(/* ... */) { val uiState: StateFlow&lt;MyScreenUiState&gt; = /* ... */ fun doSomething() { /* ... */ } fun doAnotherThing() { /* ... */ } // ... } @Stable class MyScreenState( // DO NOT pass a ViewModel instance to a plain state holder class // private val viewModel: MyScreenViewModel, // Instead, pass only what it needs as a dependency private val someState: StateFlow&lt;SomeState&gt;, private val doSomething: () -&gt; Unit, // Other UI-scoped types private val scaffoldState: ScaffoldState ) { /* ... */ } @Composable fun rememberMyScreenState( someState: StateFlow&lt;SomeState&gt;, doSomething: () -&gt; Unit, scaffoldState: ScaffoldState = rememberScaffoldState() ): MyScreenState = remember(someState, doSomething, scaffoldState) { MyScreenState(someState, doSomething, scaffoldState) } @Composable fun MyScreen( modifier: Modifier = Modifier, viewModel: MyScreenViewModel = viewModel(), state: MyScreenState = rememberMyScreenState( someState = viewModel.uiState.map { it.toSomeState() }, doSomething = viewModel::doSomething ), // ... ) { /* ... */ } . Aşağıdaki diyagram, UI ile önceki kod parçacığının farklı state holder’ları arasındaki bağımlılıkları temsil etmektedir: . Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-holders-and-ui-state.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-holders-and-ui-state.html"
  },"169": {
    "doc": "State production",
    "title": "State production",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production.html"
  },"170": {
    "doc": "State production",
    "title": "UI State Production",
    "content": "Modern UI ler nadiren statiktir. Kullanıcı, UI ile etkileşime girdiğinde veya uygulamanın yeni verileri göstermesi gerektiğinde UI’in state’i değişir. Bu belge, UI state’inin üretimi(production) ve yönetimi için yönergeler belirler. Sonunda şunları yapmalısınız: . | UI state’i oluşturmak(produce) için hangi API’leri kullanmanız gerektiğini bilin. Bu, tek yönlü veri akışı(UDF) ilkelerini izleyerek state holderlerinizde bulunan state değişikliği kaynaklarının doğasına bağlıdır. | Sistem kaynaklarının bilincinde olmak için UI state’inin üretimini nasıl kapsamanız(scope) gerektiğini öğrenin. | UI tarafından tüketim için UI stateini nasıl ortaya çıkarmanız gerektiğini bilin. | . Temel olarak state üretimi(state production), bu değişikliklerin UI state’ine artımlı olarak uygulanmasıdır. State her zaman vardır ve eventler sonucunda değişir. Eventler ve state arasındaki farklar aşağıdaki tabloda özetlenmiştir: . | Event | State | . | Transient, unpredictable, and exist for a finite period.(Geçici, öngörülemeyen ve sonlu bir süre için var olan.) | Always exists.(herzaman vardir) | . | The inputs of state production.(State üretiminin girdileridir.) | The output of state production.(State uretiminin ciktisidir.) | . | The product of the UI or other sources.(UI’in veya diğer kaynaklarin urunudur.) | Is consumed by the UI.(UI tarafindan tuketilir) | . Yukarıdakileri özetleyen harika bir anımsatıcı şudur: state is; events happen. Aşağıdaki şema, eventler bir zaman çizelgesinde meydana geldikçe statedeki değişiklikleri görselleştirmeye yardımcı olur. Her event uygun state holder tarafından işlenir ve bir state değişikliğiyle sonuçlanır: . Eventler şunlardan gelebilir: . | Kullanıcılar: Uygulamanın UI ile etkileşime girdikçe. | Diğer state değişikliği kaynakları: UI’den, domainden veya snackbar zaman aşımı eventleri gibi data katmanlarından uygulama verileri sunan API’ler, sırasıyla use case siniflari veya repositoryler. | . The UI state production pipeline . Android uygulamalarındaki state production, aşağıdakilerden oluşan bir processing pipeline olarak düşünülebilir: . | Inputs;State’in kaynakları değişir. Olabilirler: . | UI katmanında local: Bunlar, bir görev yönetimi uygulamasında “yapılacak iş” için bir başlık giren bir kullanıcı gibi kullanıcı eventleri veya UI state’indeki değişiklikleri yönlendiren UI logicine erişim sağlayan API’ler olabilir. Örneğin, Jetpack Compose’da DrawerState‘te open methodunu çağırmak. | UI katmanının dışında: Bunlar, UI state’inde değişikliklere neden olan domain veya data katmanlarından gelen kaynaklardır. Örneğin, bir NewsRepository’den yüklenmesi biten haberler veya diğer eventler. | Yukarıdakilerin hepsinin bir karışımı. | . | State holders;Business logici ve/veya UI logicini state değişikliği kaynaklarına uygulayan ve UI state oluşturmak(produce) için kullanıcı eventlerini işleyen türler. | Output;Uygulamanın, kullanıcılara ihtiyaç duydukları bilgileri sağlamak için işleyebileceği UI State. | . State production APIs . Pipeline’in hangi aşamasında olduğunuza bağlı olarak state productionda kullanılan iki ana API vardır: . | Pipeline stage | API | . | Input | You should use asynchronous APIs to perform work off the UI thread to keep the UI jank free. For example, Coroutines or Flows in Kotlin, and RxJava or callbacks in the Java Programming Language. | . | Output | You should use observable data holder APIs to invalidate and rerender the UI when state changes. For example, StateFlow, Compose State, or LiveData. Observable data holders guarantee the UI always has a UI state to display on the screen. | . Bu ikisi arasından, input için asenkron API seçiminin, output için gözlemlenebilir API seçiminden çok, state production pipelinein doğası üzerinde daha büyük bir etkisi vardır. Bunun nedeni, inputlarin pipeline’a uygulanabilecek processing türünü dikte etmesidir. State production pipeline assembly . Sonraki bölümler, çeşitli inputlar için en uygun state productin tekniklerini ve eşleşen output API’lerini kapsar. Her state production pipelie, inputlarin ve outputlarin bir kombinasyonudur ve şöyle olmalıdır: . | Yaşam döngüsünün farkında(Lifecycle aware): UI’in visible veya active olmadığı durumlarda, açıkça gerekli olmadıkça state production pipeline herhangi bir kaynak tüketmemelidir. | Kullanımı kolay(Easy to consume): UI, üretilen UI state’ini kolayca oluşturabilmelidir(produce etmelidir). State production pipelinenin outputuna yönelik hususlar, View sistemi veya Jetpack Compose gibi farklı View API’lerinde değişiklik gösterecektir. | . Not: İzleyen bölümlerde, tartışılan tüm API'ler deyimsel Kotlin ve Jetpack Compose kodunu kullanır. Ancak kılavuz, Java Programlama Dili veya Kotlin'deki diğer API'lerdeki eşdeğer analogları için geçerlidir. Input in state production pipelines . Bir state production pipelinedeki inputlar, state değişikliği kaynaklarını şu yollarla sağlayabilir: . | One-shot operations that may be synchronous or asynchronous, for example calls to suspend functions. | Stream APIs, for example Flows. | All of the above. | . Aşağıdaki bölümlerde, yukarıdaki inputlarin her biri için bir state production pipline’i nasıl kurabileceğiniz ele alınmaktadır. One-shot APIs as sources of state change . MutableStateFlow API’yi gözlemlenebilir, değiştirilebilir bir state containeri olarak kullanın. Jetpack Compose uygulamalarında, özellikle Compose text API‘leri ile çalışırken mutableStateOf‘u da düşünebilirsiniz. Her iki API de barındırdıkları değerlerde güvenli atomik güncellemelere izin veren methodlar sunar, güncellemeler senkron veya asenkro olsun ya da olmasın. Örneğin, basit bir zar atma uygulamasında state güncellemelerini düşünün. Kullanıcının attığı her zar, senkronize Random.nextInt() methodunu çağırır ve sonuç, UI state’ine yazılır. // StateFlow data class DiceUiState( val firstDieValue: Int? = null, val secondDieValue: Int? = null, val numberOfRolls: Int = 0, ) class DiceRollViewModel : ViewModel() { private val _uiState = MutableStateFlow(DiceUiState()) val uiState: StateFlow&lt;DiceUiState&gt; = _uiState.asStateFlow() // Called from the UI fun rollDice() { _uiState.update { currentState -&gt; currentState.copy( firstDieValue = Random.nextInt(from = 1, until = 7), secondDieValue = Random.nextInt(from = 1, until = 7), numberOfRolls = currentState.numberOfRolls + 1, ) } } } //compose @Stable interface DiceUiState { val firstDieValue: Int? val secondDieValue: Int? val numberOfRolls: Int? } private class MutableDiceUiState: DiceUiState { override var firstDieValue: Int? by mutableStateOf(null) override var secondDieValue: Int? by mutableStateOf(null) override var numberOfRolls: Int by mutableStateOf(0) } class DiceRollViewModel : ViewModel() { private val _uiState = MutableDiceUiState() val uiState: DiceUiState = _uiState // Called from the UI fun rollDice() { _uiState.firstDieValue = Random.nextInt(from = 1, until = 7) _uiState.secondDieValue = Random.nextInt(from = 1, until = 7) _uiState.numberOfRolls = _uiState.numberOfRolls + 1 } } . Mutating the UI state from asynchronous calls . Asenkron bir sonuç gerektiren state değişiklikleri için uygun CoroutineScope’ta bir Coroutine başlatın. Bu, CoroutineScope iptal edildiğinde uygulamanın işi silmesine izin verir. State holder daha sonra suspend method çağrısının sonucunu UI state’ini ortaya çıkarmak için kullanılan gözlemlenebilir API’ye yazar. Örneğin, [Architecture örneği](https://github.com/android/architecture-samplesndeki AddEditTaskViewModel’i göz önünde bulundurun. Askıya alınan(suspend edilen) saveTask() methodu bir taski asenkron olarak kaydettiğinde, MutableStateFlow’daki update methodu state değişikliğini UI state’ine yayar. // StateFlow data class AddEditTaskUiState( val title: String = \"\", val description: String = \"\", val isTaskCompleted: Boolean = false, val isLoading: Boolean = false, val userMessage: String? = null, val isTaskSaved: Boolean = false ) class AddEditTaskViewModel(...) : ViewModel() { private val _uiState = MutableStateFlow(AddEditTaskUiState()) val uiState: StateFlow&lt;AddEditTaskUiState&gt; = _uiState.asStateFlow() private fun createNewTask() { viewModelScope.launch { val newTask = Task(uiState.value.title, uiState.value.description) try { tasksRepository.saveTask(newTask) // Write data into the UI state. _uiState.update { it.copy(isTaskSaved = true) } } catch(cancellationException: CancellationException) { throw cancellationException } catch(exception: Exception) { _uiState.update { it.copy(userMessage = getErrorMessage(exception)) } } } } } //Compose State @Stable interface AddEditTaskUiState { val title: String val description: String val isTaskCompleted: Boolean val isLoading: Boolean val userMessage: String? val isTaskSaved: Boolean } private class MutableAddEditTaskUiState : AddEditTaskUiState() { override var title: String by mutableStateOf(\"\") override var description: String by mutableStateOf(\"\") override var isTaskCompleted: Boolean by mutableStateOf(false) override var isLoading: Boolean by mutableStateOf(false) override var userMessage: String? by mutableStateOf&lt;String?&gt;(null) override var isTaskSaved: Boolean by mutableStateOf(false) } class AddEditTaskViewModel(...) : ViewModel() { private val _uiState = MutableAddEditTaskUiState() val uiState: AddEditTaskUiState = _uiState private fun createNewTask() { viewModelScope.launch { val newTask = Task(uiState.value.title, uiState.value.description) try { tasksRepository.saveTask(newTask) // Write data into the UI state. _uiState.isTaskSaved = true } catch(cancellationException: CancellationException) { throw cancellationException } catch(exception: Exception) { _uiState.userMessage = getErrorMessage(exception)) } } } } . Not: Bir [AAC ViewModel](/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/about-viewmodel.md)'in viewModelScope'unda başlatılan coroutineler, istisnai olarak veya başka türlü tamamlanmaya çalışır. Bu, Coroutines açıkça iptal edilmedikçe veya ViewModel temizlenmedikçe, UI görünür olsun ya da olmasın gerçekleşir. Kısa ömürlü olma eğiliminde olduklarından, çoğu istek için bu genellikle uygundur. 5 saniye veya daha uzun süren istekleri çalıştırmak için viewModelScope kullanmamalısınız. Bunun yerine bunları WorkManager ile ertelenmiş veya uzun süreli işler olarak kuyruğa almalısınız. Mutating the UI state from background threads . UI state’inin productionu için main dispacther Coroutines’in başlatılması tercih edilir. Yani, aşağıdaki kod parçacıklarındaki withContext bloğunun dışında. Ancak, UI state’ini farklı bir backgroud context’inde güncellemeniz gerekirse, bunu aşağıdaki API’leri kullanarak yapabilirsiniz: . | Use the withContext method to run Coroutines in a different concurrent context. | When using MutableStateFlow, use the update method as usual. | When using Compose State, use the Snapshot.withMutableSnapshot to guarantee atomic updates to State in the concurrent context. | . Örneğin, aşağıdaki DiceRollViewModel parçacığında, SlowRandom.nextInt()’in CPU’ya bağlı bir Coroutine’den çağrılması gereken hesaplama açısından yoğun bir askıya alma işlevi olduğunu varsayalım. // StateFlow class DiceRollViewModel( private val defaultDispatcher: CoroutineScope = Dispatchers.Default ) : ViewModel() { private val _uiState = MutableStateFlow(DiceUiState()) val uiState: StateFlow&lt;DiceUiState&gt; = _uiState.asStateFlow() // Called from the UI fun rollDice() { viewModelScope.launch() { // Other Coroutines that may be called from the current context … withContext(defaultDispatcher) { _uiState.update { currentState -&gt; currentState.copy( firstDieValue = SlowRandom.nextInt(from = 1, until = 7), secondDieValue = SlowRandom.nextInt(from = 1, until = 7), numberOfRolls = currentState.numberOfRolls + 1, ) } } } } } // Compose State class DiceRollViewModel( private val defaultDispatcher: CoroutineScope = Dispatchers.Default ) : ViewModel() { private val _uiState = MutableDiceUiState() val uiState: DiceUiState = _uiState // Called from the UI fun rollDice() { viewModelScope.launch() { // Other Coroutines that may be called from the current context … withContext(defaultDispatcher) { Snapshot.withMutableSnapshot { _uiState.firstDieValue = SlowRandom.nextInt(from = 1, until = 7) _uiState.secondDieValue = SlowRandom.nextInt(from = 1, until = 7) _uiState.numberOfRolls = _uiState.numberOfRolls + 1 } } } } } . Not: Başlatılan tüm coroutinelerin farklı bir contexden çağrılması gerekiyorsa, doğrudan viewModelScope.launch(defaultDispatcher){ } öğesini arayabilirsiniz. Uyarı: Snapshot.withMutableSnapshot{ } kullanılmadan UI olmayan bir threadden Compose state’inin güncellenmesi, üretilen state’de tutarsızlıklara neden olabilir. Stream APIs as sources of state change . Streamlerde zaman içinde birden çok değer üreten state değişikliği kaynakları için, tüm kaynakların outputlarini uyumlu bir bütün halinde birleştirmek, state üretimine(production) doğrudan bir yaklaşımdır.Kotlin Flows kullanırken bunu combine fonksiyonu ile başarabilirsiniz. Bunun bir örneği, InterestsViewModel’deki “Now in Android” örneğinde görülebilir: . class InterestsViewModel( authorsRepository: AuthorsRepository, topicsRepository: TopicsRepository ) : ViewModel() { val uiState = combine( authorsRepository.getAuthorsStream(), topicsRepository.getTopicsStream(), ) { availableAuthors, availableTopics -&gt; InterestsUiState.Interests( authors = availableAuthors, topics = availableTopics ) } .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = InterestsUiState.Loading ) } . Not: Combined Flow’u, UI state için gözlemlenebilir API olarak bir [StateFlow](https://developer.android.com/kotlin/flow/stateflow-and-sharedflow)'a dönüştürmek için [stateIn](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html) operatörünü kullanabilirsiniz. StateFlows oluşturmak için stateIn operatörünün kullanılması, yalnızca UI görünürken aktif olması gerekebileceğinden, UI’ye state production pipeline’in activitysi üzerinde daha ayrıntılı kontrol sağlar. | Flow’un yaşam döngüsüne duyarlı bir şekilde collect edilmesi sırasında pipeline’in yalnızca UI görünür olduğunda etkin olması gerekiyorsa SharingStarted.WhileSubscription() öğesini kullanın. | Kullanıcı UI’e dönebildiği sürece, yani UI backstackde veya ekran dışında başka bir sekmede olduğu sürece pipeline’in aktif olması gerekiyorsa SharingStarted.Lazily kullanın. | . Stream tabanlı state kaynaklarının collectinin geçerli olmadığı durumlarda, Kotlin Flows gibi stream API’leri, streamlerin UI state’ine işlenmesine yardımcı olmak için [merging](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/merge.html?query=fun%20%3CT%3E%20merge(vararg%20flows:%20Flow%3CT%3E), [flattening](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html?query=inline%20fun%20%3CT,%20R%3E%20Flow%3CT%3E.flatMapLatest(crossinline%20transform:%20suspend%20(T) vb. gibi zengin bir transformation seti sunar. Anahtar Nokta: Çoğu durumda combine, stream API'lerinden state productiona yönelik tavsiye edilen bir yaklaşımdır. One-shot and stream APIs as sources of state change . State production pipeline’in, state değişikliği kaynakları olarak hem tek seferlik(one-shot) çağrılara hem de streamlere bağlı olduğu durumda, tanımlayıcı kısıtlama akışlardır(streams are defining constraint). Bu nedenle, tek seferlik çağrıları stream API’lerine dönüştürün veya outputlarini streamlere aktarın ve yukarıdaki stream bölümünde açıklandığı gibi işlemeye devam edin. Flowlarla, bu genellikle state değişikliklerini yaymak için bir veya daha fazla private backing MutableStateFlow instancei oluşturmak anlamına gelir. Compose state’inden snapshot flowlari da oluşturabilirsiniz. Aşağıdaki mimari örnekler repositorysinden TaskDetailViewModel’i göz önünde bulundurun: . //StateFlow class TaskDetailViewModel @Inject constructor( private val tasksRepository: TasksRepository, savedStateHandle: SavedStateHandle ) : ViewModel() { private val _isTaskDeleted = MutableStateFlow(false) private val _task = tasksRepository.getTaskStream(taskId) val uiState: StateFlow&lt;TaskDetailUiState&gt; = combine( _isTaskDeleted, _task ) { isTaskDeleted, task -&gt; TaskDetailUiState( task = taskAsync.data, isTaskDeleted = isTaskDeleted ) } // Convert the result to the appropriate observable API for the UI .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = TaskDetailUiState() ) fun deleteTask() = viewModelScope.launch { tasksRepository.deleteTask(taskId) _isTaskDeleted.update { true } } } //Compose State class TaskDetailViewModel @Inject constructor( private val tasksRepository: TasksRepository, savedStateHandle: SavedStateHandle ) : ViewModel() { private var _isTaskDeleted by mutableStateOf(false) private val _task = tasksRepository.getTaskStream(taskId) val uiState: StateFlow&lt;TaskDetailUiState&gt; = combine( snapshotFlow { _isTaskDeleted }, _task ) { isTaskDeleted, task -&gt; TaskDetailUiState( task = taskAsync.data, isTaskDeleted = isTaskDeleted ) } // Convert the result to the appropriate observable API for the UI .stateIn( scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = TaskDetailUiState() ) fun deleteTask() = viewModelScope.launch { tasksRepository.deleteTask(taskId) _isTaskDeleted = true } } . Not: Compose State, [snapshotFlow { }](https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#snapshotFlow(kotlin.Function0)) API kullanılarak bir flowa dönüştürülür. Başka bir örnek için \"Now In Android\" örneğindeki [ForYouViewModel](https://github.com/android/nowinandroid/blob/main/feature-foryou/src/main/java/com/google/samples/apps/nowinandroid/feature/foryou/ForYouViewModel.kt)'e bakın. Output types in state production pipelines . UI State için output API’sinin seçimi ve sunumunun doğası, büyük ölçüde uygulamanızın UI’ini oluşturmak için kullandığı API’ye bağlıdır. Android uygulamalarında Views veya Jetpack Compose kullanmayı seçebilirsiniz. Buradaki hususlar şunları içerir: . | State’i yaşam döngüsüne duyarlı bir şekilde okuma. | State’in, state holderinden bir veya daha fazla field’inden gösterilmesi gerekip gerekmediği. | . Aşağıdaki tablo, herhangi bir input ve consumer için state production pipeline için hangi API’lerin kullanılacağını özetlemektedir: . | Input | Consumer | Output | . | One-shot APIs | Views | StateFlow or LiveData | . | One-shot APIs | Compose | StateFlow or Compose State | . | Stream APIs | Views | StateFlow or LiveData | . | Stream APIs | Compose | StateFlow | . | One-shot and stream APIs | Views | StateFlow or LiveData | . | One-shot and stream APIs | Compose | StateFlow | . State production pipeline initialization . State production pipeline’larının başlatılması, pipeline’ın çalışması için ilk koşulların ayarlanmasını içerir. Bu, örneğin bir haber makalesinin detail view’i için bir ID gibi pipeline’ın başlatılması için kritik olan ilk girdi değerlerinin sağlanmasını veya asenkron bir yüklemenin başlatılmasını içerebilir. Sistem kaynaklarını korumak için state production pipeline’ı mümkün olduğunca lazily başlatmalısınız. Pratikte bu genellikle çıktının bir tüketicisi olana kadar beklemek anlamına gelir. Flow API’leri, stateIn metodundaki started argümanı ile buna izin verir. Bunun uygulanamaz olduğu durumlarda, aşağıdaki kod parçasında gösterildiği gibi state production pipeline’ı explicit olarak başlatmak için idempotent bir initialize() fonksiyonu tanımlayın: . class MyViewModel : ViewModel() { private var initializeCalled = false // This function is idempotent provided it is only called from the UI thread. @MainThread fun initialize() { if(initializeCalled) return initializeCalled = true viewModelScope.launch { // seed the state production pipeline } } } . Uyarı: Bir ViewModel'in init bloğunda veya constructor'ında asenkron işlemler başlatmaktan kaçının. Asenkron işlemler bir nesne oluşturmanın yan etkisi olmamalıdır çünkü asenkron kod, nesne tam olarak başlatılmadan önce nesneden okuyabilir veya nesneye yazabilir. Bu aynı zamanda leaking the object (nesnenin sızdırılması) olarak da adlandırılır ve ince ve teşhis edilmesi zor hatalara yol açabilir. Bu özellikle Compose State ile çalışırken önemlidir. ViewModel Compose State fieldlarini tuttuğunda, ViewModel'in init bloğunda Compose State fieldlarını güncelleyen bir Coroutine başlatmayın, aksi takdirde bir IllegalStateException oluşabilir. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production.html#ui-state-production",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/state-production.html#ui-state-production"
  },"171": {
    "doc": "String",
    "title": "String",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/string.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/string.html"
  },"172": {
    "doc": "Style",
    "title": "Style",
    "content": " ",
    "url": "/docs/app-basics/app-resources/resource-types/style.html",
    
    "relUrl": "/docs/app-basics/app-resources/resource-types/style.html"
  },"173": {
    "doc": "Support multiple back stacks",
    "title": "Support multiple back stacks",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/support-multiple-back-stacks.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/support-multiple-back-stacks.html"
  },"174": {
    "doc": "supports-gl-texture",
    "title": "supports-gl-texture",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/supports-gl-texture.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/supports-gl-texture.html"
  },"175": {
    "doc": "supports-screens",
    "title": "supports-screens",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/supports-screens.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/supports-screens.html"
  },"176": {
    "doc": "Tasks and the back stack",
    "title": "Tasks and the back stack",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/tasks-and-the-back-stack.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/tasks-and-the-back-stack.html"
  },"177": {
    "doc": "Test navigation",
    "title": "Test navigation",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/test-navigation.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/test-navigation.html"
  },"178": {
    "doc": "Test your app with pseudolocales",
    "title": "Test your app with pseudolocales",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/test-your-app-with-pseudolocales.html",
    
    "relUrl": "/docs/app-basics/app-resources/localization/test-your-app-with-pseudolocales.html"
  },"179": {
    "doc": "Test your app's activities",
    "title": "Test your app's activities",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/test-your-apps-activities.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/test-your-apps-activities.html"
  },"180": {
    "doc": "Test your fragments",
    "title": "Test your fragments",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/test-your-fragments.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/test-your-fragments.html"
  },"181": {
    "doc": "Test your paging implementation",
    "title": "Test your paging implementation",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/test-your-paging-implementation.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/test-your-paging-implementation.html"
  },"182": {
    "doc": "The activity lifecycle",
    "title": "The activity lifecycle",
    "content": " ",
    "url": "/docs/app-architecture/app-entry-points/activities/the-activity-lifecycle.html",
    
    "relUrl": "/docs/app-architecture/app-entry-points/activities/the-activity-lifecycle.html"
  },"183": {
    "doc": "Transform data streams",
    "title": "Transform data streams",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/transform-data-streams.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/paging-library/transform-data-streams.html"
  },"184": {
    "doc": "Two-way data binding",
    "title": "Two-way data binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/two-way-data-binding.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/two-way-data-binding.html"
  },"185": {
    "doc": "Type-safe navigation with Compose",
    "title": "Type-safe navigation with Compose",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/type-safe-navigation-with-compose.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/type-safe-navigation-with-compose.html"
  },"186": {
    "doc": "Ui events",
    "title": "UI events",
    "content": "UI eventleri, UI layerda UI veya ViewModel tarafından işlenmesi gereken actionlardir. En yaygın event türü, kullanıcı eventleridir. Kullanıcı, uygulamayla etkileşim kurarak, örneğin ekrana dokunarak veya hareketler(gesture) oluşturarak kullanıcı eventleri oluşturur. UI daha sonra onClick() listenerlar gibi callbackleri kullanarak bu olayları tüketir( consume eder). Anahtar terimler: . | Kullanıcı Arabirimi(UI): Kullanıcı arabirimini yöneten View tabanlı kod veya Compose kodu. | UI eventleri(Kullanici arabirimi olaylari): UI layerda handle edilmesi gereken gereken actionlar. | Kullanıcı eventlari(User events): Kullanıcının uygulama ile etkileşim kurarken oluşturduğu eventler. | . ViewModel normalde belirli bir kullanıcı eventinin business logicini handle etmekten sorumludur; örneğin, kullanıcının bazı verileri yenilemek için bir butona tıklaması. Genellikle ViewModel, UI’in çağırabileceği methodlari göstererek bunu halleder. Kullanıcı eventlari, UI’in doğrudan handle edebilecegi UI behavior logicine de sahip olabilir; örneğin, farklı bir ekrana gitme veya bir Snackbar gösterme. Farklı mobil platformlarda veya form factorlerinde aynı uygulama için business logic aynı kalırken, UI behaviour logic’i bu durumlar arasında farklılık gösterebilen bir implementasyon detayıdır. UI layer sayfası, bu logic türlerini aşağıdaki gibi tanımlar: . | İş mantığı(business logic), state değişiklikleriyle ne yapılacağını ifade eder; örneğin, ödeme yapmak veya kullanıcı tercihlerini saklamak. Domain ve data layerlar genellikle bu logic’i handle eder. Bu kılavuz boyunca, Architecture Components ViewModel sınıfı, business logic’i handle eden sınıflar için düşünülmüş bir çözüm olarak kullanılır. | UI davranış mantığı veya UI mantığı(UI behavior logic veya UI logic), state değişikliklerinin nasıl görüntüleneceğini ifade eder; örneğin, navigation logic’i veya kullanıcıya mesajların nasıl gösterileceği. UI bu logic’i handle eder. | . Not: Bu sayfada sunulan öneriler ve best practiceler, geniş bir uygulama yelpazesine uygulanarak ölçeklenebilir, kaliteyi ve sağlamlığı artırabilir ve test edilmesini kolaylaştırabilir. Ancak, bunları kılavuz olarak ele almalı ve gereksinimlerinize göre uyarlamalısınız. Architecture: Handling UI events-MAD Skills . UI event decision tree . Aşağıdaki diyagram, belirli bir event kullanım senaryosunu(use case) ele almak için en iyi yaklaşımı bulmaya yönelik bir karar ağacını(decision tree) göstermektedir. Bu kılavuzun geri kalanında bu yaklaşımlar ayrıntılı olarak açıklanmaktadır. Handle user events . Bu eventler, bir UI elementinin state’inin (örneğin, expandable bir itemin state’i) değiştirilmesiyle ilgiliyse, UI, kullanıcı eventlerini doğrudan handle edebilir. Event, ekrandaki verilerin yenilenmesi gibi business logicin yürütülmesini gerektiriyorsa ViewModel tarafından işlenmelidir. Aşağıdaki örnek, UI elementini genişletmek (UI logic) ve ekrandaki verileri yenilemek (business logic) için farklı butonlarin nasıl kullanıldığını gösterir: . // Views class LatestNewsActivity : AppCompatActivity() { private lateinit var binding: ActivityLatestNewsBinding private val viewModel: LatestNewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ // The expand details event is processed by the UI that // modifies a View's internal state. binding.expandButton.setOnClickListener { binding.expandedSection.visibility = View.VISIBLE } // The refresh event is processed by the ViewModel that is in charge // of the business logic. binding.refreshButton.setOnClickListener { viewModel.refreshNews() } } } //compose @Composable fun LatestNewsScreen(viewModel: LatestNewsViewModel = viewModel()) { // State of whether more details should be shown var expanded by remember { mutableStateOf(false) } Column { Text(\"Some text\") if (expanded) { Text(\"More details\") } Button( // The expand details event is processed by the UI that // modifies this composable's internal state. onClick = { expanded = !expanded } ) { val expandText = if (expanded) \"Collapse\" else \"Expand\" Text(\"$expandText details\") } // The refresh event is processed by the ViewModel that is in charge // of the UI's business logic. Button(onClick = { viewModel.refreshNews() }) { Text(\"Refresh data\") } } } . User Events in RecyclerViews . Action, bir RecyclerView iteminde veya custom bir Viewde olduğu gibi, UI ağacının daha aşağısında üretilirse, ViewModel yine de kullanıcı eventlerini handle eden olmalıdır. Örneğin, NewsActivity’den gelen tüm haber itemlerinin bir bookmark butonu içerdiğini varsayalım. ViewModel’in bookmark eklenmiş haber iteminin IDsini bilmesi gerekir. Kullanıcı bir haber öğesine bookmark koyduğunda, RecyclerView adapteri, ViewModel’e bağımlılık gerektirecek şekilde ViewModel’den açığa çıkan addBookmark(newsId) methodunu çağırmaz. Bunun yerine ViewModel, eventi handle etmek için implementasyonu içeren NewsItemUiState adlı bir state nesnesini gösterir: . data class NewsItemUiState( val title: String, val body: String, val bookmarked: Boolean = false, val publicationDate: String, val onBookmark: () -&gt; Unit ) class LatestNewsViewModel( private val formatDateUseCase: FormatDateUseCase, private val repository: NewsRepository ) { val newsListUiItems = repository.latestNews.map { news -&gt; NewsItemUiState( title = news.title, body = news.body, bookmarked = news.bookmarked, publicationDate = formatDateUseCase(news.publicationDate), // Business logic is passed as a lambda function that the // UI calls on click events. onBookmark = { repository.addBookmark(news.id) } ) } } . Bu şekilde, RecyclerView adapteri yalnızca ihtiyaç duyduğu verilerle çalışır: NewsItemUiState nesnelerinin listesi. Adapterin ViewModel’in tamamına erişimi yoktur, bu da ViewModel tarafından açığa çıkarılan fonksiyonaliteyi kötüye kullanma olasılığını azaltır. Yalnızca activity sınıfının ViewModel ile çalışmasına izin verdiğinizde, sorumlulukları ayırmış olursunuz. Bu, viewler veya RecyclerView adapterlari gibi UI’e özgü nesnelerin ViewModel ile doğrudan etkileşime girmemesini sağlar. Uyarı: ViewModel'i RecyclerView adapterina passlamak kötü bir uygulamadır çünkü adapteri ViewModel sınıfıyla sıkı bir şekilde birleştirir. Not: Diğer bir yaygın pattern, RecyclerView adapterinin kullanıcı eylemleri( actionlari) için bir callback interfaceine sahip olmasıdır. Bu durumda, activty veya fragment bindingi handle edebilir ve doğrudan callback interfaceinden ViewModel methodlarini çağırabilir. Naming conventions for user event functions . Bu kılavuzda, kullanıcı eventlerini handle eden ViewModel fonksiyonlari, gerçekleştirdikleri eyleme göre bir fiille adlandırılır; örneğin: addBookmark(id) veya logIn(username, password). Handle ViewModel Events . ViewModel’den kaynaklanan UI actionlari(ViewModel eventleri), her zaman bir UI state güncellemesiyle sonuçlanmalıdır. Bu, Tek Yönlü Veri Akışı(UDF) ilkelerine uygundur. Configuration changesden sonra eventleri yeniden üretilebilir hale getirir ve UI actionlarinin kaybolmayacağını garanti eder. İsteğe bağlı olarak, saved state modülünü kullanırsanız, eventleri process ölümünden sonra tekrarlanabilir hale getirebilirsiniz. UI actionlarini UI state’ine maplemek her zaman basit bir işlem değildir, ancak daha basit bir logice yol açar. Örneğin, düşünce süreciniz, UI’in belirli bir ekrana nasıl yönlendirileceğini belirlemekle bitmemelidir. Daha fazla düşünmeniz ve bu kullanıcı akışını UI state’inizde nasıl temsil edeceğinizi düşünmeniz gerekir. Başka bir deyişle: UI’in yapması gereken işlemleri düşünmeyin; bu actionlarinin UI state’ini nasıl etkilediğini düşünün. Anahtar Nokta: ViewModel eventleri her zaman bir UI state güncellemesiyle sonuçlanmalıdır. Örneğin, kullanıcı oturum açma ekranında oturum açtığında ana ekrana gitme durumunu düşünün. Bunu UI state’inde aşağıdaki gibi modelleyebilirsiniz: . data class LoginUiState( val isLoading: Boolean = false, val errorMessage: String? = null, val isUserLoggedIn: Boolean = false ) . Bu UI, isUserLoggedIn state’indeki değişikliklere tepki verir ve gerektiğinde doğru hedefe gider: . //views class LoginViewModel : ViewModel() { private val _uiState = MutableStateFlow(LoginUiState()) val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow() /* ... */ } class LoginActivity : AppCompatActivity() { private val viewModel: LoginViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { uiState -&gt; if (uiState.isUserLoggedIn) { // Navigate to the Home screen. } ... } } } } } //compose class LoginViewModel : ViewModel() { var uiState by mutableStateOf(LoginUiState()) private set /* ... */ } @Composable fun LoginScreen( viewModel: LoginViewModel = viewModel(), onUserLogIn: () -&gt; Unit ) { val currentOnUserLogIn by rememberUpdatedState(onUserLogIn) // Whenever the uiState changes, check if the user is logged in. LaunchedEffect(viewModel.uiState) { if (viewModel.uiState.isUserLoggedIn) { currentOnUserLogIn() } } // Rest of the UI for the login screen. } . Not: Bu bölümdeki kod örnekleri [coroutinelerin ve bunların yaşam döngüsüne duyarlı bileşenlerle nasıl kullanılacağı](/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/use-kotlin-coroutines-with-lifecycle-aware-components) nın anlaşılmasını gerektirir. Consuming events can trigger state updates . UI’de belirli ViewModel eventlerinin kullanılması, diğer UI state güncellemelerine neden olabilir. Örneğin, kullanıcıya bir şey olduğunu bildirmek için ekranda geçici mesajlar gösterilirken, mesaj ekranda gösterildiğinde UI’in ViewModel’e başka bir state güncellemesini tetiklemesi için bildirimde bulunması gerekir. Kullanıcı mesajı tükettiğinde (bırakarak veya bir zaman aşımından sonra) meydana gelen event, “user input” olarak ele alınabilir ve bu nedenle, ViewModel bunun farkında olmalıdır. Bu durumda, UI state aşağıdaki gibi modellenebilir: . // Models the UI state for the Latest news screen. data class LatestNewsUiState( val news: List&lt;News&gt; = emptyList(), val isLoading: Boolean = false, val userMessage: String? = null ) . ViewModel, business logic kullanıcıya yeni bir geçici mesaj gösterilmesini gerektirdiğinde UI state’ini aşağıdaki gibi günceller: . //Views class LatestNewsViewModel(/* ... */) : ViewModel() { private val _uiState = MutableStateFlow(LatestNewsUiState(isLoading = true)) val uiState: StateFlow&lt;LatestNewsUiState&gt; = _uiState fun refreshNews() { viewModelScope.launch { // If there isn't internet connection, show a new message on the screen. if (!internetConnection()) { _uiState.update { currentUiState -&gt; currentUiState.copy(userMessage = \"No Internet connection\") } return@launch } // Do something else. } } fun userMessageShown() { _uiState.update { currentUiState -&gt; currentUiState.copy(userMessage = null) } } } //compose class LatestNewsViewModel(/* ... */) : ViewModel() { var uiState by mutableStateOf(LatestNewsUiState()) private set fun refreshNews() { viewModelScope.launch { // If there isn't internet connection, show a new message on the screen. if (!internetConnection()) { uiState = uiState.copy(userMessage = \"No Internet connection\") return@launch } // Do something else. } } fun userMessageShown() { uiState = uiState.copy(userMessage = null) } } . ViewModel’in, UI’in mesajı ekranda nasıl gösterdiğini bilmesi gerekmez; sadece gösterilmesi gereken bir kullanıcı mesajı olduğunu bilir. Geçici mesaj gösterildikten sonra, UI’in bunu ViewModel’e bildirmesi gerekir ve başka bir UI state güncellemesinin userMessage propertysini temizlemesine neden olur: . //views class LatestNewsActivity : AppCompatActivity() { private val viewModel: LatestNewsViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { uiState -&gt; uiState.userMessage?.let { // TODO: Show Snackbar with userMessage. // Once the message is displayed and // dismissed, notify the ViewModel. viewModel.userMessageShown() } ... } } } } } //compose @Composable fun LatestNewsScreen( snackbarHostState: SnackbarHostState, viewModel: LatestNewsViewModel = viewModel(), ) { // Rest of the UI content. // If there are user messages to show on the screen, // show it and notify the ViewModel. viewModel.uiState.userMessage?.let { userMessage -&gt; LaunchedEffect(userMessage) { snackbarHostState.showSnackbar(userMessage) // Once the message is displayed and dismissed, notify the ViewModel. viewModel.userMessageShown() } } } . Mesaj geçici olsa da, UI state, zamanın her noktasında ekranda görüntülenenlerin aslına sadık bir temsilidir. Kullanıcı mesajı görüntülenir veya görüntülenmez. Not: Ekranda gösterilecek kullanıcı mesajlarının listesini içeren daha gelişmiş bir kullanım örneği için [Jetsnack Compose](https://github.com/android/compose-samples/blob/main/Jetsnack/app/src/main/java/com/example/jetsnack/model/SnackbarManager.kt) örneğine bakın. Navigation Events . Consuming events can trigger state updates bölümü, kullanıcı mesajlarını ekranda görüntülemek için UI state’ini nasıl kullandığınızı ayrıntılarıyla açıklar. Navigasyon eventleri, bir Android uygulamasında da yaygın olarak görülen bir event türüdür. Event, kullanıcı bir butona dokunduğu için UI’de tetiklenirse, UI, navigation controller çağırarak veya eventi çağırana uygun şekilde composable olarak göstererek bununla ilgilenir. //views class LoginActivity : AppCompatActivity() { private lateinit var binding: ActivityLoginBinding private val viewModel: LoginViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ binding.helpButton.setOnClickListener { navController.navigate(...) // Open help screen } } } //compose @Composable fun LoginScreen( onHelp: () -&gt; Unit, // Caller navigates to the right screen viewModel: LoginViewModel = viewModel() ) { // Rest of the UI Button(onClick = onHelp) { Text(\"Get help\") } } . Data input, navigateden önce bazı business logic doğrulaması gerektiriyorsa, ViewModel’in bu durumu UI’a göstermesi gerekir. Kullanıcı arayüzü bu state değişikliğine tepki verir ve buna göre navigate eder. Handle ViewModel events section bölümü bu kullanım durumunu kapsar. İşte benzer bir kod: . //views class LoginActivity : AppCompatActivity() { private val viewModel: LoginViewModel by viewModels() override fun onCreate(savedInstanceState: Bundle?) { /* ... */ lifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { uiState -&gt; if (uiState.isUserLoggedIn) { // Navigate to the Home screen. } ... } } } } } //compose @Composable fun LoginScreen( onUserLogIn: () -&gt; Unit, // Caller navigates to the right screen viewModel: LoginViewModel = viewModel() ) { Button( onClick = { // ViewModel validation is triggered viewModel.login() } ) { Text(\"Log in\") } // Rest of the UI val lifecycle = LocalLifecycleOwner.current.lifecycle val currentOnUserLogIn by rememberUpdatedState(onUserLogIn) LaunchedEffect(viewModel, lifecycle) { // Whenever the uiState changes, check if the user is logged in and // call the `onUserLogin` event when `lifecycle` is at least STARTED snapshotFlow { viewModel.uiState } .filter { it.isUserLoggedIn } .flowWithLifecycle(lifecycle) .collect { currentOnUserLogIn() } } } . Yukarıdaki örnekte, current destination olan Login backstackde tutulmayacağından uygulama beklendiği gibi çalışır. Kullanıcılar geri basarlarsa geri dönemezler. Ancak bunun olabileceği durumlarda, çözüm ek logic gerektirecektir. Navigation events when the destination is kept in the back stack . Bir ViewModel, A ekranından B ekranına bir navigation event üreten bir state belirlediğinde ve A ekranı navigation backstack’nde tutulduğunda, otomatik olarak B’ye ilerlemeye devam etmemek için ek logice ihtiyacınız olabilir. Bunu implement etmek için, UI’in diğer ekrana gitmeyi düşünüp düşünmemesi gerektiğini gösteren ek bir state’e sahip olunması gerekir.Normalde, bu state UI’de tutulur çünkü Navigation logic, ViewModel ile değil, UI ile ilgilidir. Bunu göstermek için, aşağıdaki kullanım örneğini ele alalım. Diyelim ki uygulamanızın kayıt akışındasınız. Doğum tarihi doğrulama ekranında, kullanıcı bir tarih girdiğinde, kullanıcı “Continue” butonuna dokunduğunda tarih ViewModel tarafından doğrulanır. ViewModel, doğrulama logic’ini data katmanına devreder. Tarih geçerliyse, kullanıcı bir sonraki ekrana geçer. Ek bir özellik olarak, kullanıcılar bazı verileri değiştirmek istediklerinde farklı kayıt ekranları arasında gidip gelebilirler. Bu nedenle, kayıt akışındaki tüm destinationlar aynı backstackde tutulur. Bu gereksinimler göz önüne alındığında, bu ekranı aşağıdaki gibi uygulayabilirsiniz: . //views // Key that identifies the `validationInProgress` state in the Bundle private const val DOB_VALIDATION_KEY = \"dobValidationKey\" class DobValidationFragment : Fragment() { private var validationInProgress: Boolean = false private val viewModel: DobValidationViewModel by viewModels() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) val binding = // ... validationInProgress = savedInstanceState?.getBoolean(DOB_VALIDATION_KEY) ?: false binding.continueButton.setOnClickListener { viewModel.validateDob() validationInProgress = true } viewLifecycleOwner.lifecycleScope.launch { launch { viewModel.uiState .flowWithLifecycle(viewLifecycleOwner.lifecycle) .collect { uiState -&gt; // Update other parts of the UI ... // If the input is valid and the user wants // to navigate, navigate to the next screen // and reset `validationInProgress` flag if (uiState.isDobValid &amp;&amp; validationInProgress) { validationInProgress = false navController.navigate(...) // Navigate to next screen } } } } return binding } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) outState.putBoolean(DOB_VALIDATION_KEY, validationInProgress) } } //compose class DobValidationViewModel(/* ... */) : ViewModel() { var uiState by mutableStateOf(DobValidationUiState()) private set } @Composable fun DobValidationScreen( onNavigateToNextScreen: () -&gt; Unit, // Caller navigates to the right screen viewModel: DobValidationViewModel = viewModel() ) { // TextField that updates the ViewModel when a date of birth is selected var validationInProgress by rememberSaveable { mutableStateOf(false) } Button( onClick = { viewModel.validateInput() validationInProgress = true } ) { Text(\"Continue\") } // Rest of the UI /* * The following code implements the requirement of advancing automatically * to the next screen when a valid date of birth has been introduced * and the user wanted to continue with the registration process. */ if (validationInProgress) { val lifecycle = LocalLifecycleOwner.current.lifecycle val currentNavigateToNextScreen by rememberUpdatedState(onNavigateToNextScreen) LaunchedEffect(viewModel, lifecycle) { // If the date of birth is valid and the validation is in progress, // navigate to the next screen when `lifecycle` is at least STARTED, // which is the default Lifecycle.State for the `flowWithLifecycle` operator. snapshotFlow { viewModel.uiState } .filter { it.isDobValid } .flowWithLifecycle(lifecycle) .collect { validationInProgress = false currentNavigateToNextScreen() } } } } . Doğum tarihi doğrulama, ViewModel’in sorumlu olduğu business logictir. ViewModel çoğu zaman bu logic’i data katmanına devreder. Kullanıcıyı bir sonraki ekrana yönlendirme mantığı, UI logictir çünkü bu gereksinimler, UI yapılandırmasına bağlı olarak değişebilir. Örneğin, aynı anda birden çok kayıt adımı gösteriyorsanız, bir tablette otomatik olarak başka bir ekrana ilerlemek istemeyebilirsiniz. Yukarıdaki koddaki validationInProgress değişkeni bu işlevi uygular ve UI’in doğum tarihi geçerli olduğunda ve kullanıcı aşağıdaki kayıt adımına devam etmek istediğinde otomatik olarak navigate edilip edilmeyeceğini belirler. Other Use Cases . UI event usecaseinizin UI state güncellemeleriyle çözülemeyeceğini düşünüyorsanız, uygulamanızda veri akışını yeniden gözden geçirmeniz gerekebilir. Aşağıdaki ilkeleri göz önünde bulundurun: . | Her sınıf sorumlu olduğu şeyi yapmalı, daha fazlasını değil. Kullanıcı arabirimi, navigation calls, click events ve izin istekleri alma gibi ekrana özgü davranış mantığından sorumludur. ViewModel, iş mantığını içerir ve sonuçları hiyerarşinin alt katmanlarından UI state’ine dönüştürür. | Eventin nereden kaynaklandığını düşünün. Bu kılavuzun başında sunulan decision tree’yi takip edin ve her sınıfın sorumlu olduğu konuyu halletmesini sağlayın. Örneğin, event kullanıcı arayüzünden geliyorsa ve bir navigate ile olayıyla sonuçlanıyorsa, o eventin kullanıcı arayüzünde handle edilmesi gerekir. Bazı logicler ViewModel’e devredilebilir, ancak eventin handle edilmesi tamamen ViewModel’e devredilemez. | Birden çok consumer varsa ve activitynin birden çok kez consume edilmesinden endişe ediyorsanız uygulama mimarinizi yeniden gözden geçirmeniz gerekebilir. Birden fazla concurrent consumure sahip olmak, tam olarak bir kez teslim edilen sözleşmenin garanti edilmesinin son derece zor hale gelmesine neden olur, bu nedenle karmaşıklık ve subtle behavior miktarı patlar. Bu sorunu yaşıyorsanız, bu endişeleri kullanıcı arabirimi ağacınızda yukarıya taşımayı düşünün; hiyerarşide daha üstte yer alan farklı bir entitye ihtiyacınız olabilir. | State’in ne zaman tüketilmesi gerektiğini bir düşünün. Belirli durumlarda, uygulama arka plandayken (örneğin, bir Toast gösterirken) state’i tüketmeye devam etmek istemeyebilirsiniz. Bu gibi durumlarda, kullanıcı arabirimi ön planda olduğunda state’i kullanmayı düşünün. | . Not: Bazı uygulamalarda, ViewModel eventlerinin [Kotlin Channels](https://kotlinlang.org/docs/channels.html) veya diğer reactive streams kullanılarak kullanıcı arayüzüne maruz kaldığını görmüş olabilirsiniz. Producer (ViewModel) consumeri (UI—Compose veya Views) geride bıraktığında, bu çözümler bu eventlerin teslimini ve işlenmesini garanti etmez. Bu, geliştirici için gelecekte sorunlara neden olabilir ve aynı zamanda çoğu uygulama için kabul edilemez bir kullanıcı deneyimidir çünkü bu, uygulamayı tutarsız bir durumda bırakabilir, hatalara neden olabilir veya kullanıcı kritik bilgileri kaçırabilir. Bu durumlardan birindeyseniz, o tek seferlik ViewModel eventinin kullanıcı arayüzünüz için gerçekte ne anlama geldiğini tekrar düşünün. Bunları hemen handle edin ve UI state’ine indirin. UI state’i, UI'yi belirli bir zamanda daha iyi temsil eder, size daha fazla teslimat ve işleme garantisi verir, test edilmesi genellikle daha kolaydır ve uygulamanızın geri kalanıyla tutarlı bir şekilde entegre olur. Bazı kod örnekleriyle yukarıda bahsedilen API'leri neden kullanmamanız gerektiği hakkında daha fazla bilgi edinmek için [ViewModel: One-off event antipatterns](https://medium.com/androiddevelopers/viewmodel-one-off-event-antipatterns-16a1da869b95) blog gönderisini okuyun. Samples . ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events.html#ui-events",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events.html#ui-events"
  },"187": {
    "doc": "Ui events",
    "title": "Ui events",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-events.html"
  },"188": {
    "doc": "UI layer libraries",
    "title": "UI layer libraries",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/ui-layer-libraries.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/ui-layer-libraries.html"
  },"189": {
    "doc": "Ui layer",
    "title": "Ui layer",
    "content": " ",
    "url": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-layer.html",
    
    "relUrl": "/docs/app-architecture/guide-to-app-architecture/ui-layer/ui-layer.html"
  },"190": {
    "doc": "Unicode and internationalization support",
    "title": "Unicode and internationalization support",
    "content": " ",
    "url": "/docs/app-basics/app-resources/localization/unicode-and-internationalization-support.html",
    
    "relUrl": "/docs/app-basics/app-resources/localization/unicode-and-internationalization-support.html"
  },"191": {
    "doc": "Update UI components with NavigationUI",
    "title": "Update UI components with NavigationUI",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/navigation-component/update-ui-components-with-navigationui.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/navigation-component/update-ui-components-with-navigationui.html"
  },"192": {
    "doc": "Use Hilt with other Jetpack libraries",
    "title": "Use Hilt with other Jetpack libraries",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/use-hilt-with-other-jetpack-libraries.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/use-hilt-with-other-jetpack-libraries.html"
  },"193": {
    "doc": "Use Kotlin coroutines with Lifecycle-aware components",
    "title": "Use Kotlin coroutines with Lifecycle-aware components",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/use-kotlin-coroutines-with-lifecycle-aware-components.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/use-kotlin-coroutines-with-lifecycle-aware-components.html"
  },"194": {
    "doc": "uses-configuration",
    "title": "uses-configuration",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/uses-configuration.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/uses-configuration.html"
  },"195": {
    "doc": "manifest",
    "title": "manifest",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/uses-feature.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/uses-feature.html"
  },"196": {
    "doc": "uses-library",
    "title": "uses-library",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/uses-library.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/uses-library.html"
  },"197": {
    "doc": "uses-native-library",
    "title": "uses-native-library",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/uses-native-library.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/uses-native-library.html"
  },"198": {
    "doc": "uses-permission-sdk-23",
    "title": "uses-permission-sdk-23",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/uses-permission-sdk-23.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/uses-permission-sdk-23.html"
  },"199": {
    "doc": "uses-permission",
    "title": "uses-permission",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/uses-permission.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/uses-permission.html"
  },"200": {
    "doc": "uses-sdk",
    "title": "uses-sdk",
    "content": " ",
    "url": "/docs/app-basics/app-manifest-file/uses-sdk.html",
    
    "relUrl": "/docs/app-basics/app-manifest-file/uses-sdk.html"
  },"201": {
    "doc": "Using Dagger in Android apps",
    "title": "Using Dagger in Android apps",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-android-apps.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-android-apps.html"
  },"202": {
    "doc": "Using Dagger in multi-module apps",
    "title": "Using Dagger in multi-module apps",
    "content": " ",
    "url": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-multi-module-apps.html",
    
    "relUrl": "/docs/app-architecture/dependency-injection/dagger/using-dagger-in-multi-module-apps.html"
  },"203": {
    "doc": "Verify app links",
    "title": "Verify app links",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/app-links/verify-app-links.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/app-links/verify-app-links.html"
  },"204": {
    "doc": "View binding",
    "title": "View binding",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/view-binding.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/view-binding/view-binding.html"
  },"205": {
    "doc": "ViewModel APIs cheat sheet",
    "title": "ViewModel APIs cheat sheet",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-apis-cheat-sheet.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-apis-cheat-sheet.html"
  },"206": {
    "doc": "ViewModels scoping APIs",
    "title": "ViewModels scoping APIs",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-scoping-apis.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel-scoping-apis.html"
  },"207": {
    "doc": "ViewModel",
    "title": "ViewModel",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/ViewModel/viewmodel.html"
  },"208": {
    "doc": "Work with observable data objects",
    "title": "Work with observable data objects",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/work-with-obserable-data-objects.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/ui-layer-libraries/data-binding-library/work-with-obserable-data-objects.html"
  },"209": {
    "doc": "Working with the app",
    "title": "Working with the app",
    "content": " ",
    "url": "/docs/app-architecture/app-navigation/fragments/working-with-the-app.html",
    
    "relUrl": "/docs/app-architecture/app-navigation/fragments/working-with-the-app.html"
  },"210": {
    "doc": "WorkManager",
    "title": "WorkManager",
    "content": " ",
    "url": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/workmanager.html",
    
    "relUrl": "/docs/app-architecture/architecture-components/data-layer-libraries/workmanager/workmanager.html"
  }
}
