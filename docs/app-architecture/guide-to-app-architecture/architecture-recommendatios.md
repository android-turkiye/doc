---
layout: default
title: Architecture recommendations
grand_parent: App architecture
nav_order: 5
parent: Guide to app architecture
---

## Architecture recommendations

### Recommendations for Android Architecture
Bu sayfada çeşitli [Architecture](guide-to-app-architecture) best practiceleri ve önerileri sunulmaktadır. Uygulamanızın kalitesini, sağlamlığını ve ölçeklenebilirliğini artırmak için bunları benimseyin. Ayrıca uygulamanızın bakımını ve test edilmesini de kolaylaştırırlar.

<mark style = "background-color:lightblue">Not: Bu belgedeki önerileri katı gereklilikler olarak değil tavsiyeler olarak ele almalısınız. Gerektiğinde bunları uygulamanıza uyarlayın.</mark>

Aşağıdaki best practiceler konuya göre gruplandırılmıştır. Her birinin, ekibin ne kadar güçlü bir şekilde önerdiğini yansıtan bir önceliği vardır. Öncelikler listesi aşağıdaki gibidir:

* <span style="color:green"> Strongly recommended:</span> Yaklaşımınızla temelden çelişmediği sürece bu pratiği uygulamalısınız.
* <span style="color:deepskyblue"> Recommended: </span> Bu pratiğin uygulamanızı geliştirmesi muhtemeldir.
* <span style="color:orangered"> Optional: </span> Bu pratik, belirli durumlarda uygulamanızı geliştirebilir.

<mark style = "background-color:lightblue">Not: Bu önerileri anlamak için [Architecture kılavuzu](guide-to-app-architecture)na aşina olmanız gerekir.</mark>

### Layer Architecture
Önerdiğimiz [katmanlı mimari](about-app-architecture.md#recommended-app-architecture), seperation of concern'i destekler. UI'yi veri modellerinden yönlendirir, single source of truth ilkesine uyar ve [undirectional data flow](about-app-architecture.md#unidirectional-data-flow) ilkelerini takip eder. İşte katmanlı mimari için bazı best practiceler:

| Recommendation                                                                                                                                                                                                                  | Description                                                                                                                                                                                                                                                                                                                                               |
|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Açıkça tanımlanmış bir [data katmanı](/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer) kullanın.<br/><span style="color:green"> Strongly recommended:</span>                                   | Data katmanı, uygulama verilerini uygulamanın geri kalanına sunar ve uygulamanızın business logic'inin büyük çoğunluğunu içerir.</br> * Sadece tek bir veri kaynağı içerse bile veri repositorylerini oluşturmalısınız. </br>* Küçük uygulamalarda, data katmanı türlerini bir data paketine veya modülüne yerleştirmeyi seçebilirsiniz                   |
| Açıkça tanımlanmış bir [UI katmanı](/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer) kullanın. <br/><span style="color:green"> Strongly recommended:</span>                                        | UI katmanı, uygulama verilerini ekranda görüntüler ve kullanıcı etkileşiminin birincil noktası olarak hizmet eder.</br>* Küçük uygulamalarda, data katmanı tiplerini bir UI paketine veya modülüne yerleştirmeyi seçebilirsiniz.Daha fazla UI katmanı best practiceleri burada.                                                                           |
| [Data katmanı](/docs/app-architecture/guide-to-app-architecture/data-layer/about-the-data-layer), bir repository kullanarak uygulama verilerini açığa çıkarmalıdır.<br/><span style="color:green"> Strongly recommended:</span> | UI katmanındaki componentler, activity'ler veya ViewModel'lar gibi componentler doğrudan bir veri kaynağı ile etkileşime girmemelidir. Veri kaynaklarına örnekler şunlardır: </br>* Databases, DataStore, SharedPreferences, Firebase APIs.</br> * GPS location providers. </br> * Bluetooth data providers.</br> * Network connectivity status provider. |
| [Coroutines ve flowlari](https://developer.android.com/kotlin/coroutines) kullanin.<br/><span style="color:green"> Strongly recommended:</span>                                                                                 | Katmanlar arasında iletişim kurmak için coroutine'leri ve flow'ları kullanın.  More coroutines best practices here.                                                                                                                                                                                                                                       |
| [Domain layer](/docs/app-architecture/guide-to-app-architecture/domain-layer) kullanin.<br/><span style="color:deepskyblue"> Recommended in big apps </span>                                                                    | Birden fazla ViewModel'de data katmanıyla etkileşime giren business logic'i yeniden kullanmanız gerekiyorsa veya belirli bir ViewModel'in business logic karmaşıklığını basitleştirmek istiyorsanız bir domain katmanı, use caseleri kullanın.                                                                                                            |



### UI Layer
[UI katmanı](/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer)nın rolü, uygulama verilerini ekranda görüntülemek ve kullanıcı etkileşiminin birincil noktası olarak hizmet etmektir. İşte UI katmanı için bazı best practiceler:

| Recommendation                                                                                                                                                                                                                                         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [Unidirectional Data Flow ](https://developer.android.com/jetpack/compose/architecture#udf)(UDF’i takip edin..<br/><span style="color:green"> Strongly recommended:</span>                                                                             | ViewModel'lerin observer pattern kullanarak UI state'ini gösterdiği ve metot çağrıları yoluyla UI'dan action'lar aldığı Unidirectional Data Flow (UDF) prensiplerini takip edin.                                                                                                                                                                                                                                                                                                                                                                                      |
| Faydaları uygulamanız için uygunsa [AAC ViewModelleri](/docs/app-architecture/architecture-components/ui-layer-libraries/lifecycle-aware-components/viewmodel/about-viewmodel)ni kullanın.<br/><span style="color:green"> Strongly recommended:</span> | [Business logic'i handle etmek](/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer.md#types-of-logic) için AAC ViewModels'i kullanın ve UI state'ini UI'ye göstermek için uygulama verilerini getirin (Compose veya Android Views).</br>     See more [ViewModel best practices](/docs/app-architecture/guide-to-app-architecture/architecture-recommendations.md#viewmodel) here.</br>See the benefits of [ViewModels here](/docs/app-architecture/ui-layer/state-holders-and-ui-state.md#the-viewmodel-as-a-business-logic-state-holder). |
| Yaşam döngüsüne duyarlı UI state collection kullanın.<br/><span style="color:green"> Strongly recommended:</span>                                                                                                                                      | Uygun yaşam döngüsüne duyarlı coroutine builder kullanarak UI state'ini UI'dan collect edin: View sisteminde repeatOnLifecycle ve Jetpack Compose'da collectAsStateWithLifecycle.</br>Read more about [repeatOnLifecycle](https://medium.com/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda).</br> Read more about about [collectAsStateWithLifecycle](https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3).                                                                                    |
| ViewModel'den UI'ye event göndermeyin.<br/><span style="color:green"> Strongly recommended:</span>                                                                                                                                                     | Event'i ViewModel'de doğrudan işleyin ve event'in işlenmesinin sonucuyla bir state güncellemesine neden olun. UI event'leri hakkında daha fazla bilgiyi [burada](/docs/app-architecture/ui-layer/ui-events.md#handle-viewmodel-events) bulabilirsiniz.                                                                                                                                                                                                                                                                                                                |
| Single-activity application kullanin.<br/><span style="color:deepskyblue"> Recommended</span>                                                                                                                                                          | Uygulamanızın birden fazla ekranı varsa ekranlar arasında gezinmek ve uygulamanıza deep link vermek için [Navigation Fragments](https://developer.android.com/guide/navigation) veya [Navigation Compose](https://developer.android.com/jetpack/compose/navigation) kullanın.                                                                                                                                                                                                                                                                                         |
| [Jetpack Compose](https://developer.android.com/jetpack/compose) kullanin.<br/><span style="color:deepskyblue"> Recommended</span>                                                                                                                     | Telefonlar, tabletler, katlanabilir cihazlar ve Wear OS için yeni uygulamalar oluşturmak üzere Jetpack Compose'u kullanın.                                                                                                                                                                                                                                                                                                                                                                                                                                            |

Aşağıdaki kod parçacığı, UI state'inin yaşam döngüsüne duyarlı bir şekilde nasıl collect edileceğini özetlemektedir:
```kotlin
//Views
class MyFragment : Fragment() {

    private val viewModel: MyViewModel by viewModel()

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect {
                    // Process item
                }
            }
        }
    }
}

//Compose
@Composable
fun MyScreen(
    viewModel: MyViewModel = viewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
}
```
### ViewModel
ViewModeller, UI state'ini sağlamaktan ve data katmanına erişimden sorumludur. ViewModel'ler için bazı best practiceler aşağıda verilmiştir:

| Recommendation                                                                                                                                                                                                                                        | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [ViewModeller](/docs/app-architecture/guide-to-app-architecture/ui-layer/state-holders-and-ui-state.md#business-logic-and-its-state-holder) Android yaşam döngüsünden bağımsız olmalıdır.<br/><span style="color:green"> Strongly recommended:</span> | ViewModel'ler Yaşam Döngüsü ile ilgili herhangi bir tipe referans tutmamalıdır. Activity, Fragment, Context veya Resources'ı bağımlılık olarak geçirmeyin. Bir şeyin ViewModel'de bir Context'e ihtiyacı varsa, bunun doğru katmanda olup olmadığını mutlaka değerlendirmelisiniz.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| [Coroutine'leri ve flow'ları](https://developer.android.com/kotlin/coroutines) kullanın.<br/><span style="color:green"> Strongly recommended:</span>                                                                                                  | ViewModel, data veya domain katmanları ile etkileşime girer:</br>Uygulama verilerini almak için Kotlin flow'ları,</br>   [viewModelScope](/docs/app-architecture/architecture-coponents-ui-layer-libraries/lifecycle-aware-components/use-kotlin-coroutines-with-lifecycle-aware-components.md#viewmodelscope) kullanarak actionlari gerçekleştirmek için suspend fonksiyonlari kullanin.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Ekran seviyesinde ViewModelleri kullanın.</br><span style="color:green"> Strongly recommended:</span>                                                                                                                                                 | ViewModel'ları yeniden kullanılabilir UI parçalarında kullanmayın. ViewModel'leri şuralarda kullanmalısınız;</br>Screen-level composables,</br>Activities/Fragments in Views,</br>Destinations or graphs when using [Jetpack Navigation](https://developer.android.com/guide/navigation).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| Use [plain state holder classes](/docs/app-architecture/guide-to-app-architecture/ui-layer/state-holders-and-ui-state.md#ui-logic-and-its-state-holder) in reusable UI components.</br><span style="color:green"> Strongly recommended:</span>        | Yeniden kullanılabilir UI component'lerinde karmaşıklığı ele almak için düz state holder sınıflarını kullanın. Bunu yaparak, state harici olarak çağrılabilir ve kontrol edilebilir.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| [AndroidViewModel](https://developer.android.com/reference/androidx/lifecycle/AndroidViewModel) kullanma.<br/><span style="color:deepskyblue"> Recommended</span>                                                                                     | [ViewModel](https://developer.android.com/reference/androidx/lifecycle/ViewModel) class kullanin, AndroidViewModel kullanmayin. ViewModelde Application class kullanmamalisiniz. Bunun yerine, bağımlılığı UI veya data katmanına taşıyın.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| Bir UI state açığa çıkarın.<br/><span style="color:deepskyblue"> Recommended</span>                                                                                                                                                                   | ViewModeller, uiState adlı single property aracılığıyla UI'ye veri göstermelidir. UI birden fazla, ilgisiz veri parçası gösteriyorsa, VM [multiple UI state property](/docs/app-architecture/guide-to-app-architecture/ui-layer/about-the-ui-layer.md#additional-considerations) gösterebilir.</br>uiState'i bir StateFlow yapmalısınız.</br>Veriler hiyerarşinin diğer katmanlarından bir veri akışı olarak geliyorsa, [WhileSubscribed(5000)](https://medium.com/androiddevelopers/migrating-from-livedata-to-kotlins-flow-379292f419fb) ilkesiyle ([örnek](https://github.com/android/compose-samples/blob/main/JetNews/app/src/main/java/com/example/jetnews/ui/interests/InterestsViewModel.kt#L56)) [stateIn](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html) operatörünü kullanarak uiState oluşturmalısınız.</br>Data katmanından gelen veri akışlarının olmadığı daha basit durumlar için, immutable bir StateFlow olarak açığa çıkan bir MutableStateFlow kullanmak kabul edilebilir ([örnek](https://github.com/android/compose-samples/blob/main/Jetcaster/app/src/main/java/com/example/jetcaster/ui/home/category/PodcastCategoryViewModel.kt#L37)).</br>Data, error ve loading sinyalleri içerebilen bir data class olarak ${Screen}UiState'e sahip olmayı seçebilirsiniz. Bu sınıf, farklı statelerin özel olması halinde sealed class da olabilir.Application sınıfı ViewModel'de kullanılmamalıdır. Application sınıfı ViewModel'de kullanılmamalıdır. Bunun yerine, bağımlılığı kullanıcı arayüzüne veya veri katmanına taşıyın. |

Aşağıdaki kod parçacığı, UI state'inin bir ViewModel'den nasıl açığa çıkarılacağını özetlemektedir:
```kotlin
@HiltViewModel
class BookmarksViewModel @Inject constructor(
    newsRepository: NewsRepository
) : ViewModel() {

    val feedState: StateFlow<NewsFeedUiState> =
        newsRepository
            .getNewsResourcesStream()
            .mapToFeedState(savedNewsResourcesState)
            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(5_000),
                initialValue = NewsFeedUiState.Loading
            )

    // ...
}
```

### Lifecycle

Aşağıda [Android yaşam döngüsü](/docs/app-architecture/app-entry-points/activities/the-activity-lifecycle) ile çalışmaya yönelik best practiceler yer almaktadır:

| Recommendation                                                                                                                             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|--------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Activity'lerde veya Fragment'larda yaşam döngüsü metotlarını override etmeyin.</br><span style="color:green"> Strongly recommended:</span> | Activity'lerde veya Fragment'larda onResume gibi yaşam döngüsü metodlarını override etmeyin. Bunun yerine [LifecycleObserver](https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver) kullanın. Uygulamanın, yaşam döngüsü belirli bir Lifecycle.State değerine ulaştığında iş yapması gerekiyorsa [repeatOnLifecycle](https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#(androidx.lifecycle.Lifecycle).repeatOnLifecycle(androidx.lifecycle.Lifecycle.State,kotlin.coroutines.SuspendFunction1)) API'sini kullanın. |

Aşağıdaki kod parçacığı, belirli bir Yaşam Döngüsü state'i verildiğinde işlemlerin nasıl gerçekleştirileceğini özetlemektedir:
```kotlin
//Views
class MyFragment: Fragment() {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewLifecycleOwner.lifecycle.addObserver(object : DefaultLifecycleObserver {
            override fun onResume(owner: LifecycleOwner) {
                // ...
            }
            override fun onPause(owner: LifecycleOwner) {
                // ...
            }
        }
    }
}

//Compose
@Composable
fun MyApp() {

    val lifecycleOwner = LocalLifecycleOwner.current
    DisposableEffect(lifecycleOwner, ...) {
        val lifecycleObserver = object : DefaultLifecycleObserver {
            override fun onStop(owner: LifecycleOwner) {
                // ...
            }
        }

        lifecycleOwner.lifecycle.addObserver(lifecycleObserver)
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(lifecycleObserver)
        }
    }
}
```

### Handle dependencies
Componentler arasındaki bağımlılıkları yönetirken gözlemlemeniz gereken birkaç best practice vardir:

| Recommendation                                                                                                                                                       | Description                                                                                                                                                                                                                                                                                                                                                                                                |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [ Dependency injection](/docs/app-arhitecture/dependency-injection/about-dependency-injection) kullanin.</br><span style="color:green"> Strongly recommended:</span> | Dependency injection best practiceleri kullanin, ozellikle mumkun oldugunca [constructor injection ](/docs/app-arhitecture/dependency-injection/about-dependency-injection#what-is-the-dependency-injection)kullanin.                                                                                                                                                                                      |
| Gerektiginde bir componentin scope’nu belirleyin.</br><span style="color:green"> Strongly recommended:</span>                                                        | Scope to a [dependency container](/docs/app-arhitecture/dependency-injection/manual-dependency-injection#managing-dependencies-with-a-coontainer); tip paylaşılması gereken mutable veriler içerdiğinde veya tipin init edilmesi pahalı olduğunda ve uygulamada yaygın olarak kullanıldığında.                                                                                                             |
| [Hilt](/docs/app-arhitecture/dependency-injection/dependency-injection-with-hilt) kullanin.<br/><span style="color:deepskyblue"> Recommended</span>                  | Basit uygulamalarda Hilt veya [manual dependency injection](/docs/app-arhitecture/dependency-injection/manual-dependency-injection) kullanin. Uygulamaniz karmasiklastiginda Hilt kullanin. Ornegin asagidakilere sahipseniz: </br>Multiple screens with ViewModels—integration</br>WorkManager usage—integration</br>Advance usage of Navigation, such as ViewModels scoped to the nav graph—integration. |

### Testing
Aşağıda test için bazı best practiceler verilmiştir:

| Recommendation                                                                                                                                                       | Description                                                                                                                                                                                                                                                                                 |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [Neyi test edeceginizi bilin.](https://developer.android.com/training/testing/fundamentals/what-to-test)<br/><span style="color:green"> Strongly recommended:</span> | Unless the project is roughly as simple as a hello world app, you should test it, at minimum with:</br>Unit test ViewModels, including Flows.</br>Unit test data layer entities. That is, repositories and data sources.</br>UI navigation tests that are useful as regression tests in CI. |
| Prefer fakes to mocks.<br/><span style="color:green"> Strongly recommended:</span>                                                                                   | Read more in the [Use test doubles](https://developer.android.com/training/testing/fundamentals/test-doubles) in Android documentation.                                                                                                                                                     |
| Test StateFlows.<br/><span style="color:green"> Strongly recommended:</span>                                                                                         | When testing StateFlow:</br>[Assert on the value property](https://developer.android.com/kotlin/flow/test#stateflows) whenever possible</br>You should [create a collectJob](https://developer.android.com/kotlin/flow/test#statein) if using WhileSubscribed                               |

Daha fazla bilgi için [Android DAC'da neleri test etmeli](/docs/best-practices/testing/fundamentals/what-to-test-in-Android) kılavuzuna bakın.

### Models
Uygulamalarınızda model geliştirirken bu best practiceleri uymalısınız:

| Recommendation                                                                                                      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
|---------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Karmaşık uygulamalarda her katman için bir model oluşturun.<br/><span style="color:deepskyblue"> Recommended</span> | Karmaşık uygulamalarda, mantıklı olduğunda farklı katmanlarda veya componentlerde yeni modeller oluşturun. Aşağıdaki örnekleri göz önünde bulundurun:</br>Uzak bir veri kaynağı, ağ üzerinden aldığı modeli, yalnızca uygulamanın ihtiyaç duyduğu verileri içeren daha basit bir sınıfla eşleyebilir</br>Repository'ler DAO modellerini sadece UI katmanının ihtiyaç duyduğu bilgilerle daha basit data classlara eşleyebilir.</br>ViewModel, UiState sınıflarındaki data katmanı modellerini içerebilir. |


### Naming Conventions
Kod tabanınızı adlandırırken, aşağıdaki best practice'lerden haberdar olmalısınız:

| Recommendation                                                                                     | Description                                                                                                                                                                                                                                                                                                                                                                                                  |
|----------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Methodlari isimlendirmek.</br><span style="color:orangered"> Optional: </span>                     | Metodlar bir fiil cümlesi olmalıdır. Örneğin, makePayment().                                                                                                                                                                                                                                                                                                                                                 |
| Propertyleri isimlendirmek.</br><span style="color:orangered"> Optional: </span>                   | Propertyler bir isim cümlesi olmalıdır. Örneğin, inProgressTopicSelection.                                                                                                                                                                                                                                                                                                                                   |
| Data akislarini isimlendirmek</br><span style="color:orangered"> Optional: </span>                 | Bir sınıf bir Flow stream, LiveData veya başka bir stream sunduğunda, adlandırma kuralı get{model}Stream() şeklindedir. Örneğin, getAuthorStream(): Flow<Author>. Fonksiyon bir model listesi döndürüyorsa, model adı çoğul olmalıdır:getAuthorsStream(): Flow<List<Author>>                                                                                                                                 |
| Interface implementasyonlarini isimlendirmek.</br><span style="color:orangered"> Optional: </span> | Interfacelerin implementasyonları için isimler anlamlı olmalıdır. Daha iyi bir isim bulunamazsa önek olarak Default kullanın. Örneğin, bir NewsRepository interface'i için OfflineFirstNewsRepository veya InMemoryNewsRepository kullanabilirsiniz. Eğer iyi bir isim bulamazsanız, DefaultNewsRepository kullanın. Sahte implementasyonların önüne FakeAuthorsRepository'de olduğu gibi Fake eklenmelidir. |

### [Learning Pathway](https://developer.android.com/courses/pathways/android-architecture)